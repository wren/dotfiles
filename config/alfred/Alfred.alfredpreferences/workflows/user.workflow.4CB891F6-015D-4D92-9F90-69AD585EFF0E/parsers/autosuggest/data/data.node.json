[{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_abortcontroller","title":"Class: `AbortController`","description":"Stability: 1 - Experimental  A utility class used to signal cancelation in selected Promise-based APIs. The API is based on the Web API AbortController. const ac = new AbortController();  ac.signal.addEventListener('abort', () => console.log('Aborted!'),                            { once: true });  ac.abort();  console.log(ac.signal.aborted);  \/\/ Prints True"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_abortcontroller_abort","title":"`abortController.abort()`","description":"Triggers the abort signal, causing the abortController.signal to emit the 'abort' event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_buffer","title":"Class: `Buffer`","description":"<Function>  Used to handle binary data. See the buffer section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearimmediate_immediateobject","title":"`clearImmediate(immediateObject)`","description":"clearImmediate is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearinterval_intervalobject","title":"`clearInterval(intervalObject)`","description":"clearInterval is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cleartimeout_timeoutobject","title":"`clearTimeout(timeoutObject)`","description":"clearTimeout is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console","title":"`console`","description":"<Object>  Used to print to stdout and stderr. See the console section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_event","title":"`Event`","description":"A browser-compatible implementation of the Event class. See EventTarget and Event API for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_eventtarget","title":"`EventTarget`","description":"A browser-compatible implementation of the EventTarget class. See EventTarget and Event API for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_global","title":"`global`","description":"<Object> The global namespace object.  In browsers, the top-level scope is the global scope. This means that within the browser var something will define a new global variable. In Node.js this is different. The top-level scope is not the global scope; var something inside a Node.js module will be local to that module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_messagechannel","title":"`MessageChannel`","description":"The MessageChannel class. See MessageChannel for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_messageevent","title":"`MessageEvent`","description":"The MessageEvent class. See MessageEvent for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_messageport","title":"`MessagePort`","description":"The MessagePort class. See MessagePort for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process","title":"`process`","description":"<Object>  The process object. See the process object section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_queuemicrotask_callback","title":"`queueMicrotask(callback)`","description":"callback <Function> Function to be queued.  The queueMicrotask() method queues a microtask to invoke callback. If callback throws an exception, the process object 'uncaughtException' event will be emitted. The microtask queue is managed by V8 and may be used in a similar manner to the process.nextTick() queue, which is managed by Node.js. The process.nextTick() queue is always processed before the microtask queue within each turn of the Node.js event loop. \/\/ Here, `queueMicrotask()` is used to ensure the 'load' event is always \/\/ emitted asynchronously, and therefore consistently. Using \/\/ `process.nextTick()` here would result in the 'load' event always emitting \/\/ before any other promise jobs.  DataHandler.prototype.load = async function load(key) {   const hit = this._cache.get(url);   if (hit !== undefined) {     queueMicrotask(() => {       this.emit('load', hit);     });     return;   }    const data = await fetchData(key);   this._cache.set(url, data);   this.emit('load', data); };"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setimmediate_callback_args","title":"`setImmediate(callback[, ...args])`","description":"setImmediate is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setinterval_callback_delay_args","title":"`setInterval(callback, delay[, ...args])`","description":"setInterval is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_settimeout_callback_delay_args","title":"`setTimeout(callback, delay[, ...args])`","description":"setTimeout is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_textdecoder","title":"`TextDecoder`","description":"The WHATWG TextDecoder class. See the TextDecoder section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_textencoder","title":"`TextEncoder`","description":"The WHATWG TextEncoder class. See the TextEncoder section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url","title":"`URL`","description":"The WHATWG URL class. See the URL section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_urlsearchparams","title":"`URLSearchParams`","description":"The WHATWG URLSearchParams class. See the URLSearchParams section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_webassembly","title":"`WebAssembly`","description":"<Object>  The object that acts as the namespace for all W3C WebAssembly related functionality. See the Mozilla Developer Network for usage and compatibility."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process","title":"Process","description":"Source Code: lib\/process.js The process object is a global that provides information about, and control over, the current Node.js process. As a global, it is always available to Node.js applications without using require(). It can also be explicitly accessed using require(): const process = require('process');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_abort","title":"`process.abort()`","description":"The process.abort() method causes the Node.js process to exit immediately and generate a core file. This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_chdir_directory","title":"`process.chdir(directory)`","description":"The process.chdir() method changes the current working directory of the Node.js process or throws an exception if doing so fails (for instance, if the specified directory does not exist). console.log(`Starting directory: ${process.cwd()}`); try {   process.chdir('\/tmp');   console.log(`New directory: ${process.cwd()}`); } catch (err) {   console.error(`chdir: ${err}`); }  This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_cpuusage_previousvalue","title":"`process.cpuUsage([previousValue])`","description":"The process.cpuUsage() method returns the user and system CPU time usage of the current process, in an object with properties user and system, whose values are microsecond values (millionth of a second). These values measure time spent in user and system code respectively, and may end up being greater than actual elapsed time if multiple CPU cores are performing work for this process. The result of a previous call to process.cpuUsage() can be passed as the argument to the function, to get a diff reading. const startUsage = process.cpuUsage(); \/\/ { user: 38579, system: 6986 }  \/\/ spin the CPU for 500 milliseconds const now = Date.now(); while (Date.now() - now < 500);  console.log(process.cpuUsage(startUsage)); \/\/ { user: 514883, system: 11226 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_cwd","title":"`process.cwd()`","description":"The process.cwd() method returns the current working directory of the Node.js process. console.log(`Current directory: ${process.cwd()}`);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_disconnect","title":"`process.disconnect()`","description":"If the Node.js process is spawned with an IPC channel (see the Child Process and Cluster documentation), the process.disconnect() method will close the IPC channel to the parent process, allowing the child process to exit gracefully once there are no other connections keeping it alive. The effect of calling process.disconnect() is the same as calling ChildProcess.disconnect() from the parent process. If the Node.js process was not spawned with an IPC channel, process.disconnect() will be undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_dlopen_module_filename_flags","title":"`process.dlopen(module, filename[, flags])`","description":"The process.dlopen() method allows to dynamically load shared objects. It is primarily used by require() to load C++ Addons, and should not be used directly, except in special cases. In other words, require() should be preferred over process.dlopen(), unless there are specific reasons. The flags argument is an integer that allows to specify dlopen behavior. See the os.constants.dlopen documentation for details. If there are specific reasons to use process.dlopen() (for instance, to specify dlopen flags), it's often useful to use require.resolve() to look up the module's path. An important drawback when calling process.dlopen() is that the module instance must be passed. Functions exported by the C++ Addon will be accessible via module.exports. The example below shows how to load a C++ Addon, named as binding, that exports a foo function. All the symbols will be loaded before the call returns, by passing the RTLD_NOW constant. In this example the constant is assumed to be available. const os = require('os'); process.dlopen(module, require.resolve('binding'),                os.constants.dlopen.RTLD_NOW); module.exports.foo();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_emitwarning_warning_options","title":"`process.emitWarning(warning[, options])`","description":"The process.emitWarning() method can be used to emit custom or application specific process warnings. These can be listened for by adding a handler to the 'warning' event. \/\/ Emit a warning with a code and additional detail. process.emitWarning('Something happened!', {   code: 'MY_WARNING',   detail: 'This is some additional information' }); \/\/ Emits: \/\/ (node:56338) [MY_WARNING] Warning: Something happened! \/\/ This is some additional information  In this example, an Error object is generated internally by process.emitWarning() and passed through to the 'warning' handler. process.on('warning', (warning) => {   console.warn(warning.name);    \/\/ 'Warning'   console.warn(warning.message); \/\/ 'Something happened!'   console.warn(warning.code);    \/\/ 'MY_WARNING'   console.warn(warning.stack);   \/\/ Stack trace   console.warn(warning.detail);  \/\/ 'This is some additional information' });  If warning is passed as an Error object, the options argument is ignored."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_emitwarning_warning_type_code_ctor","title":"`process.emitWarning(warning[, type[, code]][, ctor])`","description":"The process.emitWarning() method can be used to emit custom or application specific process warnings. These can be listened for by adding a handler to the 'warning' event. \/\/ Emit a warning using a string. process.emitWarning('Something happened!'); \/\/ Emits: (node: 56338) Warning: Something happened!  \/\/ Emit a warning using a string and a type. process.emitWarning('Something Happened!', 'CustomWarning'); \/\/ Emits: (node:56338) CustomWarning: Something Happened!  process.emitWarning('Something happened!', 'CustomWarning', 'WARN001'); \/\/ Emits: (node:56338) [WARN001] CustomWarning: Something happened!  In each of the previous examples, an Error object is generated internally by process.emitWarning() and passed through to the 'warning' handler. process.on('warning', (warning) => {   console.warn(warning.name);   console.warn(warning.message);   console.warn(warning.code);   console.warn(warning.stack); });  If warning is passed as an Error object, it will be passed through to the 'warning' event handler unmodified (and the optional type, code and ctor arguments will be ignored): \/\/ Emit a warning using an Error object. const myWarning = new Error('Something happened!'); \/\/ Use the Error name property to specify the type name myWarning.name = 'CustomWarning'; myWarning.code = 'WARN001';  process.emitWarning(myWarning); \/\/ Emits: (node:56338) [WARN001] CustomWarning: Something happened!  A TypeError is thrown if warning is anything other than a string or Error object. While process warnings use Error objects, the process warning mechanism is not a replacement for normal error handling mechanisms. The following additional handling is implemented if the warning type is 'DeprecationWarning':  If the --throw-deprecation command-line flag is used, the deprecation warning is thrown as an exception rather than being emitted as an event. If the --no-deprecation command-line flag is used, the deprecation warning is suppressed. If the --trace-deprecation command-line flag is used, the deprecation warning is printed to stderr along with the full stack trace."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_avoiding_duplicate_warnings","title":"Avoiding duplicate warnings","description":"As a best practice, warnings should be emitted only once per process. To do so, it is recommended to place the emitWarning() behind a simple boolean flag as illustrated in the example below: function emitMyWarning() {   if (!emitMyWarning.warned) {     emitMyWarning.warned = true;     process.emitWarning('Only warn once!');   } } emitMyWarning(); \/\/ Emits: (node: 56339) Warning: Only warn once! emitMyWarning(); \/\/ Emits nothing"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_exit_code","title":"`process.exit([code])`","description":"The process.exit() method instructs Node.js to terminate the process synchronously with an exit status of code. If code is omitted, exit uses either the 'success' code 0 or the value of process.exitCode if it has been set. Node.js will not terminate until all the 'exit' event listeners are called. To exit with a 'failure' code: process.exit(1);  The shell that executed Node.js should see the exit code as 1. Calling process.exit() will force the process to exit as quickly as possible even if there are still asynchronous operations pending that have not yet completed fully, including I\/O operations to process.stdout and process.stderr. In most situations, it is not actually necessary to call process.exit() explicitly. The Node.js process will exit on its own if there is no additional work pending in the event loop. The process.exitCode property can be set to tell the process which exit code to use when the process exits gracefully. For instance, the following example illustrates a misuse of the process.exit() method that could lead to data printed to stdout being truncated and lost: \/\/ This is an example of what *not* to do: if (someConditionNotMet()) {   printUsageToStdout();   process.exit(1); }  The reason this is problematic is because writes to process.stdout in Node.js are sometimes asynchronous and may occur over multiple ticks of the Node.js event loop. Calling process.exit(), however, forces the process to exit before those additional writes to stdout can be performed. Rather than calling process.exit() directly, the code should set the process.exitCode and allow the process to exit naturally by avoiding scheduling any additional work for the event loop: \/\/ How to properly set the exit code while letting \/\/ the process exit gracefully. if (someConditionNotMet()) {   printUsageToStdout();   process.exitCode = 1; }  If it is necessary to terminate the Node.js process due to an error condition, throwing an uncaught error and allowing the process to terminate accordingly is safer than calling process.exit(). In Worker threads, this function stops the current thread rather than the current process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getegid","title":"`process.getegid()`","description":"The process.getegid() method returns the numerical effective group identity of the Node.js process. (See getegid(2).) if (process.getegid) {   console.log(`Current gid: ${process.getegid()}`); }  This function is only available on POSIX platforms (i.e. not Windows or Android)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_geteuid","title":"`process.geteuid()`","description":"The process.geteuid() method returns the numerical effective user identity of the process. (See geteuid(2).) if (process.geteuid) {   console.log(`Current uid: ${process.geteuid()}`); }  This function is only available on POSIX platforms (i.e. not Windows or Android)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getgid","title":"`process.getgid()`","description":"The process.getgid() method returns the numerical group identity of the process. (See getgid(2).) if (process.getgid) {   console.log(`Current gid: ${process.getgid()}`); }  This function is only available on POSIX platforms (i.e. not Windows or Android)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getgroups","title":"`process.getgroups()`","description":"The process.getgroups() method returns an array with the supplementary group IDs. POSIX leaves it unspecified if the effective group ID is included but Node.js ensures it always is. if (process.getgroups) {   console.log(process.getgroups()); \/\/ [ 16, 21, 297 ] }  This function is only available on POSIX platforms (i.e. not Windows or Android)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_getuid","title":"`process.getuid()`","description":"The process.getuid() method returns the numeric user identity of the process. (See getuid(2).) if (process.getuid) {   console.log(`Current uid: ${process.getuid()}`); }  This function is only available on POSIX platforms (i.e. not Windows or Android)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_hasuncaughtexceptioncapturecallback","title":"`process.hasUncaughtExceptionCaptureCallback()`","description":"Indicates whether a callback has been set using process.setUncaughtExceptionCaptureCallback()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_hrtime_time","title":"`process.hrtime([time])`","description":"This is the legacy version of process.hrtime.bigint() before bigint was introduced in JavaScript. The process.hrtime() method returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array, where nanoseconds is the remaining part of the real time that can't be represented in second precision. time is an optional parameter that must be the result of a previous process.hrtime() call to diff with the current time. If the parameter passed in is not a tuple Array, a TypeError will be thrown. Passing in a user-defined array instead of the result of a previous call to process.hrtime() will lead to undefined behavior. These times are relative to an arbitrary time in the past, and not related to the time of day and therefore not subject to clock drift. The primary use is for measuring performance between intervals: const NS_PER_SEC = 1e9; const time = process.hrtime(); \/\/ [ 1800216, 25 ]  setTimeout(() => {   const diff = process.hrtime(time);   \/\/ [ 1, 552 ]    console.log(`Benchmark took ${diff[0] * NS_PER_SEC + diff[1]} nanoseconds`);   \/\/ Benchmark took 1000000552 nanoseconds }, 1000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_hrtime_bigint","title":"`process.hrtime.bigint()`","description":"The bigint version of the process.hrtime() method returning the current high-resolution real time in nanoseconds as a bigint. Unlike process.hrtime(), it does not support an additional time argument since the difference can just be computed directly by subtraction of the two bigints. const start = process.hrtime.bigint(); \/\/ 191051479007711n  setTimeout(() => {   const end = process.hrtime.bigint();   \/\/ 191052633396993n    console.log(`Benchmark took ${end - start} nanoseconds`);   \/\/ Benchmark took 1154389282 nanoseconds }, 1000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_initgroups_user_extragroup","title":"`process.initgroups(user, extraGroup)`","description":"The process.initgroups() method reads the \/etc\/group file and initializes the group access list, using all groups of which the user is a member. This is a privileged operation that requires that the Node.js process either have root access or the CAP_SETGID capability. Use care when dropping privileges: console.log(process.getgroups());         \/\/ [ 0 ] process.initgroups('nodeuser', 1000);     \/\/ switch user console.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000, 0 ] process.setgid(1000);                     \/\/ drop root gid console.log(process.getgroups());         \/\/ [ 27, 30, 46, 1000 ]  This function is only available on POSIX platforms (i.e. not Windows or Android). This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_kill_pid_signal","title":"`process.kill(pid[, signal])`","description":"The process.kill() method sends the signal to the process identified by pid. Signal names are strings such as 'SIGINT' or 'SIGHUP'. See Signal Events and kill(2) for more information. This method will throw an error if the target pid does not exist. As a special case, a signal of 0 can be used to test for the existence of a process. Windows platforms will throw an error if the pid is used to kill a process group. Even though the name of this function is process.kill(), it is really just a signal sender, like the kill system call. The signal sent may do something other than kill the target process. process.on('SIGHUP', () => {   console.log('Got SIGHUP signal.'); });  setTimeout(() => {   console.log('Exiting.');   process.exit(0); }, 100);  process.kill(process.pid, 'SIGHUP');  When SIGUSR1 is received by a Node.js process, Node.js will start the debugger. See Signal Events."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_memoryusage","title":"`process.memoryUsage()`","description":"The process.memoryUsage() method returns an object describing the memory usage of the Node.js process measured in bytes. For example, the code: console.log(process.memoryUsage());  Will generate:  {   rss: 4935680,   heapTotal: 1826816,   heapUsed: 650472,   external: 49879,   arrayBuffers: 9386 }   heapTotal and heapUsed refer to V8's memory usage. external refers to the memory usage of C++ objects bound to JavaScript objects managed by V8. rss, Resident Set Size, is the amount of space occupied in the main memory device (that is a subset of the total allocated memory) for the process, including all C++ and JavaScript objects and code. arrayBuffers refers to memory allocated for ArrayBuffers and SharedArrayBuffers, including all Node.js Buffers. This is also included in the external value. When Node.js is used as an embedded library, this value may be 0 because allocations for ArrayBuffers may not be tracked in that case.  When using Worker threads, rss will be a value that is valid for the entire process, while the other fields will only refer to the current thread."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_nexttick_callback_args","title":"`process.nextTick(callback[, ...args])`","description":"process.nextTick() adds callback to the \"next tick queue\". This queue is fully drained after the current operation on the JavaScript stack runs to completion and before the event loop is allowed to continue. It's possible to create an infinite loop if one were to recursively call process.nextTick(). See the Event Loop guide for more background. console.log('start'); process.nextTick(() => {   console.log('nextTick callback'); }); console.log('scheduled'); \/\/ Output: \/\/ start \/\/ scheduled \/\/ nextTick callback  This is important when developing APIs in order to give users the opportunity to assign event handlers after an object has been constructed but before any I\/O has occurred: function MyThing(options) {   this.setupOptions(options);    process.nextTick(() => {     this.startDoingStuff();   }); }  const thing = new MyThing(); thing.getReadyForStuff();  \/\/ thing.startDoingStuff() gets called now, not before.  It is very important for APIs to be either 100% synchronous or 100% asynchronous. Consider this example: \/\/ WARNING!  DO NOT USE!  BAD UNSAFE HAZARD! function maybeSync(arg, cb) {   if (arg) {     cb();     return;   }    fs.stat('file', cb); }  This API is hazardous because in the following case: const maybeTrue = Math.random() > 0.5;  maybeSync(maybeTrue, () => {   foo(); });  bar();  It is not clear whether foo() or bar() will be called first. The following approach is much better: function definitelyAsync(arg, cb) {   if (arg) {     process.nextTick(cb);     return;   }    fs.stat('file', cb); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_resourceusage","title":"`process.resourceUsage()`","description":"console.log(process.resourceUsage()); \/*   Will output:   {     userCPUTime: 82872,     systemCPUTime: 4143,     maxRSS: 33164,     sharedMemorySize: 0,     unsharedDataSize: 0,     unsharedStackSize: 0,     minorPageFault: 2469,     majorPageFault: 0,     swappedOut: 0,     fsRead: 0,     fsWrite: 8,     ipcSent: 0,     ipcReceived: 0,     signalsCount: 0,     voluntaryContextSwitches: 79,     involuntaryContextSwitches: 1   } *\/"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_send_message_sendhandle_options_callback","title":"`process.send(message[, sendHandle[, options]][, callback])`","description":"If Node.js is spawned with an IPC channel, the process.send() method can be used to send messages to the parent process. Messages will be received as a 'message' event on the parent's ChildProcess object. If Node.js was not spawned with an IPC channel, process.send will be undefined. The message goes through serialization and parsing. The resulting message might not be the same as what is originally sent."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setegid_id","title":"`process.setegid(id)`","description":"The process.setegid() method sets the effective group identity of the process. (See setegid(2).) The id can be passed as either a numeric ID or a group name string. If a group name is specified, this method blocks while resolving the associated a numeric ID. if (process.getegid && process.setegid) {   console.log(`Current gid: ${process.getegid()}`);   try {     process.setegid(501);     console.log(`New gid: ${process.getegid()}`);   } catch (err) {     console.log(`Failed to set gid: ${err}`);   } }  This function is only available on POSIX platforms (i.e. not Windows or Android). This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_seteuid_id","title":"`process.seteuid(id)`","description":"The process.seteuid() method sets the effective user identity of the process. (See seteuid(2).) The id can be passed as either a numeric ID or a username string. If a username is specified, the method blocks while resolving the associated numeric ID. if (process.geteuid && process.seteuid) {   console.log(`Current uid: ${process.geteuid()}`);   try {     process.seteuid(501);     console.log(`New uid: ${process.geteuid()}`);   } catch (err) {     console.log(`Failed to set uid: ${err}`);   } }  This function is only available on POSIX platforms (i.e. not Windows or Android). This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setgid_id","title":"`process.setgid(id)`","description":"The process.setgid() method sets the group identity of the process. (See setgid(2).) The id can be passed as either a numeric ID or a group name string. If a group name is specified, this method blocks while resolving the associated numeric ID. if (process.getgid && process.setgid) {   console.log(`Current gid: ${process.getgid()}`);   try {     process.setgid(501);     console.log(`New gid: ${process.getgid()}`);   } catch (err) {     console.log(`Failed to set gid: ${err}`);   } }  This function is only available on POSIX platforms (i.e. not Windows or Android). This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setgroups_groups","title":"`process.setgroups(groups)`","description":"The process.setgroups() method sets the supplementary group IDs for the Node.js process. This is a privileged operation that requires the Node.js process to have root or the CAP_SETGID capability. The groups array can contain numeric group IDs, group names, or both. if (process.getgroups && process.setgroups) {   try {     process.setgroups([501]);     console.log(process.getgroups()); \/\/ new groups   } catch (err) {     console.log(`Failed to set groups: ${err}`);   } }  This function is only available on POSIX platforms (i.e. not Windows or Android). This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setuid_id","title":"`process.setuid(id)`","description":"The process.setuid(id) method sets the user identity of the process. (See setuid(2).) The id can be passed as either a numeric ID or a username string. If a username is specified, the method blocks while resolving the associated numeric ID. if (process.getuid && process.setuid) {   console.log(`Current uid: ${process.getuid()}`);   try {     process.setuid(501);     console.log(`New uid: ${process.getuid()}`);   } catch (err) {     console.log(`Failed to set uid: ${err}`);   } }  This function is only available on POSIX platforms (i.e. not Windows or Android). This feature is not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_setuncaughtexceptioncapturecallback_fn","title":"`process.setUncaughtExceptionCaptureCallback(fn)`","description":"The process.setUncaughtExceptionCaptureCallback() function sets a function that will be invoked when an uncaught exception occurs, which will receive the exception value itself as its first argument. If such a function is set, the 'uncaughtException' event will not be emitted. If --abort-on-uncaught-exception was passed from the command line or set through v8.setFlagsFromString(), the process will not abort. Actions configured to take place on exceptions such as report generations will be affected too To unset the capture function, process.setUncaughtExceptionCaptureCallback(null) may be used. Calling this method with a non-null argument while another capture function is set will throw an error. Using this function is mutually exclusive with using the deprecated domain built-in module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_umask","title":"`process.umask()`","description":"process.umask() returns the Node.js process's file mode creation mask. Child processes inherit the mask from the parent process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_umask_mask","title":"`process.umask(mask)`","description":"process.umask(mask) sets the Node.js process's file mode creation mask. Child processes inherit the mask from the parent process. Returns the previous mask. const newmask = 0o022; const oldmask = process.umask(newmask); console.log(   `Changed umask from ${oldmask.toString(8)} to ${newmask.toString(8)}` );  In Worker threads, process.umask(mask) will throw an exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_uptime","title":"`process.uptime()`","description":"The process.uptime() method returns the number of seconds the current Node.js process has been running. The return value includes fractions of a second. Use Math.floor() to get whole seconds."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process_events","title":"Process events","description":"The process object is an instance of EventEmitter."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exit_codes","title":"Exit codes","description":"Node.js will normally exit with a 0 status code when no more async operations are pending. The following status codes are used in other cases:  1 Uncaught Fatal Exception: There was an uncaught exception, and it was not handled by a domain or an 'uncaughtException' event handler. 2: Unused (reserved by Bash for builtin misuse) 3 Internal JavaScript Parse Error: The JavaScript source code internal in the Node.js bootstrapping process caused a parse error. This is extremely rare, and generally can only happen during development of Node.js itself. 4 Internal JavaScript Evaluation Failure: The JavaScript source code internal in the Node.js bootstrapping process failed to return a function value when evaluated. This is extremely rare, and generally can only happen during development of Node.js itself. 5 Fatal Error: There was a fatal unrecoverable error in V8. Typically a message will be printed to stderr with the prefix FATAL ERROR. 6 Non-function Internal Exception Handler: There was an uncaught exception, but the internal fatal exception handler function was somehow set to a non-function, and could not be called. 7 Internal Exception Handler Run-Time Failure: There was an uncaught exception, and the internal fatal exception handler function itself threw an error while attempting to handle it. This can happen, for example, if an 'uncaughtException' or domain.on('error') handler throws an error. 8: Unused. In previous versions of Node.js, exit code 8 sometimes indicated an uncaught exception. 9 Invalid Argument: Either an unknown option was specified, or an option requiring a value was provided without a value. 10 Internal JavaScript Run-Time Failure: The JavaScript source code internal in the Node.js bootstrapping process threw an error when the bootstrapping function was called. This is extremely rare, and generally can only happen during development of Node.js itself. 12 Invalid Debug Argument: The --inspect and\/or --inspect-brk options were set, but the port number chosen was invalid or unavailable. 13 Unfinished Top-Level Await: await was used outside of a function in the top-level code, but the passed Promise never resolved. >128 Signal Exits: If Node.js receives a fatal signal such as SIGKILL or SIGHUP, then its exit code will be 128 plus the value of the signal code. This is a standard POSIX practice, since exit codes are defined to be 7-bit integers, and signal exits set the high-order bit, and then contain the value of the signal code. For example, signal SIGABRT has value 6, so the expected exit code will be 128 + 6, or 134."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require","title":"`require()`","description":"This variable may appear to be global but is not. See require()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_about_this_documentation","title":"About this documentation","description":"Welcome to the official API reference documentation for Node.js! Node.js is a JavaScript runtime built on the V8 JavaScript engine."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_contributing","title":"Contributing","description":"Report errors in this documentation in the issue tracker. See the contributing guide for directions on how to submit pull requests."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stability_index","title":"Stability index","description":"Throughout the documentation are indications of a section's stability. Some APIs are so proven and so relied upon that they are unlikely to ever change at all. Others are brand new and experimental, or known to be hazardous. The stability indices are as follows:  Stability: 0 - Deprecated. The feature may emit warnings. Backward compatibility is not guaranteed.    Stability: 1 - Experimental. The feature is not subject to Semantic Versioning rules. Non-backward compatible changes or removal may occur in any future release. Use of the feature is not recommended in production environments.    Stability: 2 - Stable. Compatibility with the npm ecosystem is a high priority.  Use caution when making use of Experimental features, particularly within modules. Users may not be aware that experimental features are being used. Bugs or behavior changes may surprise users when Experimental API modifications occur. To avoid surprises, use of an Experimental feature may need a command-line flag. Experimental features may also emit a warning."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_json_output","title":"JSON output","description":"Every .html document has a corresponding .json document. This is for IDEs and other utilities that consume the documentation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_system_calls_and_man_pages","title":"System calls and man pages","description":"Node.js functions which wrap a system call will document that. The docs link to the corresponding man pages which describe how the system call works. Most Unix system calls have Windows analogues. Still, behavior differences may be unavoidable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_c_addons","title":"C++ addons","description":"Addons are dynamically-linked shared objects written in C++. The require() function can load addons as ordinary Node.js modules. Addons provide an interface between JavaScript and C\/C++ libraries. There are three options for implementing addons: N-API, nan, or direct use of internal V8, libuv and Node.js libraries. Unless there is a need for direct access to functionality which is not exposed by N-API, use N-API. Refer to C\/C++ addons with N-API for more information on N-API. When not using N-API, implementing addons is complicated, involving knowledge of several components and APIs:   V8: the C++ library Node.js uses to provide the JavaScript implementation. V8 provides the mechanisms for creating objects, calling functions, etc. V8's API is documented mostly in the v8.h header file (deps\/v8\/include\/v8.h in the Node.js source tree), which is also available online.   libuv: The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform. It also serves as a cross-platform abstraction library, giving easy, POSIX-like access across all major operating systems to many common system tasks, such as interacting with the filesystem, sockets, timers, and system events. libuv also provides a pthreads-like threading abstraction that may be used to power more sophisticated asynchronous addons that need to move beyond the standard event loop. Addon authors are encouraged to think about how to avoid blocking the event loop with I\/O or other time-intensive tasks by off-loading work via libuv to non-blocking system operations, worker threads or a custom use of libuv's threads.   Internal Node.js libraries. Node.js itself exports C++ APIs that addons can use, the most important of which is the node::ObjectWrap class.   Node.js includes other statically linked libraries including OpenSSL. These other libraries are located in the deps\/ directory in the Node.js source tree. Only the libuv, OpenSSL, V8 and zlib symbols are purposefully re-exported by Node.js and may be used to various extents by addons. See Linking to libraries included with Node.js for additional information.   All of the following examples are available for download and may be used as the starting-point for an addon."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_hello_world","title":"Hello world","description":"This \"Hello world\" example is a simple addon, written in C++, that is the equivalent of the following JavaScript code: module.exports.hello = () => 'world';  First, create the file hello.cc: \/\/ hello.cc #include <node.h>  namespace demo {  using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Object; using v8::String; using v8::Value;  void Method(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   args.GetReturnValue().Set(String::NewFromUtf8(       isolate, \"world\").ToLocalChecked()); }  void Initialize(Local<Object> exports) {   NODE_SET_METHOD(exports, \"hello\", Method); }  NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)  }  \/\/ namespace demo  All Node.js addons must export an initialization function following the pattern: void Initialize(Local<Object> exports); NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)  There is no semi-colon after NODE_MODULE as it's not a function (see node.h). The module_name must match the filename of the final binary (excluding the .node suffix). In the hello.cc example, then, the initialization function is Initialize and the addon module name is addon. When building addons with node-gyp, using the macro NODE_GYP_MODULE_NAME as the first parameter of NODE_MODULE() will ensure that the name of the final binary will be passed to NODE_MODULE()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_context_aware_addons","title":"Context-aware addons","description":"There are environments in which Node.js addons may need to be loaded multiple times in multiple contexts. For example, the Electron runtime runs multiple instances of Node.js in a single process. Each instance will have its own require() cache, and thus each instance will need a native addon to behave correctly when loaded via require(). From the addon's perspective, this means that it must support multiple initializations. A context-aware addon can be constructed by using the macro NODE_MODULE_INITIALIZER, which expands to the name of a function which Node.js will expect to find when it loads an addon. An addon can thus be initialized as in the following example: using namespace v8;  extern \"C\" NODE_MODULE_EXPORT void NODE_MODULE_INITIALIZER(Local<Object> exports,                         Local<Value> module,                         Local<Context> context) {   \/* Perform addon initialization steps here. *\/ }  Another option is to use the macro NODE_MODULE_INIT(), which will also construct a context-aware addon. Unlike NODE_MODULE(), which is used to construct an addon around a given addon initializer function, NODE_MODULE_INIT() serves as the declaration of such an initializer to be followed by a function body. The following three variables may be used inside the function body following an invocation of NODE_MODULE_INIT():  Local<Object> exports, Local<Value> module, and Local<Context> context  The choice to build a context-aware addon carries with it the responsibility of carefully managing global static data. Since the addon may be loaded multiple times, potentially even from different threads, any global static data stored in the addon must be properly protected, and must not contain any persistent references to JavaScript objects. The reason for this is that JavaScript objects are only valid in one context, and will likely cause a crash when accessed from the wrong context or from a different thread than the one on which they were created. The context-aware addon can be structured to avoid global static data by performing the following steps:  Define a class which will hold per-addon-instance data and which has a static member of the form static void DeleteInstance(void* data) {   \/\/ Cast `data` to an instance of the class and delete it. }   Heap-allocate an instance of this class in the addon initializer. This can be accomplished using the new keyword. Call node::AddEnvironmentCleanupHook(), passing it the above-created instance and a pointer to DeleteInstance(). This will ensure the instance is deleted when the environment is torn down. Store the instance of the class in a v8::External, and Pass the v8::External to all methods exposed to JavaScript by passing it to v8::FunctionTemplate::New() or v8::Function::New() which creates the native-backed JavaScript functions. The third parameter of v8::FunctionTemplate::New() or v8::Function::New()  accepts the v8::External and makes it available in the native callback using the v8::FunctionCallbackInfo::Data() method.  This will ensure that the per-addon-instance data reaches each binding that can be called from JavaScript. The per-addon-instance data must also be passed into any asynchronous callbacks the addon may create. The following example illustrates the implementation of a context-aware addon: #include <node.h>  using namespace v8;  class AddonData {  public:   explicit AddonData(Isolate* isolate):       call_count(0) {     \/\/ Ensure this per-addon-instance data is deleted at environment cleanup.     node::AddEnvironmentCleanupHook(isolate, DeleteInstance, this);   }    \/\/ Per-addon data.   int call_count;    static void DeleteInstance(void* data) {     delete static_cast<AddonData*>(data);   } };  static void Method(const v8::FunctionCallbackInfo<v8::Value>& info) {   \/\/ Retrieve the per-addon-instance data.   AddonData* data =       reinterpret_cast<AddonData*>(info.Data().As<External>()->Value());   data->call_count++;   info.GetReturnValue().Set((double)data->call_count); }  \/\/ Initialize this addon to be context-aware. NODE_MODULE_INIT(\/* exports, module, context *\/) {   Isolate* isolate = context->GetIsolate();    \/\/ Create a new instance of `AddonData` for this instance of the addon and   \/\/ tie its life cycle to that of the Node.js environment.   AddonData* data = new AddonData(isolate);    \/\/ Wrap the data in a `v8::External` so we can pass it to the method we   \/\/ expose.   Local<External> external = External::New(isolate, data);    \/\/ Expose the method `Method` to JavaScript, and make sure it receives the   \/\/ per-addon-instance data we created above by passing `external` as the   \/\/ third parameter to the `FunctionTemplate` constructor.   exports->Set(context,                String::NewFromUtf8(isolate, \"method\").ToLocalChecked(),                FunctionTemplate::New(isolate, Method, external)                   ->GetFunction(context).ToLocalChecked()).FromJust(); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_worker_support","title":"Worker support","description":"In order to be loaded from multiple Node.js environments, such as a main thread and a Worker thread, an add-on needs to either:  Be an N-API addon, or Be declared as context-aware using NODE_MODULE_INIT() as described above  In order to support Worker threads, addons need to clean up any resources they may have allocated when such a thread exists. This can be achieved through the usage of the AddEnvironmentCleanupHook() function: void AddEnvironmentCleanupHook(v8::Isolate* isolate,                                void (*fun)(void* arg),                                void* arg);  This function adds a hook that will run before a given Node.js instance shuts down. If necessary, such hooks can be removed before they are run using RemoveEnvironmentCleanupHook(), which has the same signature. Callbacks are run in last-in first-out order. If necessary, there is an additional pair of AddEnvironmentCleanupHook() and RemoveEnvironmentCleanupHook() overloads, where the cleanup hook takes a callback function. This can be used for shutting down asynchronous resources, such as any libuv handles registered by the addon. The following addon.cc uses AddEnvironmentCleanupHook: \/\/ addon.cc #include <node.h> #include <assert.h> #include <stdlib.h>  using node::AddEnvironmentCleanupHook; using v8::HandleScope; using v8::Isolate; using v8::Local; using v8::Object;  \/\/ Note: In a real-world application, do not rely on static\/global data. static char cookie[] = \"yum yum\"; static int cleanup_cb1_called = 0; static int cleanup_cb2_called = 0;  static void cleanup_cb1(void* arg) {   Isolate* isolate = static_cast<Isolate*>(arg);   HandleScope scope(isolate);   Local<Object> obj = Object::New(isolate);   assert(!obj.IsEmpty());  \/\/ assert VM is still alive   assert(obj->IsObject());   cleanup_cb1_called++; }  static void cleanup_cb2(void* arg) {   assert(arg == static_cast<void*>(cookie));   cleanup_cb2_called++; }  static void sanity_check(void*) {   assert(cleanup_cb1_called == 1);   assert(cleanup_cb2_called == 1); }  \/\/ Initialize this addon to be context-aware. NODE_MODULE_INIT(\/* exports, module, context *\/) {   Isolate* isolate = context->GetIsolate();    AddEnvironmentCleanupHook(isolate, sanity_check, nullptr);   AddEnvironmentCleanupHook(isolate, cleanup_cb2, cookie);   AddEnvironmentCleanupHook(isolate, cleanup_cb1, isolate); }  Test in JavaScript by running: \/\/ test.js require('.\/build\/Release\/addon');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_building","title":"Building","description":"Once the source code has been written, it must be compiled into the binary addon.node file. To do so, create a file called binding.gyp in the top-level of the project describing the build configuration of the module using a JSON-like format. This file is used by node-gyp, a tool written specifically to compile Node.js addons. {   \"targets\": [     {       \"target_name\": \"addon\",       \"sources\": [ \"hello.cc\" ]     }   ] }  A version of the node-gyp utility is bundled and distributed with Node.js as part of npm. This version is not made directly available for developers to use and is intended only to support the ability to use the npm install command to compile and install addons. Developers who wish to use node-gyp directly can install it using the command npm install -g node-gyp. See the node-gyp installation instructions for more information, including platform-specific requirements. Once the binding.gyp file has been created, use node-gyp configure to generate the appropriate project build files for the current platform. This will generate either a Makefile (on Unix platforms) or a vcxproj file (on Windows) in the build\/ directory. Next, invoke the node-gyp build command to generate the compiled addon.node file. This will be put into the build\/Release\/ directory. When using npm install to install a Node.js addon, npm uses its own bundled version of node-gyp to perform this same set of actions, generating a compiled version of the addon for the user's platform on demand. Once built, the binary addon can be used from within Node.js by pointing require() to the built addon.node module: \/\/ hello.js const addon = require('.\/build\/Release\/addon');  console.log(addon.hello()); \/\/ Prints: 'world'  Because the exact path to the compiled addon binary can vary depending on how it is compiled (i.e. sometimes it may be in .\/build\/Debug\/), addons can use the bindings package to load the compiled module. While the bindings package implementation is more sophisticated in how it locates addon modules, it is essentially using a try\u2026catch pattern similar to: try {   return require('.\/build\/Release\/addon.node'); } catch (err) {   return require('.\/build\/Debug\/addon.node'); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_linking_to_libraries_included_with_node_js","title":"Linking to libraries included with Node.js","description":"Node.js uses statically linked libraries such as V8, libuv and OpenSSL. All addons are required to link to V8 and may link to any of the other dependencies as well. Typically, this is as simple as including the appropriate #include <...> statements (e.g. #include <v8.h>) and node-gyp will locate the appropriate headers automatically. However, there are a few caveats to be aware of:   When node-gyp runs, it will detect the specific release version of Node.js and download either the full source tarball or just the headers. If the full source is downloaded, addons will have complete access to the full set of Node.js dependencies. However, if only the Node.js headers are downloaded, then only the symbols exported by Node.js will be available.   node-gyp can be run using the --nodedir flag pointing at a local Node.js source image. Using this option, the addon will have access to the full set of dependencies."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_loading_addons_using_require","title":"Loading addons using `require()`","description":"The filename extension of the compiled addon binary is .node (as opposed to .dll or .so). The require() function is written to look for files with the .node file extension and initialize those as dynamically-linked libraries. When calling require(), the .node extension can usually be omitted and Node.js will still find and initialize the addon. One caveat, however, is that Node.js will first attempt to locate and load modules or JavaScript files that happen to share the same base name. For instance, if there is a file addon.js in the same directory as the binary addon.node, then require('addon') will give precedence to the addon.js file and load it instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_native_abstractions_for_node_js","title":"Native abstractions for Node.js","description":"Each of the examples illustrated in this document directly use the Node.js and V8 APIs for implementing addons. The V8 API can, and has, changed dramatically from one V8 release to the next (and one major Node.js release to the next). With each change, addons may need to be updated and recompiled in order to continue functioning. The Node.js release schedule is designed to minimize the frequency and impact of such changes but there is little that Node.js can do to ensure stability of the V8 APIs. The Native Abstractions for Node.js (or nan) provide a set of tools that addon developers are recommended to use to keep compatibility between past and future releases of V8 and Node.js. See the nan examples for an illustration of how it can be used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_n_api","title":"N-API","description":"N-API is an API for building native addons. It is independent from the underlying JavaScript runtime (e.g. V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation. Addons are built\/packaged with the same approach\/tools outlined in this document (node-gyp, etc.). The only difference is the set of APIs that are used by the native code. Instead of using the V8 or Native Abstractions for Node.js APIs, the functions available in the N-API are used. Creating and maintaining an addon that benefits from the ABI stability provided by N-API carries with it certain implementation considerations. To use N-API in the above \"Hello world\" example, replace the content of hello.cc with the following. All other instructions remain the same. \/\/ hello.cc using N-API #include <node_api.h>  namespace demo {  napi_value Method(napi_env env, napi_callback_info args) {   napi_value greeting;   napi_status status;    status = napi_create_string_utf8(env, \"world\", NAPI_AUTO_LENGTH, &greeting);   if (status != napi_ok) return nullptr;   return greeting; }  napi_value init(napi_env env, napi_value exports) {   napi_status status;   napi_value fn;    status = napi_create_function(env, nullptr, 0, Method, nullptr, &fn);   if (status != napi_ok) return nullptr;    status = napi_set_named_property(env, exports, \"hello\", fn);   if (status != napi_ok) return nullptr;   return exports; }  NAPI_MODULE(NODE_GYP_MODULE_NAME, init)  }  \/\/ namespace demo  The functions available and how to use them are documented in C\/C++ addons with N-API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_addon_examples","title":"Addon examples","description":"Following are some example addons intended to help developers get started. The examples use the V8 APIs. Refer to the online V8 reference for help with the various V8 calls, and V8's Embedder's Guide for an explanation of several concepts used such as handles, scopes, function templates, etc. Each of these examples using the following binding.gyp file: {   \"targets\": [     {       \"target_name\": \"addon\",       \"sources\": [ \"addon.cc\" ]     }   ] }  In cases where there is more than one .cc file, simply add the additional filename to the sources array: \"sources\": [\"addon.cc\", \"myexample.cc\"]  Once the binding.gyp file is ready, the example addons can be configured and built using node-gyp: $ node-gyp configure build"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_function_arguments","title":"Function arguments","description":"Addons will typically expose objects and functions that can be accessed from JavaScript running within Node.js. When functions are invoked from JavaScript, the input arguments and return value must be mapped to and from the C\/C++ code. The following example illustrates how to read function arguments passed from JavaScript and how to return a result: \/\/ addon.cc #include <node.h>  namespace demo {  using v8::Exception; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::String; using v8::Value;  \/\/ This is the implementation of the \"add\" method \/\/ Input arguments are passed using the \/\/ const FunctionCallbackInfo<Value>& args struct void Add(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();    \/\/ Check the number of arguments passed.   if (args.Length() < 2) {     \/\/ Throw an Error that is passed back to JavaScript     isolate->ThrowException(Exception::TypeError(         String::NewFromUtf8(isolate,                             \"Wrong number of arguments\").ToLocalChecked()));     return;   }    \/\/ Check the argument types   if (!args[0]->IsNumber() || !args[1]->IsNumber()) {     isolate->ThrowException(Exception::TypeError(         String::NewFromUtf8(isolate,                             \"Wrong arguments\").ToLocalChecked()));     return;   }    \/\/ Perform the operation   double value =       args[0].As<Number>()->Value() + args[1].As<Number>()->Value();   Local<Number> num = Number::New(isolate, value);    \/\/ Set the return value (using the passed in   \/\/ FunctionCallbackInfo<Value>&)   args.GetReturnValue().Set(num); }  void Init(Local<Object> exports) {   NODE_SET_METHOD(exports, \"add\", Add); }  NODE_MODULE(NODE_GYP_MODULE_NAME, Init)  }  \/\/ namespace demo  Once compiled, the example addon can be required and used from within Node.js: \/\/ test.js const addon = require('.\/build\/Release\/addon');  console.log('This should be eight:', addon.add(3, 5));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_callbacks","title":"Callbacks","description":"It is common practice within addons to pass JavaScript functions to a C++ function and execute them from there. The following example illustrates how to invoke such callbacks: \/\/ addon.cc #include <node.h>  namespace demo {  using v8::Context; using v8::Function; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Null; using v8::Object; using v8::String; using v8::Value;  void RunCallback(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   Local<Context> context = isolate->GetCurrentContext();   Local<Function> cb = Local<Function>::Cast(args[0]);   const unsigned argc = 1;   Local<Value> argv[argc] = {       String::NewFromUtf8(isolate,                           \"hello world\").ToLocalChecked() };   cb->Call(context, Null(isolate), argc, argv).ToLocalChecked(); }  void Init(Local<Object> exports, Local<Object> module) {   NODE_SET_METHOD(module, \"exports\", RunCallback); }  NODE_MODULE(NODE_GYP_MODULE_NAME, Init)  }  \/\/ namespace demo  This example uses a two-argument form of Init() that receives the full module object as the second argument. This allows the addon to completely overwrite exports with a single function instead of adding the function as a property of exports. To test it, run the following JavaScript: \/\/ test.js const addon = require('.\/build\/Release\/addon');  addon((msg) => {   console.log(msg); \/\/ Prints: 'hello world' });  In this example, the callback function is invoked synchronously."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_object_factory","title":"Object factory","description":"Addons can create and return new objects from within a C++ function as illustrated in the following example. An object is created and returned with a property msg that echoes the string passed to createObject(): \/\/ addon.cc #include <node.h>  namespace demo {  using v8::Context; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Object; using v8::String; using v8::Value;  void CreateObject(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   Local<Context> context = isolate->GetCurrentContext();    Local<Object> obj = Object::New(isolate);   obj->Set(context,            String::NewFromUtf8(isolate,                                \"msg\").ToLocalChecked(),                                args[0]->ToString(context).ToLocalChecked())            .FromJust();    args.GetReturnValue().Set(obj); }  void Init(Local<Object> exports, Local<Object> module) {   NODE_SET_METHOD(module, \"exports\", CreateObject); }  NODE_MODULE(NODE_GYP_MODULE_NAME, Init)  }  \/\/ namespace demo  To test it in JavaScript: \/\/ test.js const addon = require('.\/build\/Release\/addon');  const obj1 = addon('hello'); const obj2 = addon('world'); console.log(obj1.msg, obj2.msg); \/\/ Prints: 'hello world'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_function_factory","title":"Function factory","description":"Another common scenario is creating JavaScript functions that wrap C++ functions and returning those back to JavaScript: \/\/ addon.cc #include <node.h>  namespace demo {  using v8::Context; using v8::Function; using v8::FunctionCallbackInfo; using v8::FunctionTemplate; using v8::Isolate; using v8::Local; using v8::Object; using v8::String; using v8::Value;  void MyFunction(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   args.GetReturnValue().Set(String::NewFromUtf8(       isolate, \"hello world\").ToLocalChecked()); }  void CreateFunction(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();    Local<Context> context = isolate->GetCurrentContext();   Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, MyFunction);   Local<Function> fn = tpl->GetFunction(context).ToLocalChecked();    \/\/ omit this to make it anonymous   fn->SetName(String::NewFromUtf8(       isolate, \"theFunction\").ToLocalChecked());    args.GetReturnValue().Set(fn); }  void Init(Local<Object> exports, Local<Object> module) {   NODE_SET_METHOD(module, \"exports\", CreateFunction); }  NODE_MODULE(NODE_GYP_MODULE_NAME, Init)  }  \/\/ namespace demo  To test: \/\/ test.js const addon = require('.\/build\/Release\/addon');  const fn = addon(); console.log(fn()); \/\/ Prints: 'hello world'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_wrapping_c_objects","title":"Wrapping C++ objects","description":"It is also possible to wrap C++ objects\/classes in a way that allows new instances to be created using the JavaScript new operator: \/\/ addon.cc #include <node.h> #include \"myobject.h\"  namespace demo {  using v8::Local; using v8::Object;  void InitAll(Local<Object> exports) {   MyObject::Init(exports); }  NODE_MODULE(NODE_GYP_MODULE_NAME, InitAll)  }  \/\/ namespace demo  Then, in myobject.h, the wrapper class inherits from node::ObjectWrap: \/\/ myobject.h #ifndef MYOBJECT_H #define MYOBJECT_H  #include <node.h> #include <node_object_wrap.h>  namespace demo {  class MyObject : public node::ObjectWrap {  public:   static void Init(v8::Local<v8::Object> exports);   private:   explicit MyObject(double value = 0);   ~MyObject();    static void New(const v8::FunctionCallbackInfo<v8::Value>& args);   static void PlusOne(const v8::FunctionCallbackInfo<v8::Value>& args);    double value_; };  }  \/\/ namespace demo  #endif  In myobject.cc, implement the various methods that are to be exposed. Below, the method plusOne() is exposed by adding it to the constructor's prototype: \/\/ myobject.cc #include \"myobject.h\"  namespace demo {  using v8::Context; using v8::Function; using v8::FunctionCallbackInfo; using v8::FunctionTemplate; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::ObjectTemplate; using v8::String; using v8::Value;  MyObject::MyObject(double value) : value_(value) { }  MyObject::~MyObject() { }  void MyObject::Init(Local<Object> exports) {   Isolate* isolate = exports->GetIsolate();   Local<Context> context = isolate->GetCurrentContext();    Local<ObjectTemplate> addon_data_tpl = ObjectTemplate::New(isolate);   addon_data_tpl->SetInternalFieldCount(1);  \/\/ 1 field for the MyObject::New()   Local<Object> addon_data =       addon_data_tpl->NewInstance(context).ToLocalChecked();    \/\/ Prepare constructor template   Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New, addon_data);   tpl->SetClassName(String::NewFromUtf8(isolate, \"MyObject\").ToLocalChecked());   tpl->InstanceTemplate()->SetInternalFieldCount(1);    \/\/ Prototype   NODE_SET_PROTOTYPE_METHOD(tpl, \"plusOne\", PlusOne);    Local<Function> constructor = tpl->GetFunction(context).ToLocalChecked();   addon_data->SetInternalField(0, constructor);   exports->Set(context, String::NewFromUtf8(       isolate, \"MyObject\").ToLocalChecked(),       constructor).FromJust(); }  void MyObject::New(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   Local<Context> context = isolate->GetCurrentContext();    if (args.IsConstructCall()) {     \/\/ Invoked as constructor: `new MyObject(...)`     double value = args[0]->IsUndefined() ?         0 : args[0]->NumberValue(context).FromMaybe(0);     MyObject* obj = new MyObject(value);     obj->Wrap(args.This());     args.GetReturnValue().Set(args.This());   } else {     \/\/ Invoked as plain function `MyObject(...)`, turn into construct call.     const int argc = 1;     Local<Value> argv[argc] = { args[0] };     Local<Function> cons =         args.Data().As<Object>()->GetInternalField(0).As<Function>();     Local<Object> result =         cons->NewInstance(context, argc, argv).ToLocalChecked();     args.GetReturnValue().Set(result);   } }  void MyObject::PlusOne(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();    MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.Holder());   obj->value_ += 1;    args.GetReturnValue().Set(Number::New(isolate, obj->value_)); }  }  \/\/ namespace demo  To build this example, the myobject.cc file must be added to the binding.gyp: {   \"targets\": [     {       \"target_name\": \"addon\",       \"sources\": [         \"addon.cc\",         \"myobject.cc\"       ]     }   ] }  Test it with: \/\/ test.js const addon = require('.\/build\/Release\/addon');  const obj = new addon.MyObject(10); console.log(obj.plusOne()); \/\/ Prints: 11 console.log(obj.plusOne()); \/\/ Prints: 12 console.log(obj.plusOne()); \/\/ Prints: 13  The destructor for a wrapper object will run when the object is garbage-collected. For destructor testing, there are command-line flags that can be used to make it possible to force garbage collection. These flags are provided by the underlying V8 JavaScript engine. They are subject to change or removal at any time. They are not documented by Node.js or V8, and they should never be used outside of testing."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_factory_of_wrapped_objects","title":"Factory of wrapped objects","description":"Alternatively, it is possible to use a factory pattern to avoid explicitly creating object instances using the JavaScript new operator: const obj = addon.createObject(); \/\/ instead of: \/\/ const obj = new addon.Object();  First, the createObject() method is implemented in addon.cc: \/\/ addon.cc #include <node.h> #include \"myobject.h\"  namespace demo {  using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Object; using v8::String; using v8::Value;  void CreateObject(const FunctionCallbackInfo<Value>& args) {   MyObject::NewInstance(args); }  void InitAll(Local<Object> exports, Local<Object> module) {   MyObject::Init(exports->GetIsolate());    NODE_SET_METHOD(module, \"exports\", CreateObject); }  NODE_MODULE(NODE_GYP_MODULE_NAME, InitAll)  }  \/\/ namespace demo  In myobject.h, the static method NewInstance() is added to handle instantiating the object. This method takes the place of using new in JavaScript: \/\/ myobject.h #ifndef MYOBJECT_H #define MYOBJECT_H  #include <node.h> #include <node_object_wrap.h>  namespace demo {  class MyObject : public node::ObjectWrap {  public:   static void Init(v8::Isolate* isolate);   static void NewInstance(const v8::FunctionCallbackInfo<v8::Value>& args);   private:   explicit MyObject(double value = 0);   ~MyObject();    static void New(const v8::FunctionCallbackInfo<v8::Value>& args);   static void PlusOne(const v8::FunctionCallbackInfo<v8::Value>& args);   static v8::Global<v8::Function> constructor;   double value_; };  }  \/\/ namespace demo  #endif  The implementation in myobject.cc is similar to the previous example: \/\/ myobject.cc #include <node.h> #include \"myobject.h\"  namespace demo {  using node::AddEnvironmentCleanupHook; using v8::Context; using v8::Function; using v8::FunctionCallbackInfo; using v8::FunctionTemplate; using v8::Global; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::String; using v8::Value;  \/\/ Warning! This is not thread-safe, this addon cannot be used for worker \/\/ threads. Global<Function> MyObject::constructor;  MyObject::MyObject(double value) : value_(value) { }  MyObject::~MyObject() { }  void MyObject::Init(Isolate* isolate) {   \/\/ Prepare constructor template   Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);   tpl->SetClassName(String::NewFromUtf8(isolate, \"MyObject\").ToLocalChecked());   tpl->InstanceTemplate()->SetInternalFieldCount(1);    \/\/ Prototype   NODE_SET_PROTOTYPE_METHOD(tpl, \"plusOne\", PlusOne);    Local<Context> context = isolate->GetCurrentContext();   constructor.Reset(isolate, tpl->GetFunction(context).ToLocalChecked());    AddEnvironmentCleanupHook(isolate, [](void*) {     constructor.Reset();   }, nullptr); }  void MyObject::New(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   Local<Context> context = isolate->GetCurrentContext();    if (args.IsConstructCall()) {     \/\/ Invoked as constructor: `new MyObject(...)`     double value = args[0]->IsUndefined() ?         0 : args[0]->NumberValue(context).FromMaybe(0);     MyObject* obj = new MyObject(value);     obj->Wrap(args.This());     args.GetReturnValue().Set(args.This());   } else {     \/\/ Invoked as plain function `MyObject(...)`, turn into construct call.     const int argc = 1;     Local<Value> argv[argc] = { args[0] };     Local<Function> cons = Local<Function>::New(isolate, constructor);     Local<Object> instance =         cons->NewInstance(context, argc, argv).ToLocalChecked();     args.GetReturnValue().Set(instance);   } }  void MyObject::NewInstance(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();    const unsigned argc = 1;   Local<Value> argv[argc] = { args[0] };   Local<Function> cons = Local<Function>::New(isolate, constructor);   Local<Context> context = isolate->GetCurrentContext();   Local<Object> instance =       cons->NewInstance(context, argc, argv).ToLocalChecked();    args.GetReturnValue().Set(instance); }  void MyObject::PlusOne(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();    MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.Holder());   obj->value_ += 1;    args.GetReturnValue().Set(Number::New(isolate, obj->value_)); }  }  \/\/ namespace demo  Once again, to build this example, the myobject.cc file must be added to the binding.gyp: {   \"targets\": [     {       \"target_name\": \"addon\",       \"sources\": [         \"addon.cc\",         \"myobject.cc\"       ]     }   ] }  Test it with: \/\/ test.js const createObject = require('.\/build\/Release\/addon');  const obj = createObject(10); console.log(obj.plusOne()); \/\/ Prints: 11 console.log(obj.plusOne()); \/\/ Prints: 12 console.log(obj.plusOne()); \/\/ Prints: 13  const obj2 = createObject(20); console.log(obj2.plusOne()); \/\/ Prints: 21 console.log(obj2.plusOne()); \/\/ Prints: 22 console.log(obj2.plusOne()); \/\/ Prints: 23"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_passing_wrapped_objects_around","title":"Passing wrapped objects around","description":"In addition to wrapping and returning C++ objects, it is possible to pass wrapped objects around by unwrapping them with the Node.js helper function node::ObjectWrap::Unwrap. The following examples shows a function add() that can take two MyObject objects as input arguments: \/\/ addon.cc #include <node.h> #include <node_object_wrap.h> #include \"myobject.h\"  namespace demo {  using v8::Context; using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::Number; using v8::Object; using v8::String; using v8::Value;  void CreateObject(const FunctionCallbackInfo<Value>& args) {   MyObject::NewInstance(args); }  void Add(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   Local<Context> context = isolate->GetCurrentContext();    MyObject* obj1 = node::ObjectWrap::Unwrap<MyObject>(       args[0]->ToObject(context).ToLocalChecked());   MyObject* obj2 = node::ObjectWrap::Unwrap<MyObject>(       args[1]->ToObject(context).ToLocalChecked());    double sum = obj1->value() + obj2->value();   args.GetReturnValue().Set(Number::New(isolate, sum)); }  void InitAll(Local<Object> exports) {   MyObject::Init(exports->GetIsolate());    NODE_SET_METHOD(exports, \"createObject\", CreateObject);   NODE_SET_METHOD(exports, \"add\", Add); }  NODE_MODULE(NODE_GYP_MODULE_NAME, InitAll)  }  \/\/ namespace demo  In myobject.h, a new public method is added to allow access to private values after unwrapping the object. \/\/ myobject.h #ifndef MYOBJECT_H #define MYOBJECT_H  #include <node.h> #include <node_object_wrap.h>  namespace demo {  class MyObject : public node::ObjectWrap {  public:   static void Init(v8::Isolate* isolate);   static void NewInstance(const v8::FunctionCallbackInfo<v8::Value>& args);   inline double value() const { return value_; }   private:   explicit MyObject(double value = 0);   ~MyObject();    static void New(const v8::FunctionCallbackInfo<v8::Value>& args);   static v8::Global<v8::Function> constructor;   double value_; };  }  \/\/ namespace demo  #endif  The implementation of myobject.cc is similar to before: \/\/ myobject.cc #include <node.h> #include \"myobject.h\"  namespace demo {  using node::AddEnvironmentCleanupHook; using v8::Context; using v8::Function; using v8::FunctionCallbackInfo; using v8::FunctionTemplate; using v8::Global; using v8::Isolate; using v8::Local; using v8::Object; using v8::String; using v8::Value;  \/\/ Warning! This is not thread-safe, this addon cannot be used for worker \/\/ threads. Global<Function> MyObject::constructor;  MyObject::MyObject(double value) : value_(value) { }  MyObject::~MyObject() { }  void MyObject::Init(Isolate* isolate) {   \/\/ Prepare constructor template   Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);   tpl->SetClassName(String::NewFromUtf8(isolate, \"MyObject\").ToLocalChecked());   tpl->InstanceTemplate()->SetInternalFieldCount(1);    Local<Context> context = isolate->GetCurrentContext();   constructor.Reset(isolate, tpl->GetFunction(context).ToLocalChecked());    AddEnvironmentCleanupHook(isolate, [](void*) {     constructor.Reset();   }, nullptr); }  void MyObject::New(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();   Local<Context> context = isolate->GetCurrentContext();    if (args.IsConstructCall()) {     \/\/ Invoked as constructor: `new MyObject(...)`     double value = args[0]->IsUndefined() ?         0 : args[0]->NumberValue(context).FromMaybe(0);     MyObject* obj = new MyObject(value);     obj->Wrap(args.This());     args.GetReturnValue().Set(args.This());   } else {     \/\/ Invoked as plain function `MyObject(...)`, turn into construct call.     const int argc = 1;     Local<Value> argv[argc] = { args[0] };     Local<Function> cons = Local<Function>::New(isolate, constructor);     Local<Object> instance =         cons->NewInstance(context, argc, argv).ToLocalChecked();     args.GetReturnValue().Set(instance);   } }  void MyObject::NewInstance(const FunctionCallbackInfo<Value>& args) {   Isolate* isolate = args.GetIsolate();    const unsigned argc = 1;   Local<Value> argv[argc] = { args[0] };   Local<Function> cons = Local<Function>::New(isolate, constructor);   Local<Context> context = isolate->GetCurrentContext();   Local<Object> instance =       cons->NewInstance(context, argc, argv).ToLocalChecked();    args.GetReturnValue().Set(instance); }  }  \/\/ namespace demo  Test it with: \/\/ test.js const addon = require('.\/build\/Release\/addon');  const obj1 = addon.createObject(10); const obj2 = addon.createObject(20); const result = addon.add(obj1, obj2);  console.log(result); \/\/ Prints: 30"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_n_api","title":"N-API","description":"N-API (pronounced N as in the letter, followed by API) is an API for building native Addons. It is independent from the underlying JavaScript runtime (for example, V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one major version to run on later major versions of Node.js without recompilation. The ABI Stability guide provides a more in-depth explanation. Addons are built\/packaged with the same approach\/tools outlined in the section titled C++ Addons. The only difference is the set of APIs that are used by the native code. Instead of using the V8 or Native Abstractions for Node.js APIs, the functions available in the N-API are used. APIs exposed by N-API are generally used to create and manipulate JavaScript values. Concepts and operations generally map to ideas specified in the ECMA-262 Language Specification. The APIs have the following properties:  All N-API calls return a status code of type napi_status. This status indicates whether the API call succeeded or failed. The API's return value is passed via an out parameter. All JavaScript values are abstracted behind an opaque type named napi_value. In case of an error status code, additional information can be obtained using napi_get_last_error_info. More information can be found in the error handling section Error handling.  The N-API is a C API that ensures ABI stability across Node.js versions and different compiler levels. A C++ API can be easier to use. To support using C++, the project maintains a C++ wrapper module called node-addon-api. This wrapper provides an inlineable C++ API. Binaries built with node-addon-api will depend on the symbols for the N-API C-based functions exported by Node.js. node-addon-api is a more efficient way to write code that calls N-API. Take, for example, the following node-addon-api code. The first section shows the node-addon-api code and the second section shows what actually gets used in the addon. Object obj = Object::New(env); obj[\"foo\"] = String::New(env, \"bar\");  napi_status status; napi_value object, string; status = napi_create_object(env, &object); if (status != napi_ok) {   napi_throw_error(env, ...);   return; }  status = napi_create_string_utf8(env, \"bar\", NAPI_AUTO_LENGTH, &string); if (status != napi_ok) {   napi_throw_error(env, ...);   return; }  status = napi_set_named_property(env, object, \"foo\", string); if (status != napi_ok) {   napi_throw_error(env, ...);   return; }  The end result is that the addon only uses the exported C APIs. As a result, it still gets the benefits of the ABI stability provided by the C API. When using node-addon-api instead of the C APIs, start with the API docs for node-addon-api. The N-API Resource\u00a0offers an excellent orientation and tips for developers just getting started with N-API and node-addon-api."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implications_of_abi_stability","title":"Implications of ABI stability","description":"Although N-API provides an ABI stability guarantee, other parts of Node.js do not, and any external libraries used from the addon may not. In particular, none of the following APIs provide an ABI stability guarantee across major versions:   the Node.js C++ APIs available via any of #include <node.h> #include <node_buffer.h> #include <node_version.h> #include <node_object_wrap.h>    the libuv APIs which are also included with Node.js and available via #include <uv.h>    the V8 API available via #include <v8.h>    Thus, for an addon to remain ABI-compatible across Node.js major versions, it must use N-API exclusively by restricting itself to using #include <node_api.h>  and by checking, for all external libraries that it uses, that the external library makes ABI stability guarantees similar to N-API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_building","title":"Building","description":"Unlike modules written in JavaScript, developing and deploying Node.js native addons using N-API requires an additional set of tools. Besides the basic tools required to develop for Node.js, the native addon developer requires a toolchain that can compile C and C++ code into a binary. In addition, depending upon how the native addon is deployed, the user of the native addon will also need to have a C\/C++ toolchain installed. For Linux developers, the necessary C\/C++ toolchain packages are readily available. GCC is widely used in the Node.js community to build and test across a variety of platforms. For many developers, the LLVM compiler infrastructure is also a good choice. For Mac developers, Xcode offers all the required compiler tools. However, it is not necessary to install the entire Xcode IDE. The following command installs the necessary toolchain: xcode-select --install  For Windows developers, Visual Studio offers all the required compiler tools. However, it is not necessary to install the entire Visual Studio IDE. The following command installs the necessary toolchain: npm install --global windows-build-tools  The sections below describe the additional tools available for developing and deploying Node.js native addons."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_build_tools","title":"Build tools","description":"Both the tools listed here require that users of the native addon have a C\/C++ toolchain installed in order to successfully install the native addon."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_gyp","title":"node-gyp","description":"node-gyp is a build system based on Google's GYP tool and comes bundled with npm. GYP, and therefore node-gyp, requires that Python be installed. Historically, node-gyp has been the tool of choice for building native addons. It has widespread adoption and documentation. However, some developers have run into limitations in node-gyp."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_uploading_precompiled_binaries","title":"Uploading precompiled binaries","description":"The three tools listed here permit native addon developers and maintainers to create and upload binaries to public or private servers. These tools are typically integrated with CI\/CD build systems like Travis CI and AppVeyor to build and upload binaries for a variety of platforms and architectures. These binaries are then available for download by users who do not need to have a C\/C++ toolchain installed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_pre_gyp","title":"node-pre-gyp","description":"node-pre-gyp is a tool based on node-gyp that adds the ability to upload binaries to a server of the developer's choice. node-pre-gyp has particularly good support for uploading binaries to Amazon S3."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_prebuild","title":"prebuild","description":"prebuild is a tool that supports builds using either node-gyp or CMake.js. Unlike node-pre-gyp which supports a variety of servers, prebuild uploads binaries only to GitHub releases. prebuild is a good choice for GitHub projects using CMake.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_prebuildify","title":"prebuildify","description":"prebuildify is a tool based on node-gyp. The advantage of prebuildify is that the built binaries are bundled with the native module when it's uploaded to npm. The binaries are downloaded from npm and are immediately available to the module user when the native module is installed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_usage","title":"Usage","description":"In order to use the N-API functions, include the file node_api.h which is located in the src directory in the node development tree: #include <node_api.h>  This will opt into the default NAPI_VERSION for the given release of Node.js. In order to ensure compatibility with specific versions of N-API, the version can be specified explicitly when including the header: #define NAPI_VERSION 3 #include <node_api.h>  This restricts the N-API surface to just the functionality that was available in the specified (and earlier) versions. Some of the N-API surface is experimental and requires explicit opt-in: #define NAPI_EXPERIMENTAL #include <node_api.h>  In this case the entire API surface, including any experimental APIs, will be available to the module code."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_n_api_version_matrix","title":"N-API version matrix","description":"N-API versions are additive and versioned independently from Node.js. Version 4 is an extension to version 3 in that it has all of the APIs from version 3 with some additions. This means that it is not necessary to recompile for new versions of Node.js which are listed as supporting a later version.               1     2     3           v6.x               v6.14.2*           v8.x     v8.6.0**     v8.10.0*     v8.11.2           v9.x     v9.0.0*     v9.3.0*     v9.11.0*           \u2265 v10.x     all releases     all releases     all releases                  4     5     6     7           v10.x     v10.16.0     v10.17.0     v10.20.0                v11.x     v11.8.0                          v12.x     v12.0.0     v12.11.0     v12.17.0     v12.19.0           v13.x     v13.0.0     v13.0.0                     v14.x     v14.0.0     v14.0.0     v14.0.0     v14.12.0     * N-API was experimental. ** Node.js 8.0.0 included N-API as experimental. It was released as N-API version 1 but continued to evolve until Node.js 8.6.0. The API is different in versions prior to Node.js 8.6.0. We recommend N-API version 3 or later. Each API documented for N-API will have a header named added in:, and APIs which are stable will have the additional header N-API version:. APIs are directly usable when using a Node.js version which supports the N-API version shown in N-API version: or higher. When using a Node.js version that does not support the N-API version: listed or if there is no N-API version: listed, then the API will only be available if #define NAPI_EXPERIMENTAL precedes the inclusion of node_api.h or js_native_api.h. If an API appears not to be available on a version of Node.js which is later than the one shown in added in: then this is most likely the reason for the apparent absence. The N-APIs associated strictly with accessing ECMAScript features from native code can be found separately in js_native_api.h and js_native_api_types.h. The APIs defined in these headers are included in node_api.h and node_api_types.h. The headers are structured in this way in order to allow implementations of N-API outside of Node.js. For those implementations the Node.js specific APIs may not be applicable. The Node.js-specific parts of an addon can be separated from the code that exposes the actual functionality to the JavaScript environment so that the latter may be used with multiple implementations of N-API. In the example below, addon.c and addon.h refer only to js_native_api.h. This ensures that addon.c can be reused to compile against either the Node.js implementation of N-API or any implementation of N-API outside of Node.js. addon_node.c is a separate file that contains the Node.js specific entry point to the addon and which instantiates the addon by calling into addon.c when the addon is loaded into a Node.js environment. \/\/ addon.h #ifndef _ADDON_H_ #define _ADDON_H_ #include <js_native_api.h> napi_value create_addon(napi_env env); #endif  \/\/ _ADDON_H_  \/\/ addon.c #include \"addon.h\"  #define NAPI_CALL(env, call)                                      \\   do {                                                            \\     napi_status status = (call);                                  \\     if (status != napi_ok) {                                      \\       const napi_extended_error_info* error_info = NULL;          \\       napi_get_last_error_info((env), &error_info);               \\       bool is_pending;                                            \\       napi_is_exception_pending((env), &is_pending);              \\       if (!is_pending) {                                          \\         const char* message = (error_info->error_message == NULL) \\             ? \"empty error message\"                               \\             : error_info->error_message;                          \\         napi_throw_error((env), NULL, message);                   \\         return NULL;                                              \\       }                                                           \\     }                                                             \\   } while(0)  static napi_value DoSomethingUseful(napi_env env, napi_callback_info info) {   \/\/ Do something useful.   return NULL; }  napi_value create_addon(napi_env env) {   napi_value result;   NAPI_CALL(env, napi_create_object(env, &result));    napi_value exported_function;   NAPI_CALL(env, napi_create_function(env,                                       \"doSomethingUseful\",                                       NAPI_AUTO_LENGTH,                                       DoSomethingUseful,                                       NULL,                                       &exported_function));    NAPI_CALL(env, napi_set_named_property(env,                                          result,                                          \"doSomethingUseful\",                                          exported_function));    return result; }  \/\/ addon_node.c #include <node_api.h> #include \"addon.h\"  NAPI_MODULE_INIT() {   \/\/ This function body is expected to return a `napi_value`.   \/\/ The variables `napi_env env` and `napi_value exports` may be used within   \/\/ the body, as they are provided by the definition of `NAPI_MODULE_INIT()`.   return create_addon(env); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_environment_life_cycle_apis","title":"Environment life cycle APIs","description":"Section 8.7 of the ECMAScript Language Specification defines the concept of an \"Agent\" as a self-contained environment in which JavaScript code runs. Multiple such Agents may be started and terminated either concurrently or in sequence by the process. A Node.js environment corresponds to an ECMAScript Agent. In the main process, an environment is created at startup, and additional environments can be created on separate threads to serve as worker threads. When Node.js is embedded in another application, the main thread of the application may also construct and destroy a Node.js environment multiple times during the life cycle of the application process such that each Node.js environment created by the application may, in turn, during its life cycle create and destroy additional environments as worker threads. From the perspective of a native addon this means that the bindings it provides may be called multiple times, from multiple contexts, and even concurrently from multiple threads. Native addons may need to allocate global state which they use during their entire life cycle such that the state must be unique to each instance of the addon. To this end, N-API provides a way to allocate data such that its life cycle is tied to the life cycle of the Agent."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_set_instance_data","title":"napi_set_instance_data","description":"napi_status napi_set_instance_data(napi_env env,                                    void* data,                                    napi_finalize finalize_cb,                                    void* finalize_hint);   [in] env: The environment that the N-API call is invoked under. [in] data: The data item to make available to bindings of this instance. [in] finalize_cb: The function to call when the environment is being torn down. The function receives data so that it might free it. napi_finalize provides more details. [in] finalize_hint: Optional hint to pass to the finalize callback during collection.  Returns napi_ok if the API succeeded. This API associates data with the currently running Agent. data can later be retrieved using napi_get_instance_data(). Any existing data associated with the currently running Agent which was set by means of a previous call to napi_set_instance_data() will be overwritten. If a finalize_cb was provided by the previous call, it will not be called."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_instance_data","title":"napi_get_instance_data","description":"napi_status napi_get_instance_data(napi_env env,                                    void** data);   [in] env: The environment that the N-API call is invoked under. [out] data: The data item that was previously associated with the currently running Agent by a call to napi_set_instance_data().  Returns napi_ok if the API succeeded. This API retrieves data that was previously associated with the currently running Agent via napi_set_instance_data(). If no data is set, the call will succeed and data will be set to NULL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_basic_n_api_data_types","title":"Basic N-API data types","description":"N-API exposes the following fundamental datatypes as abstractions that are consumed by the various APIs. These APIs should be treated as opaque, introspectable only with other N-API calls."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_status","title":"napi_status","description":"Integral status code indicating the success or failure of a N-API call. Currently, the following status codes are supported. typedef enum {   napi_ok,   napi_invalid_arg,   napi_object_expected,   napi_string_expected,   napi_name_expected,   napi_function_expected,   napi_number_expected,   napi_boolean_expected,   napi_array_expected,   napi_generic_failure,   napi_pending_exception,   napi_cancelled,   napi_escape_called_twice,   napi_handle_scope_mismatch,   napi_callback_scope_mismatch,   napi_queue_full,   napi_closing,   napi_bigint_expected,   napi_date_expected,   napi_arraybuffer_expected,   napi_detachable_arraybuffer_expected,   napi_would_deadlock,  \/* unused *\/ } napi_status;  If additional information is required upon an API returning a failed status, it can be obtained by calling napi_get_last_error_info."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_extended_error_info","title":"napi_extended_error_info","description":"typedef struct {   const char* error_message;   void* engine_reserved;   uint32_t engine_error_code;   napi_status error_code; } napi_extended_error_info;   error_message: UTF8-encoded string containing a VM-neutral description of the error. engine_reserved: Reserved for VM-specific error details. This is currently not implemented for any VM. engine_error_code: VM-specific error code. This is currently not implemented for any VM. error_code: The N-API status code that originated with the last error.  See the Error handling section for additional information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_env","title":"napi_env","description":"napi_env is used to represent a context that the underlying N-API implementation can use to persist VM-specific state. This structure is passed to native functions when they're invoked, and it must be passed back when making N-API calls. Specifically, the same napi_env that was passed in when the initial native function was called must be passed to any subsequent nested N-API calls. Caching the napi_env for the purpose of general reuse, and passing the napi_env between instances of the same addon running on different Worker threads is not allowed. The napi_env becomes invalid when an instance of a native addon is unloaded. Notification of this event is delivered through the callbacks given to napi_add_env_cleanup_hook and napi_set_instance_data."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_value","title":"napi_value","description":"This is an opaque pointer that is used to represent a JavaScript value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_threadsafe_function","title":"napi_threadsafe_function","description":"This is an opaque pointer that represents a JavaScript function which can be called asynchronously from multiple threads via napi_call_threadsafe_function()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_threadsafe_function_release_mode","title":"napi_threadsafe_function_release_mode","description":"A value to be given to napi_release_threadsafe_function() to indicate whether the thread-safe function is to be closed immediately (napi_tsfn_abort) or merely released (napi_tsfn_release) and thus available for subsequent use via napi_acquire_threadsafe_function() and napi_call_threadsafe_function(). typedef enum {   napi_tsfn_release,   napi_tsfn_abort } napi_threadsafe_function_release_mode;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_threadsafe_function_call_mode","title":"napi_threadsafe_function_call_mode","description":"A value to be given to napi_call_threadsafe_function() to indicate whether the call should block whenever the queue associated with the thread-safe function is full. typedef enum {   napi_tsfn_nonblocking,   napi_tsfn_blocking } napi_threadsafe_function_call_mode;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_n_api_memory_management_types","title":"N-API memory management types","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_handle_scope","title":"napi_handle_scope","description":"This is an abstraction used to control and modify the lifetime of objects created within a particular scope. In general, N-API values are created within the context of a handle scope. When a native method is called from JavaScript, a default handle scope will exist. If the user does not explicitly create a new handle scope, N-API values will be created in the default handle scope. For any invocations of code outside the execution of a native method (for instance, during a libuv callback invocation), the module is required to create a scope before invoking any functions that can result in the creation of JavaScript values. Handle scopes are created using napi_open_handle_scope and are destroyed using napi_close_handle_scope. Closing the scope can indicate to the GC that all napi_values created during the lifetime of the handle scope are no longer referenced from the current stack frame. For more details, review the Object lifetime management."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_escapable_handle_scope","title":"napi_escapable_handle_scope","description":"Escapable handle scopes are a special type of handle scope to return values created within a particular handle scope to a parent scope."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_ref","title":"napi_ref","description":"This is the abstraction to use to reference a napi_value. This allows for users to manage the lifetimes of JavaScript values, including defining their minimum lifetimes explicitly. For more details, review the Object lifetime management."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_type_tag","title":"napi_type_tag","description":"A 128-bit value stored as two unsigned 64-bit integers. It serves as a UUID with which JavaScript objects can be \"tagged\" in order to ensure that they are of a certain type. This is a stronger check than napi_instanceof, because the latter can report a false positive if the object's prototype has been manipulated. Type-tagging is most useful in conjunction with napi_wrap because it ensures that the pointer retrieved from a wrapped object can be safely cast to the native type corresponding to the type tag that had been previously applied to the JavaScript object. typedef struct {   uint64_t lower;   uint64_t upper; } napi_type_tag;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_async_cleanup_hook_handle","title":"napi_async_cleanup_hook_handle","description":"An opaque value returned by napi_add_async_cleanup_hook. It must be passed to napi_remove_async_cleanup_hook when the chain of asynchronous cleanup events completes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_n_api_callback_types","title":"N-API callback types","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_callback_info","title":"napi_callback_info","description":"Opaque datatype that is passed to a callback function. It can be used for getting additional information about the context in which the callback was invoked."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_callback","title":"napi_callback","description":"Function pointer type for user-provided native functions which are to be exposed to JavaScript via N-API. Callback functions should satisfy the following signature: typedef napi_value (*napi_callback)(napi_env, napi_callback_info);  Unless for reasons discussed in Object Lifetime Management, creating a handle and\/or callback scope inside a napi_callback is not necessary."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_finalize","title":"napi_finalize","description":"Function pointer type for add-on provided functions that allow the user to be notified when externally-owned data is ready to be cleaned up because the object with which it was associated with, has been garbage-collected. The user must provide a function satisfying the following signature which would get called upon the object's collection. Currently, napi_finalize can be used for finding out when objects that have external data are collected. typedef void (*napi_finalize)(napi_env env,                               void* finalize_data,                               void* finalize_hint);  Unless for reasons discussed in Object Lifetime Management, creating a handle and\/or callback scope inside the function body is not necessary."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_async_execute_callback","title":"napi_async_execute_callback","description":"Function pointer used with functions that support asynchronous operations. Callback functions must satisfy the following signature: typedef void (*napi_async_execute_callback)(napi_env env, void* data);  Implementations of this function must avoid making N-API calls that execute JavaScript or interact with JavaScript objects. N-API calls should be in the napi_async_complete_callback instead. Do not use the napi_env parameter as it will likely result in execution of JavaScript."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_async_complete_callback","title":"napi_async_complete_callback","description":"Function pointer used with functions that support asynchronous operations. Callback functions must satisfy the following signature: typedef void (*napi_async_complete_callback)(napi_env env,                                              napi_status status,                                              void* data);  Unless for reasons discussed in Object Lifetime Management, creating a handle and\/or callback scope inside the function body is not necessary."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_threadsafe_function_call_js","title":"napi_threadsafe_function_call_js","description":"Function pointer used with asynchronous thread-safe function calls. The callback will be called on the main thread. Its purpose is to use a data item arriving via the queue from one of the secondary threads to construct the parameters necessary for a call into JavaScript, usually via napi_call_function, and then make the call into JavaScript. The data arriving from the secondary thread via the queue is given in the data parameter and the JavaScript function to call is given in the js_callback parameter. N-API sets up the environment prior to calling this callback, so it is sufficient to call the JavaScript function via napi_call_function rather than via napi_make_callback. Callback functions must satisfy the following signature: typedef void (*napi_threadsafe_function_call_js)(napi_env env,                                                  napi_value js_callback,                                                  void* context,                                                  void* data);   [in] env: The environment to use for API calls, or NULL if the thread-safe function is being torn down and data may need to be freed. [in] js_callback: The JavaScript function to call, or NULL if the thread-safe function is being torn down and data may need to be freed. It may also be NULL if the thread-safe function was created without js_callback. [in] context: The optional data with which the thread-safe function was created. [in] data: Data created by the secondary thread. It is the responsibility of the callback to convert this native data to JavaScript values (with N-API functions) that can be passed as parameters when js_callback is invoked. This pointer is managed entirely by the threads and this callback. Thus this callback should free the data.  Unless for reasons discussed in Object Lifetime Management, creating a handle and\/or callback scope inside the function body is not necessary."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_async_cleanup_hook","title":"napi_async_cleanup_hook","description":"Function pointer used with napi_add_async_cleanup_hook. It will be called when the environment is being torn down. Callback functions must satisfy the following signature: typedef void (*napi_async_cleanup_hook)(napi_async_cleanup_hook_handle handle,                                         void* data);   [in] handle: The handle that must be passed to napi_remove_async_cleanup_hook after completion of the asynchronous cleanup. [in] data: The data that was passed to napi_add_async_cleanup_hook.  The body of the function should initiate the asynchronous cleanup actions at the end of which handle must be passed in a call to napi_remove_async_cleanup_hook."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_handling","title":"Error handling","description":"N-API uses both return values and JavaScript exceptions for error handling. The following sections explain the approach for each case."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_return_values","title":"Return values","description":"All of the N-API functions share the same error handling pattern. The return type of all API functions is napi_status. The return value will be napi_ok if the request was successful and no uncaught JavaScript exception was thrown. If an error occurred AND an exception was thrown, the napi_status value for the error will be returned. If an exception was thrown, and no error occurred, napi_pending_exception will be returned. In cases where a return value other than napi_ok or napi_pending_exception is returned, napi_is_exception_pending must be called to check if an exception is pending. See the section on exceptions for more details. The full set of possible napi_status values is defined in napi_api_types.h. The napi_status return value provides a VM-independent representation of the error which occurred. In some cases it is useful to be able to get more detailed information, including a string representing the error as well as VM (engine)-specific information. In order to retrieve this information napi_get_last_error_info is provided which returns a napi_extended_error_info structure. The format of the napi_extended_error_info structure is as follows: typedef struct napi_extended_error_info {   const char* error_message;   void* engine_reserved;   uint32_t engine_error_code;   napi_status error_code; };   error_message: Textual representation of the error that occurred. engine_reserved: Opaque handle reserved for engine use only. engine_error_code: VM specific error code. error_code: n-api status code for the last error.  napi_get_last_error_info returns the information for the last N-API call that was made. Do not rely on the content or format of any of the extended information as it is not subject to SemVer and may change at any time. It is intended only for logging purposes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_last_error_info","title":"napi_get_last_error_info","description":"napi_status napi_get_last_error_info(napi_env env,                          const napi_extended_error_info** result);   [in] env: The environment that the API is invoked under. [out] result: The napi_extended_error_info structure with more information about the error.  Returns napi_ok if the API succeeded. This API retrieves a napi_extended_error_info structure with information about the last error that occurred. The content of the napi_extended_error_info returned is only valid up until an n-api function is called on the same env. Do not rely on the content or format of any of the extended information as it is not subject to SemVer and may change at any time. It is intended only for logging purposes. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exceptions","title":"Exceptions","description":"Any N-API function call may result in a pending JavaScript exception. This is the case for any of the API functions, even those that may not cause the execution of JavaScript. If the napi_status returned by a function is napi_ok then no exception is pending and no additional action is required. If the napi_status returned is anything other than napi_ok or napi_pending_exception, in order to try to recover and continue instead of simply returning immediately, napi_is_exception_pending must be called in order to determine if an exception is pending or not. In many cases when an N-API function is called and an exception is already pending, the function will return immediately with a napi_status of napi_pending_exception. However, this is not the case for all functions. N-API allows a subset of the functions to be called to allow for some minimal cleanup before returning to JavaScript. In that case, napi_status will reflect the status for the function. It will not reflect previous pending exceptions. To avoid confusion, check the error status after every function call. When an exception is pending one of two approaches can be employed. The first approach is to do any appropriate cleanup and then return so that execution will return to JavaScript. As part of the transition back to JavaScript, the exception will be thrown at the point in the JavaScript code where the native method was invoked. The behavior of most N-API calls is unspecified while an exception is pending, and many will simply return napi_pending_exception, so do as little as possible and then return to JavaScript where the exception can be handled. The second approach is to try to handle the exception. There will be cases where the native code can catch the exception, take the appropriate action, and then continue. This is only recommended in specific cases where it is known that the exception can be safely handled. In these cases napi_get_and_clear_last_exception can be used to get and clear the exception. On success, result will contain the handle to the last JavaScript Object thrown. If it is determined, after retrieving the exception, the exception cannot be handled after all it can be re-thrown it with napi_throw where error is the JavaScript Error object to be thrown. The following utility functions are also available in case native code needs to throw an exception or determine if a napi_value is an instance of a JavaScript Error object: napi_throw_error, napi_throw_type_error, napi_throw_range_error and napi_is_error. The following utility functions are also available in case native code needs to create an Error object: napi_create_error, napi_create_type_error, and napi_create_range_error, where result is the napi_value that refers to the newly created JavaScript Error object. The Node.js project is adding error codes to all of the errors generated internally. The goal is for applications to use these error codes for all error checking. The associated error messages will remain, but will only be meant to be used for logging and display with the expectation that the message can change without SemVer applying. In order to support this model with N-API, both in internal functionality and for module specific functionality (as its good practice), the throw_ and create_ functions take an optional code parameter which is the string for the code to be added to the error object. If the optional parameter is NULL then no code will be associated with the error. If a code is provided, the name associated with the error is also updated to be: originalName [code]  where originalName is the original name associated with the error and code is the code that was provided. For example, if the code is 'ERR_ERROR_1' and a TypeError is being created the name will be: TypeError [ERR_ERROR_1]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_throw","title":"napi_throw","description":"NAPI_EXTERN napi_status napi_throw(napi_env env, napi_value error);   [in] env: The environment that the API is invoked under. [in] error: The JavaScript value to be thrown.  Returns napi_ok if the API succeeded. This API throws the JavaScript value provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_throw_error","title":"napi_throw_error","description":"NAPI_EXTERN napi_status napi_throw_error(napi_env env,                                          const char* code,                                          const char* msg);   [in] env: The environment that the API is invoked under. [in] code: Optional error code to be set on the error. [in] msg: C string representing the text to be associated with the error.  Returns napi_ok if the API succeeded. This API throws a JavaScript Error with the text provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_throw_type_error","title":"napi_throw_type_error","description":"NAPI_EXTERN napi_status napi_throw_type_error(napi_env env,                                               const char* code,                                               const char* msg);   [in] env: The environment that the API is invoked under. [in] code: Optional error code to be set on the error. [in] msg: C string representing the text to be associated with the error.  Returns napi_ok if the API succeeded. This API throws a JavaScript TypeError with the text provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_throw_range_error","title":"napi_throw_range_error","description":"NAPI_EXTERN napi_status napi_throw_range_error(napi_env env,                                                const char* code,                                                const char* msg);   [in] env: The environment that the API is invoked under. [in] code: Optional error code to be set on the error. [in] msg: C string representing the text to be associated with the error.  Returns napi_ok if the API succeeded. This API throws a JavaScript RangeError with the text provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_error","title":"napi_is_error","description":"NAPI_EXTERN napi_status napi_is_error(napi_env env,                                       napi_value value,                                       bool* result);   [in] env: The environment that the API is invoked under. [in] value: The napi_value to be checked. [out] result: Boolean value that is set to true if napi_value represents an error, false otherwise.  Returns napi_ok if the API succeeded. This API queries a napi_value to check if it represents an error object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_error","title":"napi_create_error","description":"NAPI_EXTERN napi_status napi_create_error(napi_env env,                                           napi_value code,                                           napi_value msg,                                           napi_value* result);   [in] env: The environment that the API is invoked under. [in] code: Optional napi_value with the string for the error code to be associated with the error. [in] msg: napi_value that references a JavaScript String to be used as the message for the Error. [out] result: napi_value representing the error created.  Returns napi_ok if the API succeeded. This API returns a JavaScript Error with the text provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_type_error","title":"napi_create_type_error","description":"NAPI_EXTERN napi_status napi_create_type_error(napi_env env,                                                napi_value code,                                                napi_value msg,                                                napi_value* result);   [in] env: The environment that the API is invoked under. [in] code: Optional napi_value with the string for the error code to be associated with the error. [in] msg: napi_value that references a JavaScript String to be used as the message for the Error. [out] result: napi_value representing the error created.  Returns napi_ok if the API succeeded. This API returns a JavaScript TypeError with the text provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_range_error","title":"napi_create_range_error","description":"NAPI_EXTERN napi_status napi_create_range_error(napi_env env,                                                 napi_value code,                                                 napi_value msg,                                                 napi_value* result);   [in] env: The environment that the API is invoked under. [in] code: Optional napi_value with the string for the error code to be associated with the error. [in] msg: napi_value that references a JavaScript String to be used as the message for the Error. [out] result: napi_value representing the error created.  Returns napi_ok if the API succeeded. This API returns a JavaScript RangeError with the text provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_and_clear_last_exception","title":"napi_get_and_clear_last_exception","description":"napi_status napi_get_and_clear_last_exception(napi_env env,                                               napi_value* result);   [in] env: The environment that the API is invoked under. [out] result: The exception if one is pending, NULL otherwise.  Returns napi_ok if the API succeeded. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_exception_pending","title":"napi_is_exception_pending","description":"napi_status napi_is_exception_pending(napi_env env, bool* result);   [in] env: The environment that the API is invoked under. [out] result: Boolean value that is set to true if an exception is pending.  Returns napi_ok if the API succeeded. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_fatal_exception","title":"napi_fatal_exception","description":"napi_status napi_fatal_exception(napi_env env, napi_value err);   [in] env: The environment that the API is invoked under. [in] err: The error that is passed to 'uncaughtException'.  Trigger an 'uncaughtException' in JavaScript. Useful if an async callback throws an exception with no way to recover."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fatal_errors","title":"Fatal errors","description":"In the event of an unrecoverable error in a native module, a fatal error can be thrown to immediately terminate the process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_fatal_error","title":"napi_fatal_error","description":"NAPI_NO_RETURN void napi_fatal_error(const char* location,                                                  size_t location_len,                                                  const char* message,                                                  size_t message_len);   [in] location: Optional location at which the error occurred. [in] location_len: The length of the location in bytes, or NAPI_AUTO_LENGTH if it is null-terminated. [in] message: The message associated with the error. [in] message_len: The length of the message in bytes, or NAPI_AUTO_LENGTH if it is null-terminated.  The function call does not return, the process will be terminated. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_object_lifetime_management","title":"Object lifetime management","description":"As N-API calls are made, handles to objects in the heap for the underlying VM may be returned as napi_values. These handles must hold the objects 'live' until they are no longer required by the native code, otherwise the objects could be collected before the native code was finished using them. As object handles are returned they are associated with a 'scope'. The lifespan for the default scope is tied to the lifespan of the native method call. The result is that, by default, handles remain valid and the objects associated with these handles will be held live for the lifespan of the native method call. In many cases, however, it is necessary that the handles remain valid for either a shorter or longer lifespan than that of the native method. The sections which follow describe the N-API functions that can be used to change the handle lifespan from the default."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_making_handle_lifespan_shorter_than_that_of_the_native_method","title":"Making handle lifespan shorter than that of the native method","description":"It is often necessary to make the lifespan of handles shorter than the lifespan of a native method. For example, consider a native method that has a loop which iterates through the elements in a large array: for (int i = 0; i < 1000000; i++) {   napi_value result;   napi_status status = napi_get_element(env, object, i, &result);   if (status != napi_ok) {     break;   }   \/\/ do something with element }  This would result in a large number of handles being created, consuming substantial resources. In addition, even though the native code could only use the most recent handle, all of the associated objects would also be kept alive since they all share the same scope. To handle this case, N-API provides the ability to establish a new 'scope' to which newly created handles will be associated. Once those handles are no longer required, the scope can be 'closed' and any handles associated with the scope are invalidated. The methods available to open\/close scopes are napi_open_handle_scope and napi_close_handle_scope. N-API only supports a single nested hierarchy of scopes. There is only one active scope at any time, and all new handles will be associated with that scope while it is active. Scopes must be closed in the reverse order from which they are opened. In addition, all scopes created within a native method must be closed before returning from that method. Taking the earlier example, adding calls to napi_open_handle_scope and napi_close_handle_scope would ensure that at most a single handle is valid throughout the execution of the loop: for (int i = 0; i < 1000000; i++) {   napi_handle_scope scope;   napi_status status = napi_open_handle_scope(env, &scope);   if (status != napi_ok) {     break;   }   napi_value result;   status = napi_get_element(env, object, i, &result);   if (status != napi_ok) {     break;   }   \/\/ do something with element   status = napi_close_handle_scope(env, scope);   if (status != napi_ok) {     break;   } }  When nesting scopes, there are cases where a handle from an inner scope needs to live beyond the lifespan of that scope. N-API supports an 'escapable scope' in order to support this case. An escapable scope allows one handle to be 'promoted' so that it 'escapes' the current scope and the lifespan of the handle changes from the current scope to that of the outer scope. The methods available to open\/close escapable scopes are napi_open_escapable_handle_scope and napi_close_escapable_handle_scope. The request to promote a handle is made through napi_escape_handle which can only be called once."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_open_handle_scope","title":"napi_open_handle_scope","description":"NAPI_EXTERN napi_status napi_open_handle_scope(napi_env env,                                                napi_handle_scope* result);   [in] env: The environment that the API is invoked under. [out] result: napi_value representing the new scope.  Returns napi_ok if the API succeeded. This API opens a new scope."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_close_handle_scope","title":"napi_close_handle_scope","description":"NAPI_EXTERN napi_status napi_close_handle_scope(napi_env env,                                                 napi_handle_scope scope);   [in] env: The environment that the API is invoked under. [in] scope: napi_value representing the scope to be closed.  Returns napi_ok if the API succeeded. This API closes the scope passed in. Scopes must be closed in the reverse order from which they were created. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_open_escapable_handle_scope","title":"napi_open_escapable_handle_scope","description":"NAPI_EXTERN napi_status     napi_open_escapable_handle_scope(napi_env env,                                      napi_handle_scope* result);   [in] env: The environment that the API is invoked under. [out] result: napi_value representing the new scope.  Returns napi_ok if the API succeeded. This API opens a new scope from which one object can be promoted to the outer scope."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_close_escapable_handle_scope","title":"napi_close_escapable_handle_scope","description":"NAPI_EXTERN napi_status     napi_close_escapable_handle_scope(napi_env env,                                       napi_handle_scope scope);   [in] env: The environment that the API is invoked under. [in] scope: napi_value representing the scope to be closed.  Returns napi_ok if the API succeeded. This API closes the scope passed in. Scopes must be closed in the reverse order from which they were created. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_escape_handle","title":"napi_escape_handle","description":"napi_status napi_escape_handle(napi_env env,                                napi_escapable_handle_scope scope,                                napi_value escapee,                                napi_value* result);   [in] env: The environment that the API is invoked under. [in] scope: napi_value representing the current scope. [in] escapee: napi_value representing the JavaScript Object to be escaped. [out] result: napi_value representing the handle to the escaped Object in the outer scope.  Returns napi_ok if the API succeeded. This API promotes the handle to the JavaScript object so that it is valid for the lifetime of the outer scope. It can only be called once per scope. If it is called more than once an error will be returned. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_references_to_objects_with_a_lifespan_longer_than_that_of_the_native_method","title":"References to objects with a lifespan longer than that of the native method","description":"In some cases an addon will need to be able to create and reference objects with a lifespan longer than that of a single native method invocation. For example, to create a constructor and later use that constructor in a request to creates instances, it must be possible to reference the constructor object across many different instance creation requests. This would not be possible with a normal handle returned as a napi_value as described in the earlier section. The lifespan of a normal handle is managed by scopes and all scopes must be closed before the end of a native method. N-API provides methods to create persistent references to an object. Each persistent reference has an associated count with a value of 0 or higher. The count determines if the reference will keep the corresponding object live. References with a count of 0 do not prevent the object from being collected and are often called 'weak' references. Any count greater than 0 will prevent the object from being collected. References can be created with an initial reference count. The count can then be modified through napi_reference_ref and napi_reference_unref. If an object is collected while the count for a reference is 0, all subsequent calls to get the object associated with the reference napi_get_reference_value will return NULL for the returned napi_value. An attempt to call napi_reference_ref for a reference whose object has been collected results in an error. References must be deleted once they are no longer required by the addon. When a reference is deleted, it will no longer prevent the corresponding object from being collected. Failure to delete a persistent reference results in a 'memory leak' with both the native memory for the persistent reference and the corresponding object on the heap being retained forever. There can be multiple persistent references created which refer to the same object, each of which will either keep the object live or not based on its individual count."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_reference","title":"napi_create_reference","description":"NAPI_EXTERN napi_status napi_create_reference(napi_env env,                                               napi_value value,                                               uint32_t initial_refcount,                                               napi_ref* result);   [in] env: The environment that the API is invoked under. [in] value: napi_value representing the Object to which we want a reference. [in] initial_refcount: Initial reference count for the new reference. [out] result: napi_ref pointing to the new reference.  Returns napi_ok if the API succeeded. This API create a new reference with the specified reference count to the Object passed in."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_delete_reference","title":"napi_delete_reference","description":"NAPI_EXTERN napi_status napi_delete_reference(napi_env env, napi_ref ref);   [in] env: The environment that the API is invoked under. [in] ref: napi_ref to be deleted.  Returns napi_ok if the API succeeded. This API deletes the reference passed in. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_reference_ref","title":"napi_reference_ref","description":"NAPI_EXTERN napi_status napi_reference_ref(napi_env env,                                            napi_ref ref,                                            uint32_t* result);   [in] env: The environment that the API is invoked under. [in] ref: napi_ref for which the reference count will be incremented. [out] result: The new reference count.  Returns napi_ok if the API succeeded. This API increments the reference count for the reference passed in and returns the resulting reference count."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_reference_unref","title":"napi_reference_unref","description":"NAPI_EXTERN napi_status napi_reference_unref(napi_env env,                                              napi_ref ref,                                              uint32_t* result);   [in] env: The environment that the API is invoked under. [in] ref: napi_ref for which the reference count will be decremented. [out] result: The new reference count.  Returns napi_ok if the API succeeded. This API decrements the reference count for the reference passed in and returns the resulting reference count."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_reference_value","title":"napi_get_reference_value","description":"NAPI_EXTERN napi_status napi_get_reference_value(napi_env env,                                                  napi_ref ref,                                                  napi_value* result);  the napi_value passed in or out of these methods is a handle to the object to which the reference is related.  [in] env: The environment that the API is invoked under. [in] ref: napi_ref for which we requesting the corresponding Object. [out] result: The napi_value for the Object referenced by the napi_ref.  Returns napi_ok if the API succeeded. If still valid, this API returns the napi_value representing the JavaScript Object associated with the napi_ref. Otherwise, result will be NULL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cleanup_on_exit_of_the_current_node_js_instance","title":"Cleanup on exit of the current Node.js instance","description":"While a Node.js process typically releases all its resources when exiting, embedders of Node.js, or future Worker support, may require addons to register clean-up hooks that will be run once the current Node.js instance exits. N-API provides functions for registering and un-registering such callbacks. When those callbacks are run, all resources that are being held by the addon should be freed up."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_add_env_cleanup_hook","title":"napi_add_env_cleanup_hook","description":"NODE_EXTERN napi_status napi_add_env_cleanup_hook(napi_env env,                                                   void (*fun)(void* arg),                                                   void* arg);  Registers fun as a function to be run with the arg parameter once the current Node.js environment exits. A function can safely be specified multiple times with different arg values. In that case, it will be called multiple times as well. Providing the same fun and arg values multiple times is not allowed and will lead the process to abort. The hooks will be called in reverse order, i.e. the most recently added one will be called first. Removing this hook can be done by using napi_remove_env_cleanup_hook. Typically, that happens when the resource for which this hook was added is being torn down anyway. For asynchronous cleanup, napi_add_async_cleanup_hook is available."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_remove_env_cleanup_hook","title":"napi_remove_env_cleanup_hook","description":"NAPI_EXTERN napi_status napi_remove_env_cleanup_hook(napi_env env,                                                      void (*fun)(void* arg),                                                      void* arg);  Unregisters fun as a function to be run with the arg parameter once the current Node.js environment exits. Both the argument and the function value need to be exact matches. The function must have originally been registered with napi_add_env_cleanup_hook, otherwise the process will abort."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_add_async_cleanup_hook","title":"napi_add_async_cleanup_hook","description":"NAPI_EXTERN napi_status napi_add_async_cleanup_hook(     napi_env env,     napi_async_cleanup_hook hook,     void* arg,     napi_async_cleanup_hook_handle* remove_handle);   [in] env: The environment that the API is invoked under. [in] hook: The function pointer to call at environment teardown. [in] arg: The pointer to pass to hook when it gets called. [out] remove_handle: Optional handle that refers to the asynchronous cleanup hook.  Registers hook, which is a function of type napi_async_cleanup_hook, as a function to be run with the remove_handle and arg parameters once the current Node.js environment exits. Unlike napi_add_env_cleanup_hook, the hook is allowed to be asynchronous. Otherwise, behavior generally matches that of napi_add_env_cleanup_hook. If remove_handle is not NULL, an opaque value will be stored in it that must later be passed to napi_remove_async_cleanup_hook, regardless of whether the hook has already been invoked. Typically, that happens when the resource for which this hook was added is being torn down anyway."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_remove_async_cleanup_hook","title":"napi_remove_async_cleanup_hook","description":"NAPI_EXTERN napi_status napi_remove_async_cleanup_hook(     napi_async_cleanup_hook_handle remove_handle);   [in] remove_handle: The handle to an asynchronous cleanup hook that was created with napi_add_async_cleanup_hook.  Unregisters the cleanup hook corresponding to remove_handle. This will prevent the hook from being executed, unless it has already started executing. This must be called on any napi_async_cleanup_hook_handle value obtained from napi_add_async_cleanup_hook."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_registration","title":"Module registration","description":"N-API modules are registered in a manner similar to other modules except that instead of using the NODE_MODULE macro the following is used: NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)  The next difference is the signature for the Init method. For a N-API module it is as follows: napi_value Init(napi_env env, napi_value exports);  The return value from Init is treated as the exports object for the module. The Init method is passed an empty object via the exports parameter as a convenience. If Init returns NULL, the parameter passed as exports is exported by the module. N-API modules cannot modify the module object but can specify anything as the exports property of the module. To add the method hello as a function so that it can be called as a method provided by the addon: napi_value Init(napi_env env, napi_value exports) {   napi_status status;   napi_property_descriptor desc = {     \"hello\",     NULL,     Method,     NULL,     NULL,     NULL,     napi_writable | napi_enumerable | napi_configurable,     NULL   };   status = napi_define_properties(env, exports, 1, &desc);   if (status != napi_ok) return NULL;   return exports; }  To set a function to be returned by the require() for the addon: napi_value Init(napi_env env, napi_value exports) {   napi_value method;   napi_status status;   status = napi_create_function(env, \"exports\", NAPI_AUTO_LENGTH, Method, NULL, &method);   if (status != napi_ok) return NULL;   return method; }  To define a class so that new instances can be created (often used with Object wrap): \/\/ NOTE: partial example, not all referenced code is included napi_value Init(napi_env env, napi_value exports) {   napi_status status;   napi_property_descriptor properties[] = {     { \"value\", NULL, NULL, GetValue, SetValue, NULL, napi_writable | napi_configurable, NULL },     DECLARE_NAPI_METHOD(\"plusOne\", PlusOne),     DECLARE_NAPI_METHOD(\"multiply\", Multiply),   };    napi_value cons;   status =       napi_define_class(env, \"MyObject\", New, NULL, 3, properties, &cons);   if (status != napi_ok) return NULL;    status = napi_create_reference(env, cons, 1, &constructor);   if (status != napi_ok) return NULL;    status = napi_set_named_property(env, exports, \"MyObject\", cons);   if (status != napi_ok) return NULL;    return exports; }  If the module will be loaded multiple times during the lifetime of the Node.js process, use the NAPI_MODULE_INIT macro to initialize the module: NAPI_MODULE_INIT() {   napi_value answer;   napi_status result;    status = napi_create_int64(env, 42, &answer);   if (status != napi_ok) return NULL;    status = napi_set_named_property(env, exports, \"answer\", answer);   if (status != napi_ok) return NULL;    return exports; }  This macro includes NAPI_MODULE, and declares an Init function with a special name and with visibility beyond the addon. This will allow Node.js to initialize the module even if it is loaded multiple times. There are a few design considerations when declaring a module that may be loaded multiple times. The documentation of context-aware addons provides more details. The variables env and exports will be available inside the function body following the macro invocation. For more details on setting properties on objects, see the section on Working with JavaScript properties. For more details on building addon modules in general, refer to the existing API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_working_with_javascript_values","title":"Working with JavaScript values","description":"N-API exposes a set of APIs to create all types of JavaScript values. Some of these types are documented under Section 6 of the ECMAScript Language Specification. Fundamentally, these APIs are used to do one of the following:  Create a new JavaScript object Convert from a primitive C type to an N-API value Convert from N-API value to a primitive C type Get global instances including undefined and null  N-API values are represented by the type napi_value. Any N-API call that requires a JavaScript value takes in a napi_value. In some cases, the API does check the type of the napi_value up-front. However, for better performance, it's better for the caller to make sure that the napi_value in question is of the JavaScript type expected by the API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_enum_types","title":"Enum types","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_key_collection_mode","title":"napi_key_collection_mode","description":"typedef enum {   napi_key_include_prototypes,   napi_key_own_only } napi_key_collection_mode;  Describes the Keys\/Properties filter enums: napi_key_collection_mode limits the range of collected properties. napi_key_own_only limits the collected properties to the given object only. napi_key_include_prototypes will include all keys of the objects's prototype chain as well."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_key_filter","title":"napi_key_filter","description":"typedef enum {   napi_key_all_properties = 0,   napi_key_writable = 1,   napi_key_enumerable = 1 << 1,   napi_key_configurable = 1 << 2,   napi_key_skip_strings = 1 << 3,   napi_key_skip_symbols = 1 << 4 } napi_key_filter;  Property filter bits. They can be or'ed to build a composite filter."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_key_conversion","title":"napi_key_conversion","description":"typedef enum {   napi_key_keep_numbers,   napi_key_numbers_to_strings } napi_key_conversion;  napi_key_numbers_to_strings will convert integer indices to strings. napi_key_keep_numbers will return numbers for integer indices."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_valuetype","title":"napi_valuetype","description":"typedef enum {   \/\/ ES6 types (corresponds to typeof)   napi_undefined,   napi_null,   napi_boolean,   napi_number,   napi_string,   napi_symbol,   napi_object,   napi_function,   napi_external,   napi_bigint, } napi_valuetype;  Describes the type of a napi_value. This generally corresponds to the types described in Section 6.1 of the ECMAScript Language Specification. In addition to types in that section, napi_valuetype can also represent Functions and Objects with external data. A JavaScript value of type napi_external appears in JavaScript as a plain object such that no properties can be set on it, and no prototype."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_typedarray_type","title":"napi_typedarray_type","description":"typedef enum {   napi_int8_array,   napi_uint8_array,   napi_uint8_clamped_array,   napi_int16_array,   napi_uint16_array,   napi_int32_array,   napi_uint32_array,   napi_float32_array,   napi_float64_array,   napi_bigint64_array,   napi_biguint64_array, } napi_typedarray_type;  This represents the underlying binary scalar datatype of the TypedArray. Elements of this enum correspond to Section 22.2 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_object_creation_functions","title":"Object creation functions","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_array","title":"napi_create_array","description":"napi_status napi_create_array(napi_env env, napi_value* result)   [in] env: The environment that the N-API call is invoked under. [out] result: A napi_value representing a JavaScript Array.  Returns napi_ok if the API succeeded. This API returns an N-API value corresponding to a JavaScript Array type. JavaScript arrays are described in Section 22.1 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_array_with_length","title":"napi_create_array_with_length","description":"napi_status napi_create_array_with_length(napi_env env,                                           size_t length,                                           napi_value* result)   [in] env: The environment that the API is invoked under. [in] length: The initial length of the Array. [out] result: A napi_value representing a JavaScript Array.  Returns napi_ok if the API succeeded. This API returns an N-API value corresponding to a JavaScript Array type. The Array's length property is set to the passed-in length parameter. However, the underlying buffer is not guaranteed to be pre-allocated by the VM when the array is created. That behavior is left to the underlying VM implementation. If the buffer must be a contiguous block of memory that can be directly read and\/or written via C, consider using napi_create_external_arraybuffer. JavaScript arrays are described in Section 22.1 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_arraybuffer","title":"napi_create_arraybuffer","description":"napi_status napi_create_arraybuffer(napi_env env,                                     size_t byte_length,                                     void** data,                                     napi_value* result)   [in] env: The environment that the API is invoked under. [in] length: The length in bytes of the array buffer to create. [out] data: Pointer to the underlying byte buffer of the ArrayBuffer. [out] result: A napi_value representing a JavaScript ArrayBuffer.  Returns napi_ok if the API succeeded. This API returns an N-API value corresponding to a JavaScript ArrayBuffer. ArrayBuffers are used to represent fixed-length binary data buffers. They are normally used as a backing-buffer for TypedArray objects. The ArrayBuffer allocated will have an underlying byte buffer whose size is determined by the length parameter that's passed in. The underlying buffer is optionally returned back to the caller in case the caller wants to directly manipulate the buffer. This buffer can only be written to directly from native code. To write to this buffer from JavaScript, a typed array or DataView object would need to be created. JavaScript ArrayBuffer objects are described in Section 24.1 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_buffer","title":"napi_create_buffer","description":"napi_status napi_create_buffer(napi_env env,                                size_t size,                                void** data,                                napi_value* result)   [in] env: The environment that the API is invoked under. [in] size: Size in bytes of the underlying buffer. [out] data: Raw pointer to the underlying buffer. [out] result: A napi_value representing a node::Buffer.  Returns napi_ok if the API succeeded. This API allocates a node::Buffer object. While this is still a fully-supported data structure, in most cases using a TypedArray will suffice."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_buffer_copy","title":"napi_create_buffer_copy","description":"napi_status napi_create_buffer_copy(napi_env env,                                     size_t length,                                     const void* data,                                     void** result_data,                                     napi_value* result)   [in] env: The environment that the API is invoked under. [in] size: Size in bytes of the input buffer (should be the same as the size of the new buffer). [in] data: Raw pointer to the underlying buffer to copy from. [out] result_data: Pointer to the new Buffer's underlying data buffer. [out] result: A napi_value representing a node::Buffer.  Returns napi_ok if the API succeeded. This API allocates a node::Buffer object and initializes it with data copied from the passed-in buffer. While this is still a fully-supported data structure, in most cases using a TypedArray will suffice."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_date","title":"napi_create_date","description":"napi_status napi_create_date(napi_env env,                              double time,                              napi_value* result);   [in] env: The environment that the API is invoked under. [in] time: ECMAScript time value in milliseconds since 01 January, 1970 UTC. [out] result: A napi_value representing a JavaScript Date.  Returns napi_ok if the API succeeded. This API does not observe leap seconds; they are ignored, as ECMAScript aligns with POSIX time specification. This API allocates a JavaScript Date object. JavaScript Date objects are described in Section 20.3 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_external","title":"napi_create_external","description":"napi_status napi_create_external(napi_env env,                                  void* data,                                  napi_finalize finalize_cb,                                  void* finalize_hint,                                  napi_value* result)   [in] env: The environment that the API is invoked under. [in] data: Raw pointer to the external data. [in] finalize_cb: Optional callback to call when the external value is being collected. napi_finalize provides more details. [in] finalize_hint: Optional hint to pass to the finalize callback during collection. [out] result: A napi_value representing an external value.  Returns napi_ok if the API succeeded. This API allocates a JavaScript value with external data attached to it. This is used to pass external data through JavaScript code, so it can be retrieved later by native code using napi_get_value_external. The API adds a napi_finalize callback which will be called when the JavaScript object just created is ready for garbage collection. It is similar to napi_wrap() except that:  the native data cannot be retrieved later using napi_unwrap(), nor can it be removed later using napi_remove_wrap(), and the object created by the API can be used with napi_wrap().  The created value is not an object, and therefore does not support additional properties. It is considered a distinct value type: calling napi_typeof() with an external value yields napi_external."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_external_arraybuffer","title":"napi_create_external_arraybuffer","description":"napi_status napi_create_external_arraybuffer(napi_env env,                                  void* external_data,                                  size_t byte_length,                                  napi_finalize finalize_cb,                                  void* finalize_hint,                                  napi_value* result)   [in] env: The environment that the API is invoked under. [in] external_data: Pointer to the underlying byte buffer of the ArrayBuffer. [in] byte_length: The length in bytes of the underlying buffer. [in] finalize_cb: Optional callback to call when the ArrayBuffer is being collected. napi_finalize provides more details. [in] finalize_hint: Optional hint to pass to the finalize callback during collection. [out] result: A napi_value representing a JavaScript ArrayBuffer.  Returns napi_ok if the API succeeded. This API returns an N-API value corresponding to a JavaScript ArrayBuffer. The underlying byte buffer of the ArrayBuffer is externally allocated and managed. The caller must ensure that the byte buffer remains valid until the finalize callback is called. The API adds a napi_finalize callback which will be called when the JavaScript object just created is ready for garbage collection. It is similar to napi_wrap() except that:  the native data cannot be retrieved later using napi_unwrap(), nor can it be removed later using napi_remove_wrap(), and the object created by the API can be used with napi_wrap().  JavaScript ArrayBuffers are described in Section 24.1 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_external_buffer","title":"napi_create_external_buffer","description":"napi_status napi_create_external_buffer(napi_env env,                                         size_t length,                                         void* data,                                         napi_finalize finalize_cb,                                         void* finalize_hint,                                         napi_value* result)   [in] env: The environment that the API is invoked under. [in] length: Size in bytes of the input buffer (should be the same as the size of the new buffer). [in] data: Raw pointer to the underlying buffer to expose to JavaScript. [in] finalize_cb: Optional callback to call when the ArrayBuffer is being collected. napi_finalize provides more details. [in] finalize_hint: Optional hint to pass to the finalize callback during collection. [out] result: A napi_value representing a node::Buffer.  Returns napi_ok if the API succeeded. This API allocates a node::Buffer object and initializes it with data backed by the passed in buffer. While this is still a fully-supported data structure, in most cases using a TypedArray will suffice. The API adds a napi_finalize callback which will be called when the JavaScript object just created is ready for garbage collection. It is similar to napi_wrap() except that:  the native data cannot be retrieved later using napi_unwrap(), nor can it be removed later using napi_remove_wrap(), and the object created by the API can be used with napi_wrap().  For Node.js >=4 Buffers are Uint8Arrays."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_object","title":"napi_create_object","description":"napi_status napi_create_object(napi_env env, napi_value* result)   [in] env: The environment that the API is invoked under. [out] result: A napi_value representing a JavaScript Object.  Returns napi_ok if the API succeeded. This API allocates a default JavaScript Object. It is the equivalent of doing new Object() in JavaScript. The JavaScript Object type is described in Section 6.1.7 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_symbol","title":"napi_create_symbol","description":"napi_status napi_create_symbol(napi_env env,                                napi_value description,                                napi_value* result)   [in] env: The environment that the API is invoked under. [in] description: Optional napi_value which refers to a JavaScript String to be set as the description for the symbol. [out] result: A napi_value representing a JavaScript Symbol.  Returns napi_ok if the API succeeded. This API creates a JavaScript Symbol object from a UTF8-encoded C string. The JavaScript Symbol type is described in Section 19.4 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_typedarray","title":"napi_create_typedarray","description":"napi_status napi_create_typedarray(napi_env env,                                    napi_typedarray_type type,                                    size_t length,                                    napi_value arraybuffer,                                    size_t byte_offset,                                    napi_value* result)   [in] env: The environment that the API is invoked under. [in] type: Scalar datatype of the elements within the TypedArray. [in] length: Number of elements in the TypedArray. [in] arraybuffer: ArrayBuffer underlying the typed array. [in] byte_offset: The byte offset within the ArrayBuffer from which to start projecting the TypedArray. [out] result: A napi_value representing a JavaScript TypedArray.  Returns napi_ok if the API succeeded. This API creates a JavaScript TypedArray object over an existing ArrayBuffer. TypedArray objects provide an array-like view over an underlying data buffer where each element has the same underlying binary scalar datatype. It's required that (length * size_of_element) + byte_offset should be <= the size in bytes of the array passed in. If not, a RangeError exception is raised. JavaScript TypedArray objects are described in Section 22.2 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_dataview","title":"napi_create_dataview","description":"napi_status napi_create_dataview(napi_env env,                                  size_t byte_length,                                  napi_value arraybuffer,                                  size_t byte_offset,                                  napi_value* result)   [in] env: The environment that the API is invoked under. [in] length: Number of elements in the DataView. [in] arraybuffer: ArrayBuffer underlying the DataView. [in] byte_offset: The byte offset within the ArrayBuffer from which to start projecting the DataView. [out] result: A napi_value representing a JavaScript DataView.  Returns napi_ok if the API succeeded. This API creates a JavaScript DataView object over an existing ArrayBuffer. DataView objects provide an array-like view over an underlying data buffer, but one which allows items of different size and type in the ArrayBuffer. It is required that byte_length + byte_offset is less than or equal to the size in bytes of the array passed in. If not, a RangeError exception is raised. JavaScript DataView objects are described in Section 24.3 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_functions_to_convert_from_c_types_to_n_api","title":"Functions to convert from C types to N-API","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_int32","title":"napi_create_int32","description":"napi_status napi_create_int32(napi_env env, int32_t value, napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: Integer value to be represented in JavaScript. [out] result: A napi_value representing a JavaScript Number.  Returns napi_ok if the API succeeded. This API is used to convert from the C int32_t type to the JavaScript Number type. The JavaScript Number type is described in Section 6.1.6 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_uint32","title":"napi_create_uint32","description":"napi_status napi_create_uint32(napi_env env, uint32_t value, napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: Unsigned integer value to be represented in JavaScript. [out] result: A napi_value representing a JavaScript Number.  Returns napi_ok if the API succeeded. This API is used to convert from the C uint32_t type to the JavaScript Number type. The JavaScript Number type is described in Section 6.1.6 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_int64","title":"napi_create_int64","description":"napi_status napi_create_int64(napi_env env, int64_t value, napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: Integer value to be represented in JavaScript. [out] result: A napi_value representing a JavaScript Number.  Returns napi_ok if the API succeeded. This API is used to convert from the C int64_t type to the JavaScript Number type. The JavaScript Number type is described in Section 6.1.6 of the ECMAScript Language Specification. Note the complete range of int64_t cannot be represented with full precision in JavaScript. Integer values outside the range of Number.MIN_SAFE_INTEGER -(2**53 - 1) - Number.MAX_SAFE_INTEGER (2**53 - 1) will lose precision."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_double","title":"napi_create_double","description":"napi_status napi_create_double(napi_env env, double value, napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: Double-precision value to be represented in JavaScript. [out] result: A napi_value representing a JavaScript Number.  Returns napi_ok if the API succeeded. This API is used to convert from the C double type to the JavaScript Number type. The JavaScript Number type is described in Section 6.1.6 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_bigint_int64","title":"napi_create_bigint_int64","description":"napi_status napi_create_bigint_int64(napi_env env,                                      int64_t value,                                      napi_value* result);   [in] env: The environment that the API is invoked under. [in] value: Integer value to be represented in JavaScript. [out] result: A napi_value representing a JavaScript BigInt.  Returns napi_ok if the API succeeded. This API converts the C int64_t type to the JavaScript BigInt type."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_bigint_uint64","title":"napi_create_bigint_uint64","description":"napi_status napi_create_bigint_uint64(napi_env env,                                       uint64_t value,                                       napi_value* result);   [in] env: The environment that the API is invoked under. [in] value: Unsigned integer value to be represented in JavaScript. [out] result: A napi_value representing a JavaScript BigInt.  Returns napi_ok if the API succeeded. This API converts the C uint64_t type to the JavaScript BigInt type."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_bigint_words","title":"napi_create_bigint_words","description":"napi_status napi_create_bigint_words(napi_env env,                                      int sign_bit,                                      size_t word_count,                                      const uint64_t* words,                                      napi_value* result);   [in] env: The environment that the API is invoked under. [in] sign_bit: Determines if the resulting BigInt will be positive or negative. [in] word_count: The length of the words array. [in] words: An array of uint64_t little-endian 64-bit words. [out] result: A napi_value representing a JavaScript BigInt.  Returns napi_ok if the API succeeded. This API converts an array of unsigned 64-bit words into a single BigInt value. The resulting BigInt is calculated as: (\u20131)sign_bit (words[0] \u00d7 (264)0 + words[1] \u00d7 (264)1 + \u2026)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_string_latin1","title":"napi_create_string_latin1","description":"napi_status napi_create_string_latin1(napi_env env,                                       const char* str,                                       size_t length,                                       napi_value* result);   [in] env: The environment that the API is invoked under. [in] str: Character buffer representing an ISO-8859-1-encoded string. [in] length: The length of the string in bytes, or NAPI_AUTO_LENGTH if it is null-terminated. [out] result: A napi_value representing a JavaScript String.  Returns napi_ok if the API succeeded. This API creates a JavaScript String object from an ISO-8859-1-encoded C string. The native string is copied. The JavaScript String type is described in Section 6.1.4 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_string_utf16","title":"napi_create_string_utf16","description":"napi_status napi_create_string_utf16(napi_env env,                                      const char16_t* str,                                      size_t length,                                      napi_value* result)   [in] env: The environment that the API is invoked under. [in] str: Character buffer representing a UTF16-LE-encoded string. [in] length: The length of the string in two-byte code units, or NAPI_AUTO_LENGTH if it is null-terminated. [out] result: A napi_value representing a JavaScript String.  Returns napi_ok if the API succeeded. This API creates a JavaScript String object from a UTF16-LE-encoded C string. The native string is copied. The JavaScript String type is described in Section 6.1.4 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_string_utf8","title":"napi_create_string_utf8","description":"napi_status napi_create_string_utf8(napi_env env,                                     const char* str,                                     size_t length,                                     napi_value* result)   [in] env: The environment that the API is invoked under. [in] str: Character buffer representing a UTF8-encoded string. [in] length: The length of the string in bytes, or NAPI_AUTO_LENGTH if it is null-terminated. [out] result: A napi_value representing a JavaScript String.  Returns napi_ok if the API succeeded. This API creates a JavaScript String object from a UTF8-encoded C string. The native string is copied. The JavaScript String type is described in Section 6.1.4 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_functions_to_convert_from_n_api_to_c_types","title":"Functions to convert from N-API to C types","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_array_length","title":"napi_get_array_length","description":"napi_status napi_get_array_length(napi_env env,                                   napi_value value,                                   uint32_t* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing the JavaScript Array whose length is being queried. [out] result: uint32 representing length of the array.  Returns napi_ok if the API succeeded. This API returns the length of an array. Array length is described in Section 22.1.4.1 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_arraybuffer_info","title":"napi_get_arraybuffer_info","description":"napi_status napi_get_arraybuffer_info(napi_env env,                                       napi_value arraybuffer,                                       void** data,                                       size_t* byte_length)   [in] env: The environment that the API is invoked under. [in] arraybuffer: napi_value representing the ArrayBuffer being queried. [out] data: The underlying data buffer of the ArrayBuffer. If byte_length is 0, this may be NULL or any other pointer value. [out] byte_length: Length in bytes of the underlying data buffer.  Returns napi_ok if the API succeeded. This API is used to retrieve the underlying data buffer of an ArrayBuffer and its length. WARNING: Use caution while using this API. The lifetime of the underlying data buffer is managed by the ArrayBuffer even after it's returned. A possible safe way to use this API is in conjunction with napi_create_reference, which can be used to guarantee control over the lifetime of the ArrayBuffer. It's also safe to use the returned data buffer within the same callback as long as there are no calls to other APIs that might trigger a GC."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_buffer_info","title":"napi_get_buffer_info","description":"napi_status napi_get_buffer_info(napi_env env,                                  napi_value value,                                  void** data,                                  size_t* length)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing the node::Buffer being queried. [out] data: The underlying data buffer of the node::Buffer. If length is 0, this may be NULL or any other pointer value. [out] length: Length in bytes of the underlying data buffer.  Returns napi_ok if the API succeeded. This API is used to retrieve the underlying data buffer of a node::Buffer and it's length. Warning: Use caution while using this API since the underlying data buffer's lifetime is not guaranteed if it's managed by the VM."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_prototype","title":"napi_get_prototype","description":"napi_status napi_get_prototype(napi_env env,                                napi_value object,                                napi_value* result)   [in] env: The environment that the API is invoked under. [in] object: napi_value representing JavaScript Object whose prototype to return. This returns the equivalent of Object.getPrototypeOf (which is not the same as the function's prototype property). [out] result: napi_value representing prototype of the given object.  Returns napi_ok if the API succeeded."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_typedarray_info","title":"napi_get_typedarray_info","description":"napi_status napi_get_typedarray_info(napi_env env,                                      napi_value typedarray,                                      napi_typedarray_type* type,                                      size_t* length,                                      void** data,                                      napi_value* arraybuffer,                                      size_t* byte_offset)   [in] env: The environment that the API is invoked under. [in] typedarray: napi_value representing the TypedArray whose properties to query. [out] type: Scalar datatype of the elements within the TypedArray. [out] length: The number of elements in the TypedArray. [out] data: The data buffer underlying the TypedArray adjusted by the byte_offset value so that it points to the first element in the TypedArray. If the length of the array is 0, this may be NULL or any other pointer value. [out] arraybuffer: The ArrayBuffer underlying the TypedArray. [out] byte_offset: The byte offset within the underlying native array at which the first element of the arrays is located. The value for the data parameter has already been adjusted so that data points to the first element in the array. Therefore, the first byte of the native array would be at data - byte_offset.  Returns napi_ok if the API succeeded. This API returns various properties of a typed array. Warning: Use caution while using this API since the underlying data buffer is managed by the VM."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_dataview_info","title":"napi_get_dataview_info","description":"napi_status napi_get_dataview_info(napi_env env,                                    napi_value dataview,                                    size_t* byte_length,                                    void** data,                                    napi_value* arraybuffer,                                    size_t* byte_offset)   [in] env: The environment that the API is invoked under. [in] dataview: napi_value representing the DataView whose properties to query. [out] byte_length: Number of bytes in the DataView. [out] data: The data buffer underlying the DataView. If byte_length is 0, this may be NULL or any other pointer value. [out] arraybuffer: ArrayBuffer underlying the DataView. [out] byte_offset: The byte offset within the data buffer from which to start projecting the DataView.  Returns napi_ok if the API succeeded. This API returns various properties of a DataView."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_date_value","title":"napi_get_date_value","description":"napi_status napi_get_date_value(napi_env env,                                 napi_value value,                                 double* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing a JavaScript Date. [out] result: Time value as a double represented as milliseconds since midnight at the beginning of 01 January, 1970 UTC.  This API does not observe leap seconds; they are ignored, as ECMAScript aligns with POSIX time specification. Returns napi_ok if the API succeeded. If a non-date napi_value is passed in it returns napi_date_expected. This API returns the C double primitive of time value for the given JavaScript Date."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_bool","title":"napi_get_value_bool","description":"napi_status napi_get_value_bool(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript Boolean. [out] result: C boolean primitive equivalent of the given JavaScript Boolean.  Returns napi_ok if the API succeeded. If a non-boolean napi_value is passed in it returns napi_boolean_expected. This API returns the C boolean primitive equivalent of the given JavaScript Boolean."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_double","title":"napi_get_value_double","description":"napi_status napi_get_value_double(napi_env env,                                   napi_value value,                                   double* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript Number. [out] result: C double primitive equivalent of the given JavaScript Number.  Returns napi_ok if the API succeeded. If a non-number napi_value is passed in it returns napi_number_expected. This API returns the C double primitive equivalent of the given JavaScript Number."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_bigint_int64","title":"napi_get_value_bigint_int64","description":"napi_status napi_get_value_bigint_int64(napi_env env,                                         napi_value value,                                         int64_t* result,                                         bool* lossless);   [in] env: The environment that the API is invoked under [in] value: napi_value representing JavaScript BigInt. [out] result: C int64_t primitive equivalent of the given JavaScript BigInt. [out] lossless: Indicates whether the BigInt value was converted losslessly.  Returns napi_ok if the API succeeded. If a non-BigInt is passed in it returns napi_bigint_expected. This API returns the C int64_t primitive equivalent of the given JavaScript BigInt. If needed it will truncate the value, setting lossless to false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_bigint_uint64","title":"napi_get_value_bigint_uint64","description":"napi_status napi_get_value_bigint_uint64(napi_env env,                                         napi_value value,                                         uint64_t* result,                                         bool* lossless);   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript BigInt. [out] result: C uint64_t primitive equivalent of the given JavaScript BigInt. [out] lossless: Indicates whether the BigInt value was converted losslessly.  Returns napi_ok if the API succeeded. If a non-BigInt is passed in it returns napi_bigint_expected. This API returns the C uint64_t primitive equivalent of the given JavaScript BigInt. If needed it will truncate the value, setting lossless to false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_bigint_words","title":"napi_get_value_bigint_words","description":"napi_status napi_get_value_bigint_words(napi_env env,                                         napi_value value,                                         int* sign_bit,                                         size_t* word_count,                                         uint64_t* words);   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript BigInt. [out] sign_bit: Integer representing if the JavaScript BigInt is positive or negative. [in\/out] word_count: Must be initialized to the length of the words array. Upon return, it will be set to the actual number of words that would be needed to store this BigInt. [out] words: Pointer to a pre-allocated 64-bit word array.  Returns napi_ok if the API succeeded. This API converts a single BigInt value into a sign bit, 64-bit little-endian array, and the number of elements in the array. sign_bit and words may be both set to NULL, in order to get only word_count."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_external","title":"napi_get_value_external","description":"napi_status napi_get_value_external(napi_env env,                                     napi_value value,                                     void** result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript external value. [out] result: Pointer to the data wrapped by the JavaScript external value.  Returns napi_ok if the API succeeded. If a non-external napi_value is passed in it returns napi_invalid_arg. This API retrieves the external data pointer that was previously passed to napi_create_external()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_int32","title":"napi_get_value_int32","description":"napi_status napi_get_value_int32(napi_env env,                                  napi_value value,                                  int32_t* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript Number. [out] result: C int32 primitive equivalent of the given JavaScript Number.  Returns napi_ok if the API succeeded. If a non-number napi_value is passed in napi_number_expected. This API returns the C int32 primitive equivalent of the given JavaScript Number. If the number exceeds the range of the 32 bit integer, then the result is truncated to the equivalent of the bottom 32 bits. This can result in a large positive number becoming a negative number if the value is > 231 - 1. Non-finite number values (NaN, +Infinity, or -Infinity) set the result to zero."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_int64","title":"napi_get_value_int64","description":"napi_status napi_get_value_int64(napi_env env,                                  napi_value value,                                  int64_t* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript Number. [out] result: C int64 primitive equivalent of the given JavaScript Number.  Returns napi_ok if the API succeeded. If a non-number napi_value is passed in it returns napi_number_expected. This API returns the C int64 primitive equivalent of the given JavaScript Number. Number values outside the range of Number.MIN_SAFE_INTEGER -(2**53 - 1) - Number.MAX_SAFE_INTEGER (2**53 - 1) will lose precision. Non-finite number values (NaN, +Infinity, or -Infinity) set the result to zero."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_string_latin1","title":"napi_get_value_string_latin1","description":"napi_status napi_get_value_string_latin1(napi_env env,                                          napi_value value,                                          char* buf,                                          size_t bufsize,                                          size_t* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript string. [in] buf: Buffer to write the ISO-8859-1-encoded string into. If NULL is passed in, the length of the string in bytes and excluding the null terminator is returned in result. [in] bufsize: Size of the destination buffer. When this value is insufficient, the returned string is truncated and null-terminated. [out] result: Number of bytes copied into the buffer, excluding the null terminator.  Returns napi_ok if the API succeeded. If a non-String napi_value is passed in it returns napi_string_expected. This API returns the ISO-8859-1-encoded string corresponding the value passed in."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_string_utf8","title":"napi_get_value_string_utf8","description":"napi_status napi_get_value_string_utf8(napi_env env,                                        napi_value value,                                        char* buf,                                        size_t bufsize,                                        size_t* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript string. [in] buf: Buffer to write the UTF8-encoded string into. If NULL is passed in, the length of the string in bytes and excluding the null terminator is returned in result. [in] bufsize: Size of the destination buffer. When this value is insufficient, the returned string is truncated and null-terminated. [out] result: Number of bytes copied into the buffer, excluding the null terminator.  Returns napi_ok if the API succeeded. If a non-String napi_value is passed in it returns napi_string_expected. This API returns the UTF8-encoded string corresponding the value passed in."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_string_utf16","title":"napi_get_value_string_utf16","description":"napi_status napi_get_value_string_utf16(napi_env env,                                         napi_value value,                                         char16_t* buf,                                         size_t bufsize,                                         size_t* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript string. [in] buf: Buffer to write the UTF16-LE-encoded string into. If NULL is passed in, the length of the string in 2-byte code units and excluding the null terminator is returned. [in] bufsize: Size of the destination buffer. When this value is insufficient, the returned string is truncated and null-terminated. [out] result: Number of 2-byte code units copied into the buffer, excluding the null terminator.  Returns napi_ok if the API succeeded. If a non-String napi_value is passed in it returns napi_string_expected. This API returns the UTF16-encoded string corresponding the value passed in."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_value_uint32","title":"napi_get_value_uint32","description":"napi_status napi_get_value_uint32(napi_env env,                                   napi_value value,                                   uint32_t* result)   [in] env: The environment that the API is invoked under. [in] value: napi_value representing JavaScript Number. [out] result: C primitive equivalent of the given napi_value as a uint32_t.  Returns napi_ok if the API succeeded. If a non-number napi_value is passed in it returns napi_number_expected. This API returns the C primitive equivalent of the given napi_value as a uint32_t."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_functions_to_get_global_instances","title":"Functions to get global instances","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_boolean","title":"napi_get_boolean","description":"napi_status napi_get_boolean(napi_env env, bool value, napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: The value of the boolean to retrieve. [out] result: napi_value representing JavaScript Boolean singleton to retrieve.  Returns napi_ok if the API succeeded. This API is used to return the JavaScript singleton object that is used to represent the given boolean value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_global","title":"napi_get_global","description":"napi_status napi_get_global(napi_env env, napi_value* result)   [in] env: The environment that the API is invoked under. [out] result: napi_value representing JavaScript global object.  Returns napi_ok if the API succeeded. This API returns the global object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_null","title":"napi_get_null","description":"napi_status napi_get_null(napi_env env, napi_value* result)   [in] env: The environment that the API is invoked under. [out] result: napi_value representing JavaScript null object.  Returns napi_ok if the API succeeded. This API returns the null object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_undefined","title":"napi_get_undefined","description":"napi_status napi_get_undefined(napi_env env, napi_value* result)   [in] env: The environment that the API is invoked under. [out] result: napi_value representing JavaScript Undefined value.  Returns napi_ok if the API succeeded. This API returns the Undefined object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_working_with_javascript_values_and_abstract_operations","title":"Working with JavaScript values and abstract operations","description":"N-API exposes a set of APIs to perform some abstract operations on JavaScript values. Some of these operations are documented under Section 7 of the ECMAScript Language Specification. These APIs support doing one of the following:  Coerce JavaScript values to specific JavaScript types (such as Number or String). Check the type of a JavaScript value. Check for equality between two JavaScript values."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_coerce_to_bool","title":"napi_coerce_to_bool","description":"napi_status napi_coerce_to_bool(napi_env env,                                 napi_value value,                                 napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to coerce. [out] result: napi_value representing the coerced JavaScript Boolean.  Returns napi_ok if the API succeeded. This API implements the abstract operation ToBoolean() as defined in Section 7.1.2 of the ECMAScript Language Specification. This API can be re-entrant if getters are defined on the passed-in Object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_coerce_to_number","title":"napi_coerce_to_number","description":"napi_status napi_coerce_to_number(napi_env env,                                   napi_value value,                                   napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to coerce. [out] result: napi_value representing the coerced JavaScript Number.  Returns napi_ok if the API succeeded. This API implements the abstract operation ToNumber() as defined in Section 7.1.3 of the ECMAScript Language Specification. This API can be re-entrant if getters are defined on the passed-in Object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_coerce_to_object","title":"napi_coerce_to_object","description":"napi_status napi_coerce_to_object(napi_env env,                                   napi_value value,                                   napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to coerce. [out] result: napi_value representing the coerced JavaScript Object.  Returns napi_ok if the API succeeded. This API implements the abstract operation ToObject() as defined in Section 7.1.13 of the ECMAScript Language Specification. This API can be re-entrant if getters are defined on the passed-in Object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_coerce_to_string","title":"napi_coerce_to_string","description":"napi_status napi_coerce_to_string(napi_env env,                                   napi_value value,                                   napi_value* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to coerce. [out] result: napi_value representing the coerced JavaScript String.  Returns napi_ok if the API succeeded. This API implements the abstract operation ToString() as defined in Section 7.1.13 of the ECMAScript Language Specification. This API can be re-entrant if getters are defined on the passed-in Object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_typeof","title":"napi_typeof","description":"napi_status napi_typeof(napi_env env, napi_value value, napi_valuetype* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value whose type to query. [out] result: The type of the JavaScript value.  Returns napi_ok if the API succeeded.  napi_invalid_arg if the type of value is not a known ECMAScript type and value is not an External value.  This API represents behavior similar to invoking the typeof Operator on the object as defined in Section 12.5.5 of the ECMAScript Language Specification. However, there are some differences:  It has support for detecting an External value. It detects null as a separate type, while ECMAScript typeof would detect object.  If value has a type that is invalid, an error is returned."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_instanceof","title":"napi_instanceof","description":"napi_status napi_instanceof(napi_env env,                             napi_value object,                             napi_value constructor,                             bool* result)   [in] env: The environment that the API is invoked under. [in] object: The JavaScript value to check. [in] constructor: The JavaScript function object of the constructor function to check against. [out] result: Boolean that is set to true if object instanceof constructor is true.  Returns napi_ok if the API succeeded. This API represents invoking the instanceof Operator on the object as defined in Section 12.10.4 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_array","title":"napi_is_array","description":"napi_status napi_is_array(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to check. [out] result: Whether the given object is an array.  Returns napi_ok if the API succeeded. This API represents invoking the IsArray operation on the object as defined in Section 7.2.2 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_arraybuffer","title":"napi_is_arraybuffer","description":"napi_status napi_is_arraybuffer(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to check. [out] result: Whether the given object is an ArrayBuffer.  Returns napi_ok if the API succeeded. This API checks if the Object passed in is an array buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_buffer","title":"napi_is_buffer","description":"napi_status napi_is_buffer(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to check. [out] result: Whether the given napi_value represents a node::Buffer object.  Returns napi_ok if the API succeeded. This API checks if the Object passed in is a buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_date","title":"napi_is_date","description":"napi_status napi_is_date(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to check. [out] result: Whether the given napi_value represents a JavaScript Date object.  Returns napi_ok if the API succeeded. This API checks if the Object passed in is a date."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_error","title":"napi_is_error","description":"napi_status napi_is_error(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to check. [out] result: Whether the given napi_value represents an Error object.  Returns napi_ok if the API succeeded. This API checks if the Object passed in is an Error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_typedarray","title":"napi_is_typedarray","description":"napi_status napi_is_typedarray(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to check. [out] result: Whether the given napi_value represents a TypedArray.  Returns napi_ok if the API succeeded. This API checks if the Object passed in is a typed array."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_dataview","title":"napi_is_dataview","description":"napi_status napi_is_dataview(napi_env env, napi_value value, bool* result)   [in] env: The environment that the API is invoked under. [in] value: The JavaScript value to check. [out] result: Whether the given napi_value represents a DataView.  Returns napi_ok if the API succeeded. This API checks if the Object passed in is a DataView."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_strict_equals","title":"napi_strict_equals","description":"napi_status napi_strict_equals(napi_env env,                                napi_value lhs,                                napi_value rhs,                                bool* result)   [in] env: The environment that the API is invoked under. [in] lhs: The JavaScript value to check. [in] rhs: The JavaScript value to check against. [out] result: Whether the two napi_value objects are equal.  Returns napi_ok if the API succeeded. This API represents the invocation of the Strict Equality algorithm as defined in Section 7.2.14 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_detach_arraybuffer","title":"napi_detach_arraybuffer","description":"napi_status napi_detach_arraybuffer(napi_env env,                                     napi_value arraybuffer)   [in] env: The environment that the API is invoked under. [in] arraybuffer: The JavaScript ArrayBuffer to be detached.  Returns napi_ok if the API succeeded. If a non-detachable ArrayBuffer is passed in it returns napi_detachable_arraybuffer_expected. Generally, an ArrayBuffer is non-detachable if it has been detached before. The engine may impose additional conditions on whether an ArrayBuffer is detachable. For example, V8 requires that the ArrayBuffer be external, that is, created with napi_create_external_arraybuffer. This API represents the invocation of the ArrayBuffer detach operation as defined in Section 24.1.1.3 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_detached_arraybuffer","title":"napi_is_detached_arraybuffer","description":"napi_status napi_is_detached_arraybuffer(napi_env env,                                          napi_value arraybuffer,                                          bool* result)   [in] env: The environment that the API is invoked under. [in] arraybuffer: The JavaScript ArrayBuffer to be checked. [out] result: Whether the arraybuffer is detached.  Returns napi_ok if the API succeeded. The ArrayBuffer is considered detached if its internal data is null. This API represents the invocation of the ArrayBuffer IsDetachedBuffer operation as defined in Section 24.1.1.2 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_working_with_javascript_properties","title":"Working with JavaScript properties","description":"N-API exposes a set of APIs to get and set properties on JavaScript objects. Some of these types are documented under Section 7 of the ECMAScript Language Specification. Properties in JavaScript are represented as a tuple of a key and a value. Fundamentally, all property keys in N-API can be represented in one of the following forms:  Named: a simple UTF8-encoded string Integer-Indexed: an index value represented by uint32_t JavaScript value: these are represented in N-API by napi_value. This can be a napi_value representing a String, Number, or Symbol.  N-API values are represented by the type napi_value. Any N-API call that requires a JavaScript value takes in a napi_value. However, it's the caller's responsibility to make sure that the napi_value in question is of the JavaScript type expected by the API. The APIs documented in this section provide a simple interface to get and set properties on arbitrary JavaScript objects represented by napi_value. For instance, consider the following JavaScript code snippet: const obj = {}; obj.myProp = 123;  The equivalent can be done using N-API values with the following snippet: napi_status status = napi_generic_failure;  \/\/ const obj = {} napi_value obj, value; status = napi_create_object(env, &obj); if (status != napi_ok) return status;  \/\/ Create a napi_value for 123 status = napi_create_int32(env, 123, &value); if (status != napi_ok) return status;  \/\/ obj.myProp = 123 status = napi_set_named_property(env, obj, \"myProp\", value); if (status != napi_ok) return status;  Indexed properties can be set in a similar manner. Consider the following JavaScript snippet: const arr = []; arr[123] = 'hello';  The equivalent can be done using N-API values with the following snippet: napi_status status = napi_generic_failure;  \/\/ const arr = []; napi_value arr, value; status = napi_create_array(env, &arr); if (status != napi_ok) return status;  \/\/ Create a napi_value for 'hello' status = napi_create_string_utf8(env, \"hello\", NAPI_AUTO_LENGTH, &value); if (status != napi_ok) return status;  \/\/ arr[123] = 'hello'; status = napi_set_element(env, arr, 123, value); if (status != napi_ok) return status;  Properties can be retrieved using the APIs described in this section. Consider the following JavaScript snippet: const arr = []; const value = arr[123];  The following is the approximate equivalent of the N-API counterpart: napi_status status = napi_generic_failure;  \/\/ const arr = [] napi_value arr, value; status = napi_create_array(env, &arr); if (status != napi_ok) return status;  \/\/ const value = arr[123] status = napi_get_element(env, arr, 123, &value); if (status != napi_ok) return status;  Finally, multiple properties can also be defined on an object for performance reasons. Consider the following JavaScript: const obj = {}; Object.defineProperties(obj, {   'foo': { value: 123, writable: true, configurable: true, enumerable: true },   'bar': { value: 456, writable: true, configurable: true, enumerable: true } });  The following is the approximate equivalent of the N-API counterpart: napi_status status = napi_status_generic_failure;  \/\/ const obj = {}; napi_value obj; status = napi_create_object(env, &obj); if (status != napi_ok) return status;  \/\/ Create napi_values for 123 and 456 napi_value fooValue, barValue; status = napi_create_int32(env, 123, &fooValue); if (status != napi_ok) return status; status = napi_create_int32(env, 456, &barValue); if (status != napi_ok) return status;  \/\/ Set the properties napi_property_descriptor descriptors[] = {   { \"foo\", NULL, NULL, NULL, NULL, fooValue, napi_writable | napi_configurable, NULL },   { \"bar\", NULL, NULL, NULL, NULL, barValue, napi_writable | napi_configurable, NULL } } status = napi_define_properties(env,                                 obj,                                 sizeof(descriptors) \/ sizeof(descriptors[0]),                                 descriptors); if (status != napi_ok) return status;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_structures","title":"Structures","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_property_attributes","title":"napi_property_attributes","description":"typedef enum {   napi_default = 0,   napi_writable = 1 << 0,   napi_enumerable = 1 << 1,   napi_configurable = 1 << 2,    \/\/ Used with napi_define_class to distinguish static properties   \/\/ from instance properties. Ignored by napi_define_properties.   napi_static = 1 << 10,    \/\/ Default for class methods.   napi_default_method = napi_writable | napi_configurable,    \/\/ Default for object properties, like in JS obj[prop].   napi_default_property = napi_writable |                           napi_enumerable |                           napi_configurable, } napi_property_attributes;  napi_property_attributes are flags used to control the behavior of properties set on a JavaScript object. Other than napi_static they correspond to the attributes listed in Section 6.1.7.1 of the ECMAScript Language Specification. They can be one or more of the following bitflags:  napi_default: No explicit attributes are set on the property. By default, a property is read only, not enumerable and not configurable. napi_writable: The property is writable. napi_enumerable: The property is enumerable. napi_configurable: The property is configurable as defined in Section 6.1.7.1 of the ECMAScript Language Specification. napi_static: The property will be defined as a static property on a class as opposed to an instance property, which is the default. This is used only by napi_define_class. It is ignored by napi_define_properties. napi_default_method: Like a method in a JS class, the property is configurable and writeable, but not enumerable. napi_default_property: Like a property set via assignment in JavaScript, the property is writable, enumerable, and configurable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_property_descriptor","title":"napi_property_descriptor","description":"typedef struct {   \/\/ One of utf8name or name should be NULL.   const char* utf8name;   napi_value name;    napi_callback method;   napi_callback getter;   napi_callback setter;   napi_value value;    napi_property_attributes attributes;   void* data; } napi_property_descriptor;   utf8name: Optional String describing the key for the property, encoded as UTF8. One of utf8name or name must be provided for the property. name: Optional napi_value that points to a JavaScript string or symbol to be used as the key for the property. One of utf8name or name must be provided for the property. value: The value that's retrieved by a get access of the property if the property is a data property. If this is passed in, set getter, setter, method and data to NULL (since these members won't be used). getter: A function to call when a get access of the property is performed. If this is passed in, set value and method to NULL (since these members won't be used). The given function is called implicitly by the runtime when the property is accessed from JavaScript code (or if a get on the property is performed using a N-API call). napi_callback provides more details. setter: A function to call when a set access of the property is performed. If this is passed in, set value and method to NULL (since these members won't be used). The given function is called implicitly by the runtime when the property is set from JavaScript code (or if a set on the property is performed using a N-API call). napi_callback provides more details. method: Set this to make the property descriptor object's value property to be a JavaScript function represented by method. If this is passed in, set value, getter and setter to NULL (since these members won't be used). napi_callback provides more details. attributes: The attributes associated with the particular property. See napi_property_attributes. data: The callback data passed into method, getter and setter if this function is invoked."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_functions","title":"Functions","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_property_names","title":"napi_get_property_names","description":"napi_status napi_get_property_names(napi_env env,                                     napi_value object,                                     napi_value* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object from which to retrieve the properties. [out] result: A napi_value representing an array of JavaScript values that represent the property names of the object. The API can be used to iterate over result using napi_get_array_length and napi_get_element.  Returns napi_ok if the API succeeded. This API returns the names of the enumerable properties of object as an array of strings. The properties of object whose key is a symbol will not be included."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_all_property_names","title":"napi_get_all_property_names","description":"napi_get_all_property_names(napi_env env,                             napi_value object,                             napi_key_collection_mode key_mode,                             napi_key_filter key_filter,                             napi_key_conversion key_conversion,                             napi_value* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object from which to retrieve the properties. [in] key_mode: Whether to retrieve prototype properties as well. [in] key_filter: Which properties to retrieve (enumerable\/readable\/writable). [in] key_conversion: Whether to convert numbered property keys to strings. [out] result: A napi_value representing an array of JavaScript values that represent the property names of the object. napi_get_array_length and napi_get_element can be used to iterate over result.  Returns napi_ok if the API succeeded. This API returns an array containing the names of the available properties of this object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_set_property","title":"napi_set_property","description":"napi_status napi_set_property(napi_env env,                               napi_value object,                               napi_value key,                               napi_value value);   [in] env: The environment that the N-API call is invoked under. [in] object: The object on which to set the property. [in] key: The name of the property to set. [in] value: The property value.  Returns napi_ok if the API succeeded. This API set a property on the Object passed in."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_property","title":"napi_get_property","description":"napi_status napi_get_property(napi_env env,                               napi_value object,                               napi_value key,                               napi_value* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object from which to retrieve the property. [in] key: The name of the property to retrieve. [out] result: The value of the property.  Returns napi_ok if the API succeeded. This API gets the requested property from the Object passed in."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_has_property","title":"napi_has_property","description":"napi_status napi_has_property(napi_env env,                               napi_value object,                               napi_value key,                               bool* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to query. [in] key: The name of the property whose existence to check. [out] result: Whether the property exists on the object or not.  Returns napi_ok if the API succeeded. This API checks if the Object passed in has the named property."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_delete_property","title":"napi_delete_property","description":"napi_status napi_delete_property(napi_env env,                                  napi_value object,                                  napi_value key,                                  bool* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to query. [in] key: The name of the property to delete. [out] result: Whether the property deletion succeeded or not. result can optionally be ignored by passing NULL.  Returns napi_ok if the API succeeded. This API attempts to delete the key own property from object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_has_own_property","title":"napi_has_own_property","description":"napi_status napi_has_own_property(napi_env env,                                   napi_value object,                                   napi_value key,                                   bool* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to query. [in] key: The name of the own property whose existence to check. [out] result: Whether the own property exists on the object or not.  Returns napi_ok if the API succeeded. This API checks if the Object passed in has the named own property. key must be a string or a Symbol, or an error will be thrown. N-API will not perform any conversion between data types."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_set_named_property","title":"napi_set_named_property","description":"napi_status napi_set_named_property(napi_env env,                                     napi_value object,                                     const char* utf8Name,                                     napi_value value);   [in] env: The environment that the N-API call is invoked under. [in] object: The object on which to set the property. [in] utf8Name: The name of the property to set. [in] value: The property value.  Returns napi_ok if the API succeeded. This method is equivalent to calling napi_set_property with a napi_value created from the string passed in as utf8Name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_named_property","title":"napi_get_named_property","description":"napi_status napi_get_named_property(napi_env env,                                     napi_value object,                                     const char* utf8Name,                                     napi_value* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object from which to retrieve the property. [in] utf8Name: The name of the property to get. [out] result: The value of the property.  Returns napi_ok if the API succeeded. This method is equivalent to calling napi_get_property with a napi_value created from the string passed in as utf8Name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_has_named_property","title":"napi_has_named_property","description":"napi_status napi_has_named_property(napi_env env,                                     napi_value object,                                     const char* utf8Name,                                     bool* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to query. [in] utf8Name: The name of the property whose existence to check. [out] result: Whether the property exists on the object or not.  Returns napi_ok if the API succeeded. This method is equivalent to calling napi_has_property with a napi_value created from the string passed in as utf8Name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_set_element","title":"napi_set_element","description":"napi_status napi_set_element(napi_env env,                              napi_value object,                              uint32_t index,                              napi_value value);   [in] env: The environment that the N-API call is invoked under. [in] object: The object from which to set the properties. [in] index: The index of the property to set. [in] value: The property value.  Returns napi_ok if the API succeeded. This API sets and element on the Object passed in."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_element","title":"napi_get_element","description":"napi_status napi_get_element(napi_env env,                              napi_value object,                              uint32_t index,                              napi_value* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object from which to retrieve the property. [in] index: The index of the property to get. [out] result: The value of the property.  Returns napi_ok if the API succeeded. This API gets the element at the requested index."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_has_element","title":"napi_has_element","description":"napi_status napi_has_element(napi_env env,                              napi_value object,                              uint32_t index,                              bool* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to query. [in] index: The index of the property whose existence to check. [out] result: Whether the property exists on the object or not.  Returns napi_ok if the API succeeded. This API returns if the Object passed in has an element at the requested index."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_delete_element","title":"napi_delete_element","description":"napi_status napi_delete_element(napi_env env,                                 napi_value object,                                 uint32_t index,                                 bool* result);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to query. [in] index: The index of the property to delete. [out] result: Whether the element deletion succeeded or not. result can optionally be ignored by passing NULL.  Returns napi_ok if the API succeeded. This API attempts to delete the specified index from object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_define_properties","title":"napi_define_properties","description":"napi_status napi_define_properties(napi_env env,                                    napi_value object,                                    size_t property_count,                                    const napi_property_descriptor* properties);   [in] env: The environment that the N-API call is invoked under. [in] object: The object from which to retrieve the properties. [in] property_count: The number of elements in the properties array. [in] properties: The array of property descriptors.  Returns napi_ok if the API succeeded. This method allows the efficient definition of multiple properties on a given object. The properties are defined using property descriptors (see napi_property_descriptor). Given an array of such property descriptors, this API will set the properties on the object one at a time, as defined by DefineOwnProperty() (described in Section 9.1.6 of the ECMA-262 specification)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_object_freeze","title":"napi_object_freeze","description":"napi_status napi_object_freeze(napi_env env,                                napi_value object);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to freeze.  Returns napi_ok if the API succeeded. This method freezes a given object. This prevents new properties from being added to it, existing properties from being removed, prevents changing the enumerability, configurability, or writability of existing properties, and prevents the values of existing properties from being changed. It also prevents the object's prototype from being changed. This is described in Section 19.1.2.6 of the ECMA-262 specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_object_seal","title":"napi_object_seal","description":"napi_status napi_object_seal(napi_env env,                              napi_value object);   [in] env: The environment that the N-API call is invoked under. [in] object: The object to seal.  Returns napi_ok if the API succeeded. This method seals a given object. This prevents new properties from being added to it, as well as marking all existing properties as non-configurable. This is described in Section 19.1.2.20 of the ECMA-262 specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_working_with_javascript_functions","title":"Working with JavaScript functions","description":"N-API provides a set of APIs that allow JavaScript code to call back into native code. N-API APIs that support calling back into native code take in a callback functions represented by the napi_callback type. When the JavaScript VM calls back to native code, the napi_callback function provided is invoked. The APIs documented in this section allow the callback function to do the following:  Get information about the context in which the callback was invoked. Get the arguments passed into the callback. Return a napi_value back from the callback.  Additionally, N-API provides a set of functions which allow calling JavaScript functions from native code. One can either call a function like a regular JavaScript function call, or as a constructor function. Any non-NULL data which is passed to this API via the data field of the napi_property_descriptor items can be associated with object and freed whenever object is garbage-collected by passing both object and the data to napi_add_finalizer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_call_function","title":"napi_call_function","description":"NAPI_EXTERN napi_status napi_call_function(napi_env env,                                            napi_value recv,                                            napi_value func,                                            size_t argc,                                            const napi_value* argv,                                            napi_value* result);   [in] env: The environment that the API is invoked under. [in] recv: The this object passed to the called function. [in] func: napi_value representing the JavaScript function to be invoked. [in] argc: The count of elements in the argv array. [in] argv: Array of napi_values representing JavaScript values passed in as arguments to the function. [out] result: napi_value representing the JavaScript object returned.  Returns napi_ok if the API succeeded. This method allows a JavaScript function object to be called from a native add-on. This is the primary mechanism of calling back from the add-on's native code into JavaScript. For the special case of calling into JavaScript after an async operation, see napi_make_callback. A sample use case might look as follows. Consider the following JavaScript snippet: function AddTwo(num) {   return num + 2; }  Then, the above function can be invoked from a native add-on using the following code: \/\/ Get the function named \"AddTwo\" on the global object napi_value global, add_two, arg; napi_status status = napi_get_global(env, &global); if (status != napi_ok) return;  status = napi_get_named_property(env, global, \"AddTwo\", &add_two); if (status != napi_ok) return;  \/\/ const arg = 1337 status = napi_create_int32(env, 1337, &arg); if (status != napi_ok) return;  napi_value* argv = &arg; size_t argc = 1;  \/\/ AddTwo(arg); napi_value return_val; status = napi_call_function(env, global, add_two, argc, argv, &return_val); if (status != napi_ok) return;  \/\/ Convert the result back to a native type int32_t result; status = napi_get_value_int32(env, return_val, &result); if (status != napi_ok) return;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_function","title":"napi_create_function","description":"napi_status napi_create_function(napi_env env,                                  const char* utf8name,                                  size_t length,                                  napi_callback cb,                                  void* data,                                  napi_value* result);   [in] env: The environment that the API is invoked under. [in] utf8Name: The name of the function encoded as UTF8. This is visible within JavaScript as the new function object's name property. [in] length: The length of the utf8name in bytes, or NAPI_AUTO_LENGTH if it is null-terminated. [in] cb: The native function which should be called when this function object is invoked. napi_callback provides more details. [in] data: User-provided data context. This will be passed back into the function when invoked later. [out] result: napi_value representing the JavaScript function object for the newly created function.  Returns napi_ok if the API succeeded. This API allows an add-on author to create a function object in native code. This is the primary mechanism to allow calling into the add-on's native code from JavaScript. The newly created function is not automatically visible from script after this call. Instead, a property must be explicitly set on any object that is visible to JavaScript, in order for the function to be accessible from script. In order to expose a function as part of the add-on's module exports, set the newly created function on the exports object. A sample module might look as follows: napi_value SayHello(napi_env env, napi_callback_info info) {   printf(\"Hello\\n\");   return NULL; }  napi_value Init(napi_env env, napi_value exports) {   napi_status status;    napi_value fn;   status = napi_create_function(env, NULL, 0, SayHello, NULL, &fn);   if (status != napi_ok) return NULL;    status = napi_set_named_property(env, exports, \"sayHello\", fn);   if (status != napi_ok) return NULL;    return exports; }  NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)  Given the above code, the add-on can be used from JavaScript as follows: const myaddon = require('.\/addon'); myaddon.sayHello();  The string passed to require() is the name of the target in binding.gyp responsible for creating the .node file. Any non-NULL data which is passed to this API via the data parameter can be associated with the resulting JavaScript function (which is returned in the result parameter) and freed whenever the function is garbage-collected by passing both the JavaScript function and the data to napi_add_finalizer. JavaScript Functions are described in Section 19.2 of the ECMAScript Language Specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_cb_info","title":"napi_get_cb_info","description":"napi_status napi_get_cb_info(napi_env env,                              napi_callback_info cbinfo,                              size_t* argc,                              napi_value* argv,                              napi_value* thisArg,                              void** data)   [in] env: The environment that the API is invoked under. [in] cbinfo: The callback info passed into the callback function. [in-out] argc: Specifies the length of the provided argv array and receives the actual count of arguments. [out] argv: Buffer to which the napi_value representing the arguments are copied. If there are more arguments than the provided count, only the requested number of arguments are copied. If there are fewer arguments provided than claimed, the rest of argv is filled with napi_value values that represent undefined. [out] this: Receives the JavaScript this argument for the call. [out] data: Receives the data pointer for the callback.  Returns napi_ok if the API succeeded. This method is used within a callback function to retrieve details about the call like the arguments and the this pointer from a given callback info."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_new_target","title":"napi_get_new_target","description":"napi_status napi_get_new_target(napi_env env,                                 napi_callback_info cbinfo,                                 napi_value* result)   [in] env: The environment that the API is invoked under. [in] cbinfo: The callback info passed into the callback function. [out] result: The new.target of the constructor call.  Returns napi_ok if the API succeeded. This API returns the new.target of the constructor call. If the current callback is not a constructor call, the result is NULL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_new_instance","title":"napi_new_instance","description":"napi_status napi_new_instance(napi_env env,                               napi_value cons,                               size_t argc,                               napi_value* argv,                               napi_value* result)   [in] env: The environment that the API is invoked under. [in] cons: napi_value representing the JavaScript function to be invoked as a constructor. [in] argc: The count of elements in the argv array. [in] argv: Array of JavaScript values as napi_value representing the arguments to the constructor. [out] result: napi_value representing the JavaScript object returned, which in this case is the constructed object.  This method is used to instantiate a new JavaScript value using a given napi_value that represents the constructor for the object. For example, consider the following snippet: function MyObject(param) {   this.param = param; }  const arg = 'hello'; const value = new MyObject(arg);  The following can be approximated in N-API using the following snippet: \/\/ Get the constructor function MyObject napi_value global, constructor, arg, value; napi_status status = napi_get_global(env, &global); if (status != napi_ok) return;  status = napi_get_named_property(env, global, \"MyObject\", &constructor); if (status != napi_ok) return;  \/\/ const arg = \"hello\" status = napi_create_string_utf8(env, \"hello\", NAPI_AUTO_LENGTH, &arg); if (status != napi_ok) return;  napi_value* argv = &arg; size_t argc = 1;  \/\/ const value = new MyObject(arg) status = napi_new_instance(env, constructor, argc, argv, &value);  Returns napi_ok if the API succeeded."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_object_wrap","title":"Object wrap","description":"N-API offers a way to \"wrap\" C++ classes and instances so that the class constructor and methods can be called from JavaScript.  The napi_define_class API defines a JavaScript class with constructor, static properties and methods, and instance properties and methods that correspond to the C++ class. When JavaScript code invokes the constructor, the constructor callback uses napi_wrap to wrap a new C++ instance in a JavaScript object, then returns the wrapper object. When JavaScript code invokes a method or property accessor on the class, the corresponding napi_callback C++ function is invoked. For an instance callback, napi_unwrap obtains the C++ instance that is the target of the call.  For wrapped objects it may be difficult to distinguish between a function called on a class prototype and a function called on an instance of a class. A common pattern used to address this problem is to save a persistent reference to the class constructor for later instanceof checks. napi_value MyClass_constructor = NULL; status = napi_get_reference_value(env, MyClass::es_constructor, &MyClass_constructor); assert(napi_ok == status); bool is_instance = false; status = napi_instanceof(env, es_this, MyClass_constructor, &is_instance); assert(napi_ok == status); if (is_instance) {   \/\/ napi_unwrap() ... } else {   \/\/ otherwise... }  The reference must be freed once it is no longer needed. There are occasions where napi_instanceof() is insufficient for ensuring that a JavaScript object is a wrapper for a certain native type. This is the case especially when wrapped JavaScript objects are passed back into the addon via static methods rather than as the this value of prototype methods. In such cases there is a chance that they may be unwrapped incorrectly. const myAddon = require('.\/build\/Release\/my_addon.node');  \/\/ `openDatabase()` returns a JavaScript object that wraps a native database \/\/ handle. const dbHandle = myAddon.openDatabase();  \/\/ `query()` returns a JavaScript object that wraps a native query handle. const queryHandle = myAddon.query(dbHandle, 'Gimme ALL the things!');  \/\/ There is an accidental error in the line below. The first parameter to \/\/ `myAddon.queryHasRecords()` should be the database handle (`dbHandle`), not \/\/ the query handle (`query`), so the correct condition for the while-loop \/\/ should be \/\/ \/\/ myAddon.queryHasRecords(dbHandle, queryHandle) \/\/ while (myAddon.queryHasRecords(queryHandle, dbHandle)) {   \/\/ retrieve records }  In the above example myAddon.queryHasRecords() is a method that accepts two arguments. The first is a database handle and the second is a query handle. Internally, it unwraps the first argument and casts the resulting pointer to a native database handle. It then unwraps the second argument and casts the resulting pointer to a query handle. If the arguments are passed in the wrong order, the casts will work, however, there is a good chance that the underlying database operation will fail, or will even cause an invalid memory access. To ensure that the pointer retrieved from the first argument is indeed a pointer to a database handle and, similarly, that the pointer retrieved from the second argument is indeed a pointer to a query handle, the implementation of queryHasRecords() has to perform a type validation. Retaining the JavaScript class constructor from which the database handle was instantiated and the constructor from which the query handle was instantiated in napi_refs can help, because napi_instanceof() can then be used to ensure that the instances passed into queryHashRecords() are indeed of the correct type. Unfortunately, napi_instanceof() does not protect against prototype manipulation. For example, the prototype of the database handle instance can be set to the prototype of the constructor for query handle instances. In this case, the database handle instance can appear as a query handle instance, and it will pass the napi_instanceof() test for a query handle instance, while still containing a pointer to a database handle. To this end, N-API provides type-tagging capabilities. A type tag is a 128-bit integer unique to the addon. N-API provides the napi_type_tag structure for storing a type tag. When such a value is passed along with a JavaScript object stored in a napi_value to napi_type_tag_object(), the JavaScript object will be \"marked\" with the type tag. The \"mark\" is invisible on the JavaScript side. When a JavaScript object arrives into a native binding, napi_check_object_type_tag() can be used along with the original type tag to determine whether the JavaScript object was previously \"marked\" with the type tag. This creates a type-checking capability of a higher fidelity than napi_instanceof() can provide, because such type- tagging survives prototype manipulation and addon unloading\/reloading. Continuing the above example, the following skeleton addon implementation illustrates the use of napi_type_tag_object() and napi_check_object_type_tag(). \/\/ This value is the type tag for a database handle. The command \/\/ \/\/   uuidgen | sed -r -e 's\/-\/\/g' -e 's\/(.{16})(.*)\/0x\\1, 0x\\2\/' \/\/ \/\/ can be used to obtain the two values with which to initialize the structure. static const napi_type_tag DatabaseHandleTypeTag = {   0x1edf75a38336451d, 0xa5ed9ce2e4c00c38 };  \/\/ This value is the type tag for a query handle. static const napi_type_tag QueryHandleTypeTag = {   0x9c73317f9fad44a3, 0x93c3920bf3b0ad6a };  static napi_value openDatabase(napi_env env, napi_callback_info info) {   napi_status status;   napi_value result;    \/\/ Perform the underlying action which results in a database handle.   DatabaseHandle* dbHandle = open_database();    \/\/ Create a new, empty JS object.   status = napi_create_object(env, &result);   if (status != napi_ok) return NULL;    \/\/ Tag the object to indicate that it holds a pointer to a `DatabaseHandle`.   status = napi_type_tag_object(env, result, &DatabaseHandleTypeTag);   if (status != napi_ok) return NULL;    \/\/ Store the pointer to the `DatabaseHandle` structure inside the JS object.   status = napi_wrap(env, result, dbHandle, NULL, NULL, NULL);   if (status != napi_ok) return NULL;    return result; }  \/\/ Later when we receive a JavaScript object purporting to be a database handle \/\/ we can use `napi_check_object_type_tag()` to ensure that it is indeed such a \/\/ handle.  static napi_value query(napi_env env, napi_callback_info info) {   napi_status status;   size_t argc = 2;   napi_value argv[2];   bool is_db_handle;    status = napi_get_cb_info(env, info, &argc, argv, NULL, NULL);   if (status != napi_ok) return NULL;    \/\/ Check that the object passed as the first parameter has the previously   \/\/ applied tag.   status = napi_check_object_type_tag(env,                                       argv[0],                                       &DatabaseHandleTypeTag,                                       &is_db_handle);   if (status != napi_ok) return NULL;    \/\/ Throw a `TypeError` if it doesn't.   if (!is_db_handle) {     \/\/ Throw a TypeError.     return NULL;   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_define_class","title":"napi_define_class","description":"napi_status napi_define_class(napi_env env,                               const char* utf8name,                               size_t length,                               napi_callback constructor,                               void* data,                               size_t property_count,                               const napi_property_descriptor* properties,                               napi_value* result);   [in] env: The environment that the API is invoked under. [in] utf8name: Name of the JavaScript constructor function; this is not required to be the same as the C++ class name, though it is recommended for clarity. [in] length: The length of the utf8name in bytes, or NAPI_AUTO_LENGTH if it is null-terminated. [in] constructor: Callback function that handles constructing instances of the class. This should be a static method on the class, not an actual C++ constructor function. napi_callback provides more details. [in] data: Optional data to be passed to the constructor callback as the data property of the callback info. [in] property_count: Number of items in the properties array argument. [in] properties: Array of property descriptors describing static and instance data properties, accessors, and methods on the class See napi_property_descriptor. [out] result: A napi_value representing the constructor function for the class.  Returns napi_ok if the API succeeded. Defines a JavaScript class that corresponds to a C++ class, including:  A JavaScript constructor function that has the class name and invokes the provided C++ constructor callback. Properties on the constructor function corresponding to static data properties, accessors, and methods of the C++ class (defined by property descriptors with the napi_static attribute). Properties on the constructor function's prototype object corresponding to non-static data properties, accessors, and methods of the C++ class (defined by property descriptors without the napi_static attribute).  The C++ constructor callback should be a static method on the class that calls the actual class constructor, then wraps the new C++ instance in a JavaScript object, and returns the wrapper object. See napi_wrap() for details. The JavaScript constructor function returned from napi_define_class is often saved and used later, to construct new instances of the class from native code, and\/or check whether provided values are instances of the class. In that case, to prevent the function value from being garbage-collected, create a persistent reference to it using napi_create_reference and ensure the reference count is kept >= 1. Any non-NULL data which is passed to this API via the data parameter or via the data field of the napi_property_descriptor array items can be associated with the resulting JavaScript constructor (which is returned in the result parameter) and freed whenever the class is garbage-collected by passing both the JavaScript function and the data to napi_add_finalizer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_wrap","title":"napi_wrap","description":"napi_status napi_wrap(napi_env env,                       napi_value js_object,                       void* native_object,                       napi_finalize finalize_cb,                       void* finalize_hint,                       napi_ref* result);   [in] env: The environment that the API is invoked under. [in] js_object: The JavaScript object that will be the wrapper for the native object. [in] native_object: The native instance that will be wrapped in the JavaScript object. [in] finalize_cb: Optional native callback that can be used to free the native instance when the JavaScript object is ready for garbage-collection. napi_finalize provides more details. [in] finalize_hint: Optional contextual hint that is passed to the finalize callback. [out] result: Optional reference to the wrapped object.  Returns napi_ok if the API succeeded. Wraps a native instance in a JavaScript object. The native instance can be retrieved later using napi_unwrap(). When JavaScript code invokes a constructor for a class that was defined using napi_define_class(), the napi_callback for the constructor is invoked. After constructing an instance of the native class, the callback must then call napi_wrap() to wrap the newly constructed instance in the already-created JavaScript object that is the this argument to the constructor callback. (That this object was created from the constructor function's prototype, so it already has definitions of all the instance properties and methods.) Typically when wrapping a class instance, a finalize callback should be provided that simply deletes the native instance that is received as the data argument to the finalize callback. The optional returned reference is initially a weak reference, meaning it has a reference count of 0. Typically this reference count would be incremented temporarily during async operations that require the instance to remain valid. Caution: The optional returned reference (if obtained) should be deleted via napi_delete_reference ONLY in response to the finalize callback invocation. If it is deleted before then, then the finalize callback may never be invoked. Therefore, when obtaining a reference a finalize callback is also required in order to enable correct disposal of the reference. Calling napi_wrap() a second time on an object will return an error. To associate another native instance with the object, use napi_remove_wrap() first."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_unwrap","title":"napi_unwrap","description":"napi_status napi_unwrap(napi_env env,                         napi_value js_object,                         void** result);   [in] env: The environment that the API is invoked under. [in] js_object: The object associated with the native instance. [out] result: Pointer to the wrapped native instance.  Returns napi_ok if the API succeeded. Retrieves a native instance that was previously wrapped in a JavaScript object using napi_wrap(). When JavaScript code invokes a method or property accessor on the class, the corresponding napi_callback is invoked. If the callback is for an instance method or accessor, then the this argument to the callback is the wrapper object; the wrapped C++ instance that is the target of the call can be obtained then by calling napi_unwrap() on the wrapper object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_remove_wrap","title":"napi_remove_wrap","description":"napi_status napi_remove_wrap(napi_env env,                              napi_value js_object,                              void** result);   [in] env: The environment that the API is invoked under. [in] js_object: The object associated with the native instance. [out] result: Pointer to the wrapped native instance.  Returns napi_ok if the API succeeded. Retrieves a native instance that was previously wrapped in the JavaScript object js_object using napi_wrap() and removes the wrapping. If a finalize callback was associated with the wrapping, it will no longer be called when the JavaScript object becomes garbage-collected."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_type_tag_object","title":"napi_type_tag_object","description":"napi_status napi_type_tag_object(napi_env env,                                  napi_value js_object,                                  const napi_type_tag* type_tag);   [in] env: The environment that the API is invoked under. [in] js_object: The JavaScript object to be marked. [in] type_tag: The tag with which the object is to be marked.  Returns napi_ok if the API succeeded. Associates the value of the type_tag pointer with the JavaScript object. napi_check_object_type_tag() can then be used to compare the tag that was attached to the object with one owned by the addon to ensure that the object has the right type. If the object already has an associated type tag, this API will return napi_invalid_arg."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_check_object_type_tag","title":"napi_check_object_type_tag","description":"napi_status napi_check_object_type_tag(napi_env env,                                        napi_value js_object,                                        const napi_type_tag* type_tag,                                        bool* result);   [in] env: The environment that the API is invoked under. [in] js_object: The JavaScript object whose type tag to examine. [in] type_tag: The tag with which to compare any tag found on the object. [out] result: Whether the type tag given matched the type tag on the object. false is also returned if no type tag was found on the object.  Returns napi_ok if the API succeeded. Compares the pointer given as type_tag with any that can be found on js_object. If no tag is found on js_object or, if a tag is found but it does not match type_tag, then result is set to false. If a tag is found and it matches type_tag, then result is set to true."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_add_finalizer","title":"napi_add_finalizer","description":"napi_status napi_add_finalizer(napi_env env,                                napi_value js_object,                                void* native_object,                                napi_finalize finalize_cb,                                void* finalize_hint,                                napi_ref* result);   [in] env: The environment that the API is invoked under. [in] js_object: The JavaScript object to which the native data will be attached. [in] native_object: The native data that will be attached to the JavaScript object. [in] finalize_cb: Native callback that will be used to free the native data when the JavaScript object is ready for garbage-collection. napi_finalize provides more details. [in] finalize_hint: Optional contextual hint that is passed to the finalize callback. [out] result: Optional reference to the JavaScript object.  Returns napi_ok if the API succeeded. Adds a napi_finalize callback which will be called when the JavaScript object in js_object is ready for garbage collection. This API is similar to napi_wrap() except that:  the native data cannot be retrieved later using napi_unwrap(), nor can it be removed later using napi_remove_wrap(), and the API can be called multiple times with different data items in order to attach each of them to the JavaScript object, and the object manipulated by the API can be used with napi_wrap().  Caution: The optional returned reference (if obtained) should be deleted via napi_delete_reference ONLY in response to the finalize callback invocation. If it is deleted before then, then the finalize callback may never be invoked. Therefore, when obtaining a reference a finalize callback is also required in order to enable correct disposal of the reference."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_simple_asynchronous_operations","title":"Simple asynchronous operations","description":"Addon modules often need to leverage async helpers from libuv as part of their implementation. This allows them to schedule work to be executed asynchronously so that their methods can return in advance of the work being completed. This allows them to avoid blocking overall execution of the Node.js application. N-API provides an ABI-stable interface for these supporting functions which covers the most common asynchronous use cases. N-API defines the napi_async_work structure which is used to manage asynchronous workers. Instances are created\/deleted with napi_create_async_work and napi_delete_async_work. The execute and complete callbacks are functions that will be invoked when the executor is ready to execute and when it completes its task respectively. The execute function should avoid making any N-API calls that could result in the execution of JavaScript or interaction with JavaScript objects. Most often, any code that needs to make N-API calls should be made in complete callback instead. Avoid using the napi_env parameter in the execute callback as it will likely execute JavaScript. These functions implement the following interfaces: typedef void (*napi_async_execute_callback)(napi_env env,                                             void* data); typedef void (*napi_async_complete_callback)(napi_env env,                                              napi_status status,                                              void* data);  When these methods are invoked, the data parameter passed will be the addon-provided void* data that was passed into the napi_create_async_work call. Once created the async worker can be queued for execution using the napi_queue_async_work function: napi_status napi_queue_async_work(napi_env env,                                   napi_async_work work);  napi_cancel_async_work can be used if the work needs to be cancelled before the work has started execution. After calling napi_cancel_async_work, the complete callback will be invoked with a status value of napi_cancelled. The work should not be deleted before the complete callback invocation, even when it was cancelled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_async_work","title":"napi_create_async_work","description":"napi_status napi_create_async_work(napi_env env,                                    napi_value async_resource,                                    napi_value async_resource_name,                                    napi_async_execute_callback execute,                                    napi_async_complete_callback complete,                                    void* data,                                    napi_async_work* result);   [in] env: The environment that the API is invoked under. [in] async_resource: An optional object associated with the async work that will be passed to possible async_hooks init hooks. [in] async_resource_name: Identifier for the kind of resource that is being provided for diagnostic information exposed by the async_hooks API. [in] execute: The native function which should be called to execute the logic asynchronously. The given function is called from a worker pool thread and can execute in parallel with the main event loop thread. [in] complete: The native function which will be called when the asynchronous logic is completed or is cancelled. The given function is called from the main event loop thread. napi_async_complete_callback provides more details. [in] data: User-provided data context. This will be passed back into the execute and complete functions. [out] result: napi_async_work* which is the handle to the newly created async work.  Returns napi_ok if the API succeeded. This API allocates a work object that is used to execute logic asynchronously. It should be freed using napi_delete_async_work once the work is no longer required. async_resource_name should be a null-terminated, UTF-8-encoded string. The async_resource_name identifier is provided by the user and should be representative of the type of async work being performed. It is also recommended to apply namespacing to the identifier, e.g. by including the module name. See the async_hooks documentation for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_delete_async_work","title":"napi_delete_async_work","description":"napi_status napi_delete_async_work(napi_env env,                                    napi_async_work work);   [in] env: The environment that the API is invoked under. [in] work: The handle returned by the call to napi_create_async_work.  Returns napi_ok if the API succeeded. This API frees a previously allocated work object. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_queue_async_work","title":"napi_queue_async_work","description":"napi_status napi_queue_async_work(napi_env env,                                   napi_async_work work);   [in] env: The environment that the API is invoked under. [in] work: The handle returned by the call to napi_create_async_work.  Returns napi_ok if the API succeeded. This API requests that the previously allocated work be scheduled for execution. Once it returns successfully, this API must not be called again with the same napi_async_work item or the result will be undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_cancel_async_work","title":"napi_cancel_async_work","description":"napi_status napi_cancel_async_work(napi_env env,                                    napi_async_work work);   [in] env: The environment that the API is invoked under. [in] work: The handle returned by the call to napi_create_async_work.  Returns napi_ok if the API succeeded. This API cancels queued work if it has not yet been started. If it has already started executing, it cannot be cancelled and napi_generic_failure will be returned. If successful, the complete callback will be invoked with a status value of napi_cancelled. The work should not be deleted before the complete callback invocation, even if it has been successfully cancelled. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_custom_asynchronous_operations","title":"Custom asynchronous operations","description":"The simple asynchronous work APIs above may not be appropriate for every scenario. When using any other asynchronous mechanism, the following APIs are necessary to ensure an asynchronous operation is properly tracked by the runtime."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_async_init","title":"napi_async_init","description":"napi_status napi_async_init(napi_env env,                             napi_value async_resource,                             napi_value async_resource_name,                             napi_async_context* result)   [in] env: The environment that the API is invoked under. [in] async_resource: Object associated with the async work that will be passed to possible async_hooks init hooks and can be accessed by async_hooks.executionAsyncResource(). [in] async_resource_name: Identifier for the kind of resource that is being provided for diagnostic information exposed by the async_hooks API. [out] result: The initialized async context.  Returns napi_ok if the API succeeded. The async_resource object needs to be kept alive until napi_async_destroy to keep async_hooks related API acts correctly. In order to retain ABI compatibility with previous versions, napi_async_contexts are not maintaining the strong reference to the async_resource objects to avoid introducing causing memory leaks. However, if the async_resource is garbage collected by JavaScript engine before the napi_async_context was destroyed by napi_async_destroy, calling napi_async_context related APIs like napi_open_callback_scope and napi_make_callback can cause problems like loss of async context when using the AsyncLocalStoage API. In order to retain ABI compatibility with previous versions, passing NULL for async_resource does not result in an error. However, this is not recommended as this will result poor results with  async_hooks init hooks and async_hooks.executionAsyncResource() as the resource is now required by the underlying async_hooks implementation in order to provide the linkage between async callbacks."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_async_destroy","title":"napi_async_destroy","description":"napi_status napi_async_destroy(napi_env env,                                napi_async_context async_context);   [in] env: The environment that the API is invoked under. [in] async_context: The async context to be destroyed.  Returns napi_ok if the API succeeded. This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_make_callback","title":"napi_make_callback","description":"NAPI_EXTERN napi_status napi_make_callback(napi_env env,                                            napi_async_context async_context,                                            napi_value recv,                                            napi_value func,                                            size_t argc,                                            const napi_value* argv,                                            napi_value* result);   [in] env: The environment that the API is invoked under. [in] async_context: Context for the async operation that is invoking the callback. This should normally be a value previously obtained from napi_async_init. In order to retain ABI compatibility with previous versions, passing NULL for async_context does not result in an error. However, this results in incorrect operation of async hooks. Potential issues include loss of async context when using the AsyncLocalStorage API. [in] recv: The this object passed to the called function. [in] func: napi_value representing the JavaScript function to be invoked. [in] argc: The count of elements in the argv array. [in] argv: Array of JavaScript values as napi_value representing the arguments to the function. [out] result: napi_value representing the JavaScript object returned.  Returns napi_ok if the API succeeded. This method allows a JavaScript function object to be called from a native add-on. This API is similar to napi_call_function. However, it is used to call from native code back into JavaScript after returning from an async operation (when there is no other script on the stack). It is a fairly simple wrapper around node::MakeCallback. Note it is not necessary to use napi_make_callback from within a napi_async_complete_callback; in that situation the callback's async context has already been set up, so a direct call to napi_call_function is sufficient and appropriate. Use of the napi_make_callback function may be required when implementing custom async behavior that does not use napi_create_async_work. Any process.nextTicks or Promises scheduled on the microtask queue by JavaScript during the callback are ran before returning back to C\/C++."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_open_callback_scope","title":"napi_open_callback_scope","description":"NAPI_EXTERN napi_status napi_open_callback_scope(napi_env env,                                                  napi_value resource_object,                                                  napi_async_context context,                                                  napi_callback_scope* result)   [in] env: The environment that the API is invoked under. [in] resource_object: An object associated with the async work that will be passed to possible async_hooks init hooks. This parameter has been deprecated and is ignored at runtime. Use the async_resource parameter in napi_async_init instead. [in] context: Context for the async operation that is invoking the callback. This should be a value previously obtained from napi_async_init. [out] result: The newly created scope.  There are cases (for example, resolving promises) where it is necessary to have the equivalent of the scope associated with a callback in place when making certain N-API calls. If there is no other script on the stack the napi_open_callback_scope and napi_close_callback_scope functions can be used to open\/close the required scope."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_close_callback_scope","title":"napi_close_callback_scope","description":"NAPI_EXTERN napi_status napi_close_callback_scope(napi_env env,                                                   napi_callback_scope scope)   [in] env: The environment that the API is invoked under. [in] scope: The scope to be closed.  This API can be called even if there is a pending JavaScript exception."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_version_management","title":"Version management","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_node_version","title":"napi_get_node_version","description":"typedef struct {   uint32_t major;   uint32_t minor;   uint32_t patch;   const char* release; } napi_node_version;  napi_status napi_get_node_version(napi_env env,                                   const napi_node_version** version);   [in] env: The environment that the API is invoked under. [out] version: A pointer to version information for Node.js itself.  Returns napi_ok if the API succeeded. This function fills the version struct with the major, minor, and patch version of Node.js that is currently running, and the release field with the value of process.release.name. The returned buffer is statically allocated and does not need to be freed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_version","title":"napi_get_version","description":"napi_status napi_get_version(napi_env env,                              uint32_t* result);   [in] env: The environment that the API is invoked under. [out] result: The highest version of N-API supported.  Returns napi_ok if the API succeeded. This API returns the highest N-API version supported by the Node.js runtime. N-API is planned to be additive such that newer releases of Node.js may support additional API functions. In order to allow an addon to use a newer function when running with versions of Node.js that support it, while providing fallback behavior when running with Node.js versions that don't support it:  Call napi_get_version() to determine if the API is available. If available, dynamically load a pointer to the function using uv_dlsym(). Use the dynamically loaded pointer to invoke the function. If the function is not available, provide an alternate implementation that does not use the function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_memory_management","title":"Memory management","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_adjust_external_memory","title":"napi_adjust_external_memory","description":"NAPI_EXTERN napi_status napi_adjust_external_memory(napi_env env,                                                     int64_t change_in_bytes,                                                     int64_t* result);   [in] env: The environment that the API is invoked under. [in] change_in_bytes: The change in externally allocated memory that is kept alive by JavaScript objects. [out] result: The adjusted value  Returns napi_ok if the API succeeded. This function gives V8 an indication of the amount of externally allocated memory that is kept alive by JavaScript objects (i.e. a JavaScript object that points to its own memory allocated by a native module). Registering externally allocated memory will trigger global garbage collections more often than it would otherwise."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_promises","title":"Promises","description":"N-API provides facilities for creating Promise objects as described in Section 25.4 of the ECMA specification. It implements promises as a pair of objects. When a promise is created by napi_create_promise(), a \"deferred\" object is created and returned alongside the Promise. The deferred object is bound to the created Promise and is the only means to resolve or reject the Promise using napi_resolve_deferred() or napi_reject_deferred(). The deferred object that is created by napi_create_promise() is freed by napi_resolve_deferred() or napi_reject_deferred(). The Promise object may be returned to JavaScript where it can be used in the usual fashion. For example, to create a promise and pass it to an asynchronous worker: napi_deferred deferred; napi_value promise; napi_status status;  \/\/ Create the promise. status = napi_create_promise(env, &deferred, &promise); if (status != napi_ok) return NULL;  \/\/ Pass the deferred to a function that performs an asynchronous action. do_something_asynchronous(deferred);  \/\/ Return the promise to JS return promise;  The above function do_something_asynchronous() would perform its asynchronous action and then it would resolve or reject the deferred, thereby concluding the promise and freeing the deferred: napi_deferred deferred; napi_value undefined; napi_status status;  \/\/ Create a value with which to conclude the deferred. status = napi_get_undefined(env, &undefined); if (status != napi_ok) return NULL;  \/\/ Resolve or reject the promise associated with the deferred depending on \/\/ whether the asynchronous action succeeded. if (asynchronous_action_succeeded) {   status = napi_resolve_deferred(env, deferred, undefined); } else {   status = napi_reject_deferred(env, deferred, undefined); } if (status != napi_ok) return NULL;  \/\/ At this point the deferred has been freed, so we should assign NULL to it. deferred = NULL;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_promise","title":"napi_create_promise","description":"napi_status napi_create_promise(napi_env env,                                 napi_deferred* deferred,                                 napi_value* promise);   [in] env: The environment that the API is invoked under. [out] deferred: A newly created deferred object which can later be passed to napi_resolve_deferred() or napi_reject_deferred() to resolve resp. reject the associated promise. [out] promise: The JavaScript promise associated with the deferred object.  Returns napi_ok if the API succeeded. This API creates a deferred object and a JavaScript promise."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_resolve_deferred","title":"napi_resolve_deferred","description":"napi_status napi_resolve_deferred(napi_env env,                                   napi_deferred deferred,                                   napi_value resolution);   [in] env: The environment that the API is invoked under. [in] deferred: The deferred object whose associated promise to resolve. [in] resolution: The value with which to resolve the promise.  This API resolves a JavaScript promise by way of the deferred object with which it is associated. Thus, it can only be used to resolve JavaScript promises for which the corresponding deferred object is available. This effectively means that the promise must have been created using napi_create_promise() and the deferred object returned from that call must have been retained in order to be passed to this API. The deferred object is freed upon successful completion."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_reject_deferred","title":"napi_reject_deferred","description":"napi_status napi_reject_deferred(napi_env env,                                  napi_deferred deferred,                                  napi_value rejection);   [in] env: The environment that the API is invoked under. [in] deferred: The deferred object whose associated promise to resolve. [in] rejection: The value with which to reject the promise.  This API rejects a JavaScript promise by way of the deferred object with which it is associated. Thus, it can only be used to reject JavaScript promises for which the corresponding deferred object is available. This effectively means that the promise must have been created using napi_create_promise() and the deferred object returned from that call must have been retained in order to be passed to this API. The deferred object is freed upon successful completion."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_is_promise","title":"napi_is_promise","description":"napi_status napi_is_promise(napi_env env,                             napi_value value,                             bool* is_promise);   [in] env: The environment that the API is invoked under. [in] value: The value to examine [out] is_promise: Flag indicating whether promise is a native promise object (that is, a promise object created by the underlying engine)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_script_execution","title":"Script execution","description":"N-API provides an API for executing a string containing JavaScript using the underlying JavaScript engine."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_run_script","title":"napi_run_script","description":"NAPI_EXTERN napi_status napi_run_script(napi_env env,                                         napi_value script,                                         napi_value* result);   [in] env: The environment that the API is invoked under. [in] script: A JavaScript string containing the script to execute. [out] result: The value resulting from having executed the script.  This function executes a string of JavaScript code and returns its result with the following caveats:  Unlike eval, this function does not allow the script to access the current lexical scope, and therefore also does not allow to access the module scope, meaning that pseudo-globals such as require will not be available. The script can access the global scope. Function and var declarations in the script will be added to the global object. Variable declarations made using let and const will be visible globally, but will not be added to the global object. The value of this is global within the script."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_libuv_event_loop","title":"libuv event loop","description":"N-API provides a function for getting the current event loop associated with a specific napi_env."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_uv_event_loop","title":"napi_get_uv_event_loop","description":"NAPI_EXTERN napi_status napi_get_uv_event_loop(napi_env env,                                                struct uv_loop_s** loop);   [in] env: The environment that the API is invoked under. [out] loop: The current libuv loop instance."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_asynchronous_thread_safe_function_calls","title":"Asynchronous thread-safe function calls","description":"JavaScript functions can normally only be called from a native addon's main thread. If an addon creates additional threads, then N-API functions that require a napi_env, napi_value, or napi_ref must not be called from those threads. When an addon has additional threads and JavaScript functions need to be invoked based on the processing completed by those threads, those threads must communicate with the addon's main thread so that the main thread can invoke the JavaScript function on their behalf. The thread-safe function APIs provide an easy way to do this. These APIs provide the type napi_threadsafe_function as well as APIs to create, destroy, and call objects of this type. napi_create_threadsafe_function() creates a persistent reference to a napi_value that holds a JavaScript function which can be called from multiple threads. The calls happen asynchronously. This means that values with which the JavaScript callback is to be called will be placed in a queue, and, for each value in the queue, a call will eventually be made to the JavaScript function. Upon creation of a napi_threadsafe_function a napi_finalize callback can be provided. This callback will be invoked on the main thread when the thread-safe function is about to be destroyed. It receives the context and the finalize data given during construction, and provides an opportunity for cleaning up after the threads e.g. by calling uv_thread_join(). Aside from the main loop thread, no threads should be using the thread-safe function after the finalize callback completes. The context given during the call to napi_create_threadsafe_function() can be retrieved from any thread with a call to napi_get_threadsafe_function_context()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_calling_a_thread_safe_function","title":"Calling a thread-safe function","description":"napi_call_threadsafe_function() can be used for initiating a call into JavaScript. napi_call_threadsafe_function() accepts a parameter which controls whether the API behaves blockingly. If set to napi_tsfn_nonblocking, the API behaves non-blockingly, returning napi_queue_full if the queue was full, preventing data from being successfully added to the queue. If set to napi_tsfn_blocking, the API blocks until space becomes available in the queue. napi_call_threadsafe_function() never blocks if the thread-safe function was created with a maximum queue size of 0. napi_call_threadsafe_function() should not be called with napi_tsfn_blocking from a JavaScript thread, because, if the queue is full, it may cause the JavaScript thread to deadlock. The actual call into JavaScript is controlled by the callback given via the call_js_cb parameter. call_js_cb is invoked on the main thread once for each value that was placed into the queue by a successful call to napi_call_threadsafe_function(). If such a callback is not given, a default callback will be used, and the resulting JavaScript call will have no arguments. The call_js_cb callback receives the JavaScript function to call as a napi_value in its parameters, as well as the void* context pointer used when creating the napi_threadsafe_function, and the next data pointer that was created by one of the secondary threads. The callback can then use an API such as napi_call_function() to call into JavaScript. The callback may also be invoked with env and call_js_cb both set to NULL to indicate that calls into JavaScript are no longer possible, while items remain in the queue that may need to be freed. This normally occurs when the Node.js process exits while there is a thread-safe function still active. It is not necessary to call into JavaScript via napi_make_callback() because N-API runs call_js_cb in a context appropriate for callbacks."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_reference_counting_of_thread_safe_functions","title":"Reference counting of thread-safe functions","description":"Threads can be added to and removed from a napi_threadsafe_function object during its existence. Thus, in addition to specifying an initial number of threads upon creation, napi_acquire_threadsafe_function can be called to indicate that a new thread will start making use of the thread-safe function. Similarly, napi_release_threadsafe_function can be called to indicate that an existing thread will stop making use of the thread-safe function. napi_threadsafe_function objects are destroyed when every thread which uses the object has called napi_release_threadsafe_function() or has received a return status of napi_closing in response to a call to napi_call_threadsafe_function. The queue is emptied before the napi_threadsafe_function is destroyed. napi_release_threadsafe_function() should be the last API call made in conjunction with a given napi_threadsafe_function, because after the call completes, there is no guarantee that the napi_threadsafe_function is still allocated. For the same reason, do not use a thread-safe function after receiving a return value of napi_closing in response to a call to napi_call_threadsafe_function. Data associated with the napi_threadsafe_function can be freed in its napi_finalize callback which was passed to napi_create_threadsafe_function(). The parameter initial_thread_count of napi_create_threadsafe_function marks the initial number of aquisitions of the thread-safe functions, instead of calling napi_acquire_threadsafe_function multiple times at creation. Once the number of threads making use of a napi_threadsafe_function reaches zero, no further threads can start making use of it by calling napi_acquire_threadsafe_function(). In fact, all subsequent API calls associated with it, except napi_release_threadsafe_function(), will return an error value of napi_closing. The thread-safe function can be \"aborted\" by giving a value of napi_tsfn_abort to napi_release_threadsafe_function(). This will cause all subsequent APIs associated with the thread-safe function except napi_release_threadsafe_function() to return napi_closing even before its reference count reaches zero. In particular, napi_call_threadsafe_function() will return napi_closing, thus informing the threads that it is no longer possible to make asynchronous calls to the thread-safe function. This can be used as a criterion for terminating the thread. Upon receiving a return value of napi_closing from napi_call_threadsafe_function() a thread must not use the thread-safe function anymore because it is no longer guaranteed to be allocated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_deciding_whether_to_keep_the_process_running","title":"Deciding whether to keep the process running","description":"Similarly to libuv handles, thread-safe functions can be \"referenced\" and \"unreferenced\". A \"referenced\" thread-safe function will cause the event loop on the thread on which it is created to remain alive until the thread-safe function is destroyed. In contrast, an \"unreferenced\" thread-safe function will not prevent the event loop from exiting. The APIs napi_ref_threadsafe_function and napi_unref_threadsafe_function exist for this purpose. Neither does napi_unref_threadsafe_function mark the thread-safe functions as able to be destroyed nor does napi_ref_threadsafe_function prevent it from being destroyed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_create_threadsafe_function","title":"napi_create_threadsafe_function","description":"NAPI_EXTERN napi_status napi_create_threadsafe_function(napi_env env,                                 napi_value func,                                 napi_value async_resource,                                 napi_value async_resource_name,                                 size_t max_queue_size,                                 size_t initial_thread_count,                                 void* thread_finalize_data,                                 napi_finalize thread_finalize_cb,                                 void* context,                                 napi_threadsafe_function_call_js call_js_cb,                                 napi_threadsafe_function* result);   [in] env: The environment that the API is invoked under. [in] func: An optional JavaScript function to call from another thread. It must be provided if NULL is passed to call_js_cb. [in] async_resource: An optional object associated with the async work that will be passed to possible async_hooks init hooks. [in] async_resource_name: A JavaScript string to provide an identifier for the kind of resource that is being provided for diagnostic information exposed by the async_hooks API. [in] max_queue_size: Maximum size of the queue. 0 for no limit. [in] initial_thread_count: The initial number of acquisitions, i.e. the initial number of threads, including the main thread, which will be making use of this function. [in] thread_finalize_data: Optional data to be passed to thread_finalize_cb. [in] thread_finalize_cb: Optional function to call when the napi_threadsafe_function is being destroyed. [in] context: Optional data to attach to the resulting napi_threadsafe_function. [in] call_js_cb: Optional callback which calls the JavaScript function in response to a call on a different thread. This callback will be called on the main thread. If not given, the JavaScript function will be called with no parameters and with undefined as its this value. napi_threadsafe_function_call_js provides more details. [out] result: The asynchronous thread-safe JavaScript function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_get_threadsafe_function_context","title":"napi_get_threadsafe_function_context","description":"NAPI_EXTERN napi_status napi_get_threadsafe_function_context(napi_threadsafe_function func,                                      void** result);   [in] func: The thread-safe function for which to retrieve the context. [out] result: The location where to store the context.  This API may be called from any thread which makes use of func."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_call_threadsafe_function","title":"napi_call_threadsafe_function","description":"NAPI_EXTERN napi_status napi_call_threadsafe_function(napi_threadsafe_function func,                               void* data,                               napi_threadsafe_function_call_mode is_blocking);   [in] func: The asynchronous thread-safe JavaScript function to invoke. [in] data: Data to send into JavaScript via the callback call_js_cb provided during the creation of the thread-safe JavaScript function. [in] is_blocking: Flag whose value can be either napi_tsfn_blocking to indicate that the call should block if the queue is full or napi_tsfn_nonblocking to indicate that the call should return immediately with a status of napi_queue_full whenever the queue is full.  This API should not be called with napi_tsfn_blocking from a JavaScript thread, because, if the queue is full, it may cause the JavaScript thread to deadlock. This API will return napi_closing if napi_release_threadsafe_function() was called with abort set to napi_tsfn_abort from any thread. The value is only added to the queue if the API returns napi_ok. This API may be called from any thread which makes use of func."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_acquire_threadsafe_function","title":"napi_acquire_threadsafe_function","description":"NAPI_EXTERN napi_status napi_acquire_threadsafe_function(napi_threadsafe_function func);   [in] func: The asynchronous thread-safe JavaScript function to start making use of.  A thread should call this API before passing func to any other thread-safe function APIs to indicate that it will be making use of func. This prevents func from being destroyed when all other threads have stopped making use of it. This API may be called from any thread which will start making use of func."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_release_threadsafe_function","title":"napi_release_threadsafe_function","description":"NAPI_EXTERN napi_status napi_release_threadsafe_function(napi_threadsafe_function func,                                  napi_threadsafe_function_release_mode mode);   [in] func: The asynchronous thread-safe JavaScript function whose reference count to decrement. [in] mode: Flag whose value can be either napi_tsfn_release to indicate that the current thread will make no further calls to the thread-safe function, or napi_tsfn_abort to indicate that in addition to the current thread, no other thread should make any further calls to the thread-safe function. If set to napi_tsfn_abort, further calls to napi_call_threadsafe_function() will return napi_closing, and no further values will be placed in the queue.  A thread should call this API when it stops making use of func. Passing func to any thread-safe APIs after having called this API has undefined results, as func may have been destroyed. This API may be called from any thread which will stop making use of func."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_ref_threadsafe_function","title":"napi_ref_threadsafe_function","description":"NAPI_EXTERN napi_status napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func);   [in] env: The environment that the API is invoked under. [in] func: The thread-safe function to reference.  This API is used to indicate that the event loop running on the main thread should not exit until func has been destroyed. Similar to uv_ref it is also idempotent. Neither does napi_unref_threadsafe_function mark the thread-safe functions as able to be destroyed nor does napi_ref_threadsafe_function prevent it from being destroyed. napi_acquire_threadsafe_function and napi_release_threadsafe_function are available for that purpose. This API may only be called from the main thread."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_unref_threadsafe_function","title":"napi_unref_threadsafe_function","description":"NAPI_EXTERN napi_status napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func);   [in] env: The environment that the API is invoked under. [in] func: The thread-safe function to unreference.  This API is used to indicate that the event loop running on the main thread may exit before func is destroyed. Similar to uv_unref it is also idempotent. This API may only be called from the main thread."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_command_line_options","title":"Command-line options","description":"Node.js comes with a variety of CLI options. These options expose built-in debugging, multiple ways to execute scripts, and other helpful runtime options. To view this documentation as a manual page in a terminal, run man node."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_synopsis","title":"Synopsis","description":"node [options] [V8 options] [script.js | -e \"script\" | -] [--] [arguments] node inspect [script.js | -e \"script\" | <host>:<port>] \u2026 node --v8-options Execute without arguments to start the REPL. For more info about node inspect, see the debugger documentation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_options","title":"Options","description":"All options, including V8 options, allow words to be separated by both dashes (-) or underscores (_). For example, --pending-deprecation is equivalent to --pending_deprecation. If an option that takes a single value (such as --max-http-header-size) is passed more than once, then the last passed value is used. Options from the command line take precedence over options passed through the NODE_OPTIONS environment variable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_","title":"`-`","description":"Alias for stdin. Analogous to the use of - in other command-line utilities, meaning that the script is read from stdin, and the rest of the options are passed to that script."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_","title":"`--`","description":"Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval\/print script is supplied prior to this, then the next argument is used as a script filename."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_abort_on_uncaught_exception","title":"`--abort-on-uncaught-exception`","description":"Aborting instead of exiting causes a core file to be generated for post-mortem analysis using a debugger (such as lldb, gdb, and mdb). If this flag is passed, the behavior can still be set to not abort through process.setUncaughtExceptionCaptureCallback() (and through usage of the domain module that uses it)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_completion_bash","title":"`--completion-bash`","description":"Print source-able bash completion script for Node.js. $ node --completion-bash > node_bash_completion $ source node_bash_completion"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_conditions_condition","title":"`--conditions=condition`","description":"Enable experimental support for custom conditional exports resolution conditions. Any number of custom string condition names are permitted. The default Node.js conditions of \"node\", \"default\", \"import\", and \"require\" will always apply as defined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cpu_prof","title":"`--cpu-prof`","description":"Starts the V8 CPU profiler on start up, and writes the CPU profile to disk before exit. If --cpu-prof-dir is not specified, the generated profile is placed in the current working directory. If --cpu-prof-name is not specified, the generated profile is named CPU.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.cpuprofile. $ node --cpu-prof index.js $ ls *.cpuprofile CPU.20190409.202950.15293.0.0.cpuprofile"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cpu_prof_dir","title":"`--cpu-prof-dir`","description":"Specify the directory where the CPU profiles generated by --cpu-prof will be placed. The default value is controlled by the --diagnostic-dir command-line option."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cpu_prof_interval","title":"`--cpu-prof-interval`","description":"Specify the sampling interval in microseconds for the CPU profiles generated by --cpu-prof. The default is 1000 microseconds."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cpu_prof_name","title":"`--cpu-prof-name`","description":"Specify the file name of the CPU profile generated by --cpu-prof."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_diagnostic_dir_directory","title":"`--diagnostic-dir=directory`","description":"Set the directory to which all diagnostic output files are written. Defaults to current working directory. Affects the default output directory of:  --cpu-prof-dir --heap-prof-dir --redirect-warnings"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_disable_proto_mode","title":"`--disable-proto=mode`","description":"Disable the Object.prototype.__proto__ property. If mode is delete, the property is removed entirely. If mode is throw, accesses to the property throw an exception with the code ERR_PROTO_ACCESS."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_disallow_code_generation_from_strings","title":"`--disallow-code-generation-from-strings`","description":"Make built-in language features like eval and new Function that generate code from strings throw an exception instead. This does not affect the Node.js vm module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_enable_fips","title":"`--enable-fips`","description":"Enable FIPS-compliant crypto at startup. (Requires Node.js to be built with .\/configure --openssl-fips.)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_enable_source_maps","title":"`--enable-source-maps`","description":"Enable experimental Source Map v3 support for stack traces. Currently, overriding Error.prepareStackTrace is ignored when the --enable-source-maps flag is set."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_abortcontroller","title":"`--experimental-abortcontroller`","description":"Experimental AbortController and AbortSignal support is enabled by default. Use of this command-line flag is no longer required."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_import_meta_resolve","title":"`--experimental-import-meta-resolve`","description":"Enable experimental import.meta.resolve() support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_json_modules","title":"`--experimental-json-modules`","description":"Enable experimental JSON support for the ES Module loader."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_loader_module","title":"`--experimental-loader=module`","description":"Specify the module of a custom experimental ECMAScript Module loader. module may be either a path to a file, or an ECMAScript Module name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_modules","title":"`--experimental-modules`","description":"Enable latest experimental modules features (deprecated)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_policy","title":"`--experimental-policy`","description":"Use the specified file as a security policy."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_repl_await","title":"`--experimental-repl-await`","description":"Enable experimental top-level await keyword support in REPL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_specifier_resolution_mode","title":"`--experimental-specifier-resolution=mode`","description":"Sets the resolution algorithm for resolving ES module specifiers. Valid options are explicit and node. The default is explicit, which requires providing the full path to a module. The node mode enables support for optional file extensions and the ability to import a directory that has an index file. See customizing ESM specifier resolution for example usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_vm_modules","title":"`--experimental-vm-modules`","description":"Enable experimental ES Module support in the vm module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_wasi_unstable_preview1","title":"`--experimental-wasi-unstable-preview1`","description":"Enable experimental WebAssembly System Interface (WASI) support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_wasm_modules","title":"`--experimental-wasm-modules`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_force_context_aware","title":"`--force-context-aware`","description":"Disable loading native addons that are not context-aware. Enable experimental WebAssembly module support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_force_fips","title":"`--force-fips`","description":"Force FIPS-compliant crypto on startup. (Cannot be disabled from script code.) (Same requirements as --enable-fips.)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_frozen_intrinsics","title":"`--frozen-intrinsics`","description":"Enable experimental frozen intrinsics like Array and Object. Support is currently only provided for the root context and no guarantees are currently provided that global.Array is indeed the default intrinsic reference. Code may break under this flag. --require runs prior to freezing intrinsics in order to allow polyfills to be added."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_heapsnapshot_near_heap_limit_max_count","title":"`--heapsnapshot-near-heap-limit=max_count`","description":"Writes a V8 heap snapshot to disk when the V8 heap usage is approaching the heap limit. count should be a non-negative integer (in which case Node.js will write no more than max_count snapshots to disk). When generating snapshots, garbage collection may be triggered and bring the heap usage down, therefore multiple snapshots may be written to disk before the Node.js instance finally runs out of memory. These heap snapshots can be compared to determine what objects are being allocated during the time consecutive snapshots are taken. It's not guaranteed that Node.js will write exactly max_count snapshots to disk, but it will try its best to generate at least one and up to max_count snapshots before the Node.js instance runs out of memory when max_count is greater than 0. Generating V8 snapshots takes time and memory (both memory managed by the V8 heap and native memory outside the V8 heap). The bigger the heap is, the more resources it needs. Node.js will adjust the V8 heap to accommondate the additional V8 heap memory overhead, and try its best to avoid using up all the memory avialable to the process. When the process uses more memory than the system deems appropriate, the process may be terminated abruptly by the system, depending on the system configuration. $ node --max-old-space-size=100 --heapsnapshot-near-heap-limit=3 index.js Wrote snapshot to Heap.20200430.100036.49580.0.001.heapsnapshot Wrote snapshot to Heap.20200430.100037.49580.0.002.heapsnapshot Wrote snapshot to Heap.20200430.100038.49580.0.003.heapsnapshot  <--- Last few GCs --->  [49580:0x110000000]     4826 ms: Mark-sweep 130.6 (147.8) -> 130.5 (147.8) MB, 27.4 \/ 0.0 ms  (average mu = 0.126, current mu = 0.034) allocation failure scavenge might not succeed [49580:0x110000000]     4845 ms: Mark-sweep 130.6 (147.8) -> 130.6 (147.8) MB, 18.8 \/ 0.0 ms  (average mu = 0.088, current mu = 0.031) allocation failure scavenge might not succeed   <--- JS stacktrace --->  FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory ...."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_heapsnapshot_signal_signal","title":"`--heapsnapshot-signal=signal`","description":"Enables a signal handler that causes the Node.js process to write a heap dump when the specified signal is received. signal must be a valid signal name. Disabled by default. $ node --heapsnapshot-signal=SIGUSR2 index.js & $ ps aux USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND node         1  5.5  6.1 787252 247004 ?       Ssl  16:43   0:02 node --heapsnapshot-signal=SIGUSR2 index.js $ kill -USR2 1 $ ls Heap.20190718.133405.15554.0.001.heapsnapshot"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_heap_prof","title":"`--heap-prof`","description":"Starts the V8 heap profiler on start up, and writes the heap profile to disk before exit. If --heap-prof-dir is not specified, the generated profile is placed in the current working directory. If --heap-prof-name is not specified, the generated profile is named Heap.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.heapprofile. $ node --heap-prof index.js $ ls *.heapprofile Heap.20190409.202950.15293.0.001.heapprofile"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_heap_prof_dir","title":"`--heap-prof-dir`","description":"Specify the directory where the heap profiles generated by --heap-prof will be placed. The default value is controlled by the --diagnostic-dir command-line option."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_heap_prof_interval","title":"`--heap-prof-interval`","description":"Specify the average sampling interval in bytes for the heap profiles generated by --heap-prof. The default is 512 * 1024 bytes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_heap_prof_name","title":"`--heap-prof-name`","description":"Specify the file name of the heap profile generated by --heap-prof."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_icu_data_dir_file","title":"`--icu-data-dir=file`","description":"Specify ICU data load path. (Overrides NODE_ICU_DATA.)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_input_type_type","title":"`--input-type=type`","description":"This configures Node.js to interpret string input as CommonJS or as an ES module. String input is input via --eval, --print, or STDIN. Valid values are \"commonjs\" and \"module\". The default is \"commonjs\"."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspect_brk_host_port","title":"`--inspect-brk[=[host:]port]`","description":"Activate inspector on host:port and break at start of user script. Default host:port is 127.0.0.1:9229."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspect_port_host_port","title":"`--inspect-port=[host:]port`","description":"Set the host:port to be used when the inspector is activated. Useful when activating the inspector by sending the SIGUSR1 signal. Default host is 127.0.0.1. See the security warning below regarding the host parameter usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspect_host_port","title":"`--inspect[=[host:]port]`","description":"Activate inspector on host:port. Default is 127.0.0.1:9229. V8 inspector integration allows tools such as Chrome DevTools and IDEs to debug and profile Node.js instances. The tools attach to Node.js instances via a tcp port and communicate using the Chrome DevTools Protocol."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_warning_binding_inspector_to_a_public_ip_port_combination_is_insecure","title":"Warning: binding inspector to a public IP:port combination is insecure","description":"Binding the inspector to a public IP (including 0.0.0.0) with an open port is insecure, as it allows external hosts to connect to the inspector and perform a remote code execution attack. If specifying a host, make sure that either:  The host is not accessible from public networks. A firewall disallows unwanted connections on the port.  More specifically, --inspect=0.0.0.0 is insecure if the port (9229 by default) is not firewall-protected. See the debugging security implications section for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspect_publish_uid_stderr_http","title":"`--inspect-publish-uid=stderr,http`","description":"Specify ways of the inspector web socket url exposure. By default inspector websocket url is available in stderr and under \/json\/list endpoint on http:\/\/host:port\/json\/list."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_insecure_http_parser","title":"`--insecure-http-parser`","description":"Use an insecure HTTP parser that accepts invalid HTTP headers. This may allow interoperability with non-conformant HTTP implementations. It may also allow request smuggling and other HTTP attacks that rely on invalid headers being accepted. Avoid using this option."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_jitless","title":"`--jitless`","description":"Disable runtime allocation of executable memory. This may be required on some platforms for security reasons. It can also reduce attack surface on other platforms, but the performance impact may be severe. This flag is inherited from V8 and is subject to change upstream. It may disappear in a non-semver-major release."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_max_http_header_size_size","title":"`--max-http-header-size=size`","description":"Specify the maximum size, in bytes, of HTTP headers. Defaults to 16KB."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_napi_modules","title":"`--napi-modules`","description":"This option is a no-op. It is kept for compatibility."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_deprecation","title":"`--no-deprecation`","description":"Silence deprecation warnings."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_force_async_hooks_checks","title":"`--no-force-async-hooks-checks`","description":"Disables runtime checks for async_hooks. These will still be enabled dynamically when async_hooks is enabled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_warnings","title":"`--no-warnings`","description":"Silence all process warnings (including deprecations)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_memory_debug","title":"`--node-memory-debug`","description":"Enable extra debug checks for memory leaks in Node.js internals. This is usually only useful for developers debugging Node.js itself."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_openssl_config_file","title":"`--openssl-config=file`","description":"Load an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with .\/configure --openssl-fips."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_pending_deprecation","title":"`--pending-deprecation`","description":"Emit pending deprecation warnings. Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the --pending-deprecation command-line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective \"early warning\" mechanism that developers may leverage to detect deprecated API usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_policy_integrity_sri","title":"`--policy-integrity=sri`","description":"Instructs Node.js to error prior to running any code if the policy does not have the specified integrity. It expects a Subresource Integrity string as a parameter."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_preserve_symlinks","title":"`--preserve-symlinks`","description":"Instructs the module loader to preserve symbolic links when resolving and caching modules. By default, when Node.js loads a module from a path that is symbolically linked to a different on-disk location, Node.js will dereference the link and use the actual on-disk \"real path\" of the module as both an identifier and as a root path to locate other dependency modules. In most cases, this default behavior is acceptable. However, when using symbolically linked peer dependencies, as illustrated in the example below, the default behavior causes an exception to be thrown if moduleA attempts to require moduleB as a peer dependency: {appDir}  \u251c\u2500\u2500 app  \u2502   \u251c\u2500\u2500 index.js  \u2502   \u2514\u2500\u2500 node_modules  \u2502       \u251c\u2500\u2500 moduleA -> {appDir}\/moduleA  \u2502       \u2514\u2500\u2500 moduleB  \u2502           \u251c\u2500\u2500 index.js  \u2502           \u2514\u2500\u2500 package.json  \u2514\u2500\u2500 moduleA      \u251c\u2500\u2500 index.js      \u2514\u2500\u2500 package.json  The --preserve-symlinks command-line flag instructs Node.js to use the symlink path for modules as opposed to the real path, allowing symbolically linked peer dependencies to be found. Note, however, that using --preserve-symlinks can have other side effects. Specifically, symbolically linked native modules can fail to load if those are linked from more than one location in the dependency tree (Node.js would see those as two separate modules and would attempt to load the module multiple times, causing an exception to be thrown). The --preserve-symlinks flag does not apply to the main module, which allows node --preserve-symlinks node_module\/.bin\/<foo> to work. To apply the same behavior for the main module, also use --preserve-symlinks-main."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_preserve_symlinks_main","title":"`--preserve-symlinks-main`","description":"Instructs the module loader to preserve symbolic links when resolving and caching the main module (require.main). This flag exists so that the main module can be opted-in to the same behavior that --preserve-symlinks gives to all other imports; they are separate flags, however, for backward compatibility with older Node.js versions. --preserve-symlinks-main does not imply --preserve-symlinks; use --preserve-symlinks-main in addition to --preserve-symlinks when it is not desirable to follow symlinks before resolving relative paths. See --preserve-symlinks for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_prof","title":"`--prof`","description":"Generate V8 profiler output."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_prof_process","title":"`--prof-process`","description":"Process V8 profiler output generated using the V8 option --prof."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_redirect_warnings_file","title":"`--redirect-warnings=file`","description":"Write process warnings to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead. The file name may be an absolute path. If it is not, the default directory it will be written to is controlled by the --diagnostic-dir command-line option."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_report_compact","title":"`--report-compact`","description":"Write reports in a compact format, single-line JSON, more easily consumable by log processing systems than the default multi-line format designed for human consumption."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_report_dir_directory_report_directory_directory","title":"`--report-dir=directory`, `report-directory=directory`","description":"Location at which the report will be generated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_report_filename_filename","title":"`--report-filename=filename`","description":"Name of the file to which the report will be written."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_report_on_fatalerror","title":"`--report-on-fatalerror`","description":"Enables the report to be triggered on fatal errors (internal errors within the Node.js runtime such as out of memory) that lead to termination of the application. Useful to inspect various diagnostic data elements such as heap, stack, event loop state, resource consumption etc. to reason about the fatal error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_report_on_signal","title":"`--report-on-signal`","description":"Enables report to be generated upon receiving the specified (or predefined) signal to the running Node.js process. The signal to trigger the report is specified through --report-signal."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_report_signal_signal","title":"`--report-signal=signal`","description":"Sets or resets the signal for report generation (not supported on Windows). Default signal is SIGUSR2."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_report_uncaught_exception","title":"`--report-uncaught-exception`","description":"Enables report to be generated on uncaught exceptions. Useful when inspecting the JavaScript stack in conjunction with native stack and other runtime environment data."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_throw_deprecation","title":"`--throw-deprecation`","description":"Throw errors for deprecations."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_title_title","title":"`--title=title`","description":"Set process.title on startup."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_cipher_list_list","title":"`--tls-cipher-list=list`","description":"Specify an alternative default TLS cipher list. Requires Node.js to be built with crypto support (default)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_keylog_file","title":"`--tls-keylog=file`","description":"Log TLS key material to a file. The key material is in NSS SSLKEYLOGFILE format and can be used by software (such as Wireshark) to decrypt the TLS traffic."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_max_v1_2","title":"`--tls-max-v1.2`","description":"Set tls.DEFAULT_MAX_VERSION to 'TLSv1.2'. Use to disable support for TLSv1.3."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_max_v1_3","title":"`--tls-max-v1.3`","description":"Set default tls.DEFAULT_MAX_VERSION to 'TLSv1.3'. Use to enable support for TLSv1.3."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_min_v1_0","title":"`--tls-min-v1.0`","description":"Set default tls.DEFAULT_MIN_VERSION to 'TLSv1'. Use for compatibility with old TLS clients or servers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_min_v1_1","title":"`--tls-min-v1.1`","description":"Set default tls.DEFAULT_MIN_VERSION to 'TLSv1.1'. Use for compatibility with old TLS clients or servers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_min_v1_2","title":"`--tls-min-v1.2`","description":"Set default tls.DEFAULT_MIN_VERSION to 'TLSv1.2'. This is the default for 12.x and later, but the option is supported for compatibility with older Node.js versions."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_min_v1_3","title":"`--tls-min-v1.3`","description":"Set default tls.DEFAULT_MIN_VERSION to 'TLSv1.3'. Use to disable support for TLSv1.2, which is not as secure as TLSv1.3."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_atomics_wait","title":"`--trace-atomics-wait`","description":"Print short summaries of calls to Atomics.wait() to stderr. The output could look like this: (node:15701) [Thread 0] Atomics.wait(&lt;address> + 0, 1, inf) started (node:15701) [Thread 0] Atomics.wait(&lt;address> + 0, 1, inf) did not wait because the values mismatched (node:15701) [Thread 0] Atomics.wait(&lt;address> + 0, 0, 10) started (node:15701) [Thread 0] Atomics.wait(&lt;address> + 0, 0, 10) timed out (node:15701) [Thread 0] Atomics.wait(&lt;address> + 4, 0, inf) started (node:15701) [Thread 1] Atomics.wait(&lt;address> + 4, -1, inf) started (node:15701) [Thread 0] Atomics.wait(&lt;address> + 4, 0, inf) was woken up by another thread (node:15701) [Thread 1] Atomics.wait(&lt;address> + 4, -1, inf) was woken up by another thread  The fields here correspond to:  The thread id as given by worker_threads.threadId The base address of the SharedArrayBuffer in question, as well as the byte offset corresponding to the index passed to Atomics.wait() The expected value that was passed to Atomics.wait() The timeout passed to Atomics.wait"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_deprecation","title":"`--trace-deprecation`","description":"Print stack traces for deprecations."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_event_categories","title":"`--trace-event-categories`","description":"A comma separated list of categories that should be traced when trace event tracing is enabled using --trace-events-enabled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_event_file_pattern","title":"`--trace-event-file-pattern`","description":"Template string specifying the filepath for the trace event data, it supports ${rotation} and ${pid}."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_events_enabled","title":"`--trace-events-enabled`","description":"Enables the collection of trace event tracing information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_exit","title":"`--trace-exit`","description":"Prints a stack trace whenever an environment is exited proactively, i.e. invoking process.exit()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_sigint","title":"`--trace-sigint`","description":"Prints a stack trace on SIGINT."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_sync_io","title":"`--trace-sync-io`","description":"Prints a stack trace whenever synchronous I\/O is detected after the first turn of the event loop."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_tls","title":"`--trace-tls`","description":"Prints TLS packet trace information to stderr. This can be used to debug TLS connection problems."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_uncaught","title":"`--trace-uncaught`","description":"Print stack traces for uncaught exceptions; usually, the stack trace associated with the creation of an Error is printed, whereas this makes Node.js also print the stack trace associated with throwing the value (which does not need to be an Error instance). Enabling this option may affect garbage collection behavior negatively."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_warnings","title":"`--trace-warnings`","description":"Print stack traces for process warnings (including deprecations)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_track_heap_objects","title":"`--track-heap-objects`","description":"Track heap object allocations for heap snapshots."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_unhandled_rejections_mode","title":"`--unhandled-rejections=mode`","description":"Using this flag allows to change what should happen when an unhandled rejection occurs. One of the following modes can be chosen:  throw: Emit unhandledRejection. If this hook is not set, raise the unhandled rejection as an uncaught exception. This is the default. strict: Raise the unhandled rejection as an uncaught exception. warn: Always trigger a warning, no matter if the unhandledRejection hook is set or not but do not print the deprecation warning. warn-with-error-code: Emit unhandledRejection. If this hook is not set, trigger a warning, and set the process exit code to 1. none: Silence all warnings."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_use_bundled_ca_use_openssl_ca","title":"`--use-bundled-ca`, `--use-openssl-ca`","description":"Use bundled Mozilla CA store as supplied by current Node.js version or use OpenSSL's default CA store. The default store is selectable at build-time. The bundled CA store, as supplied by Node.js, is a snapshot of Mozilla CA store that is fixed at release time. It is identical on all supported platforms. Using OpenSSL store allows for external modifications of the store. For most Linux and BSD distributions, this store is maintained by the distribution maintainers and system administrators. OpenSSL CA store location is dependent on configuration of the OpenSSL library but this can be altered at runtime using environment variables. See SSL_CERT_DIR and SSL_CERT_FILE."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_use_largepages_mode","title":"`--use-largepages=mode`","description":"Re-map the Node.js static code to large memory pages at startup. If supported on the target system, this will cause the Node.js static code to be moved onto 2 MiB pages instead of 4 KiB pages. The following values are valid for mode:  off: No mapping will be attempted. This is the default. on: If supported by the OS, mapping will be attempted. Failure to map will be ignored and a message will be printed to standard error. silent: If supported by the OS, mapping will be attempted. Failure to map will be ignored and will not be reported."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_options","title":"`--v8-options`","description":"Print V8 command-line options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_pool_size_num","title":"`--v8-pool-size=num`","description":"Set V8's thread pool size which will be used to allocate background jobs. If set to 0 then V8 will choose an appropriate size of the thread pool based on the number of online processors. If the value provided is larger than V8's maximum, then the largest value will be chosen."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zero_fill_buffers","title":"`--zero-fill-buffers`","description":"Automatically zero-fills all newly allocated Buffer and SlowBuffer instances."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_c_check","title":"`-c`, `--check`","description":"Syntax check the script without executing."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_e_eval_script","title":"`-e`, `--eval \"script\"`","description":"Evaluate the following argument as JavaScript. The modules which are predefined in the REPL can also be used in script. On Windows, using cmd.exe a single quote will not work correctly because it only recognizes double \" for quoting. In Powershell or Git bash, both ' and \" are usable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_h_help","title":"`-h`, `--help`","description":"Print node command-line options. The output of this option is less detailed than this document."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_i_interactive","title":"`-i`, `--interactive`","description":"Opens the REPL even if stdin does not appear to be a terminal."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_p_print_script","title":"`-p`, `--print \"script\"`","description":"Identical to -e but prints the result."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_r_require_module","title":"`-r`, `--require module`","description":"Preload the specified module at startup. Follows require()'s module resolution rules. module may be either a path to a file, or a node module name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v_version","title":"`-v`, `--version`","description":"Print node's version."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_environment_variables","title":"Environment variables","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_debug_module","title":"`NODE_DEBUG=module[,\u2026]`","description":"','-separated list of core modules that should print debug information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_debug_native_module","title":"`NODE_DEBUG_NATIVE=module[,\u2026]`","description":"','-separated list of core C++ modules that should print debug information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_disable_colors_1","title":"`NODE_DISABLE_COLORS=1`","description":"When set, colors will not be used in the REPL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_extra_ca_certs_file","title":"`NODE_EXTRA_CA_CERTS=file`","description":"When set, the well known \"root\" CAs (like VeriSign) will be extended with the extra certificates in file. The file should consist of one or more trusted certificates in PEM format. A message will be emitted (once) with process.emitWarning() if the file is missing or malformed, but any errors are otherwise ignored. Neither the well known nor extra certificates are used when the ca options property is explicitly specified for a TLS or HTTPS client or server. This environment variable is ignored when node runs as setuid root or has Linux file capabilities set."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_icu_data_file","title":"`NODE_ICU_DATA=file`","description":"Data path for ICU (Intl object) data. Will extend linked-in data when compiled with small-icu support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_no_warnings_1","title":"`NODE_NO_WARNINGS=1`","description":"When set to 1, process warnings are silenced."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_options_options","title":"`NODE_OPTIONS=options...`","description":"A space-separated list of command-line options. options... are interpreted before command-line options, so command-line options will override or compound after anything in options.... Node.js will exit with an error if an option that is not allowed in the environment is used, such as -p or a script file. If an option value contains a space, it can be escaped using double quotes: NODE_OPTIONS='--require \".\/my path\/file.js\"'  A singleton flag passed as a command-line option will override the same flag passed into NODE_OPTIONS: # The inspector will be available on port 5555 NODE_OPTIONS='--inspect=localhost:4444' node --inspect=localhost:5555  A flag that can be passed multiple times will be treated as if its NODE_OPTIONS instances were passed first, and then its command-line instances afterwards: NODE_OPTIONS='--require \".\/a.js\"' node --require \".\/b.js\" # is equivalent to: node --require \".\/a.js\" --require \".\/b.js\"  Node.js options that are allowed are:   --conditions --diagnostic-dir --disable-proto --enable-fips --enable-source-maps --experimental-abortcontroller --experimental-import-meta-resolve --experimental-json-modules --experimental-loader --experimental-modules --experimental-policy --experimental-repl-await --experimental-specifier-resolution --experimental-top-level-await --experimental-vm-modules --experimental-wasi-unstable-preview1 --experimental-wasm-modules --force-context-aware --force-fips --frozen-intrinsics --heapsnapshot-near-heap-limit --heapsnapshot-signal --http-parser --icu-data-dir --input-type --insecure-http-parser --inspect-brk --inspect-port, --debug-port --inspect-publish-uid --inspect --max-http-header-size --napi-modules --no-deprecation --no-force-async-hooks-checks --no-warnings --node-memory-debug --openssl-config --pending-deprecation --policy-integrity --preserve-symlinks-main --preserve-symlinks --prof-process --redirect-warnings --report-compact --report-dir, --report-directory --report-filename --report-on-fatalerror --report-on-signal --report-signal --report-uncaught-exception --require, -r --throw-deprecation --title --tls-cipher-list --tls-keylog --tls-max-v1.2 --tls-max-v1.3 --tls-min-v1.0 --tls-min-v1.1 --tls-min-v1.2 --tls-min-v1.3 --trace-atomics-wait --trace-deprecation --trace-event-categories --trace-event-file-pattern --trace-events-enabled --trace-exit --trace-sigint --trace-sync-io --trace-tls --trace-uncaught --trace-warnings --track-heap-objects --unhandled-rejections --use-bundled-ca --use-largepages --use-openssl-ca --v8-pool-size --zero-fill-buffers    V8 options that are allowed are:   --abort-on-uncaught-exception --disallow-code-generation-from-strings --huge-max-old-generation-size --interpreted-frames-native-stack --jitless --max-old-space-size --perf-basic-prof-only-functions --perf-basic-prof --perf-prof-unwinding-info --perf-prof --stack-trace-limit    --perf-basic-prof-only-functions, --perf-basic-prof, --perf-prof-unwinding-info, and --perf-prof are only available on Linux."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_path_path","title":"`NODE_PATH=path[:\u2026]`","description":"':'-separated list of directories prefixed to the module search path. On Windows, this is a ';'-separated list instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_pending_deprecation_1","title":"`NODE_PENDING_DEPRECATION=1`","description":"When set to 1, emit pending deprecation warnings. Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the --pending-deprecation command-line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective \"early warning\" mechanism that developers may leverage to detect deprecated API usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_pending_pipe_instances_instances","title":"`NODE_PENDING_PIPE_INSTANCES=instances`","description":"Set the number of pending pipe instance handles when the pipe server is waiting for connections. This setting applies to Windows only."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_preserve_symlinks_1","title":"`NODE_PRESERVE_SYMLINKS=1`","description":"When set to 1, instructs the module loader to preserve symbolic links when resolving and caching modules."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_redirect_warnings_file","title":"`NODE_REDIRECT_WARNINGS=file`","description":"When set, process warnings will be emitted to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead. This is equivalent to using the --redirect-warnings=file command-line flag."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_repl_history_file","title":"`NODE_REPL_HISTORY=file`","description":"Path to the file used to store the persistent REPL history. The default path is ~\/.node_repl_history, which is overridden by this variable. Setting the value to an empty string ('' or ' ') disables persistent REPL history."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_repl_external_module_file","title":"`NODE_REPL_EXTERNAL_MODULE=file`","description":"Path to a Node.js module which will be loaded in place of the built-in REPL. Overriding this value to an empty string ('') will use the built-in REPL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_skip_platform_check_value","title":"`NODE_SKIP_PLATFORM_CHECK=value`","description":"If value equals '1', the check for a supported platform is skipped during Node.js startup. Node.js might not execute correctly. Any issues encountered on unsupported platforms will not be fixed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_tls_reject_unauthorized_value","title":"`NODE_TLS_REJECT_UNAUTHORIZED=value`","description":"If value equals '0', certificate validation is disabled for TLS connections. This makes TLS, and HTTPS by extension, insecure. The use of this environment variable is strongly discouraged."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_v8_coverage_dir","title":"`NODE_V8_COVERAGE=dir`","description":"When set, Node.js will begin outputting V8 JavaScript code coverage and Source Map data to the directory provided as an argument (coverage information is written as JSON to files with a coverage prefix). NODE_V8_COVERAGE will automatically propagate to subprocesses, making it easier to instrument applications that call the child_process.spawn() family of functions. NODE_V8_COVERAGE can be set to an empty string, to prevent propagation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_coverage_output","title":"Coverage output","description":"Coverage is output as an array of ScriptCoverage objects on the top-level key result: {   \"result\": [     {       \"scriptId\": \"67\",       \"url\": \"internal\/tty.js\",       \"functions\": []     }   ] }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_source_map_cache","title":"Source map cache","description":"If found, source map data is appended to the top-level key source-map-cache on the JSON coverage object. source-map-cache is an object with keys representing the files source maps were extracted from, and values which include the raw source-map URL (in the key url), the parsed Source Map v3 information (in the key data), and the line lengths of the source file (in the key lineLengths). {   \"result\": [     {       \"scriptId\": \"68\",       \"url\": \"file:\/\/\/absolute\/path\/to\/source.js\",       \"functions\": []     }   ],   \"source-map-cache\": {     \"file:\/\/\/absolute\/path\/to\/source.js\": {       \"url\": \".\/path-to-map.json\",       \"data\": {         \"version\": 3,         \"sources\": [           \"file:\/\/\/absolute\/path\/to\/original.js\"         ],         \"names\": [           \"Foo\",           \"console\",           \"info\"         ],         \"mappings\": \"MAAMA,IACJC,YAAaC\",         \"sourceRoot\": \".\/\"       },       \"lineLengths\": [         13,         62,         38,         27       ]     }   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_openssl_conf_file","title":"`OPENSSL_CONF=file`","description":"Load an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with .\/configure --openssl-fips. If the --openssl-config command-line option is used, the environment variable is ignored."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_ssl_cert_dir_dir","title":"`SSL_CERT_DIR=dir`","description":"If --use-openssl-ca is enabled, this overrides and sets OpenSSL's directory containing trusted certificates. Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_ssl_cert_file_file","title":"`SSL_CERT_FILE=file`","description":"If --use-openssl-ca is enabled, this overrides and sets OpenSSL's file containing trusted certificates. Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_uv_threadpool_size_size","title":"`UV_THREADPOOL_SIZE=size`","description":"Set the number of threads used in libuv's threadpool to size threads. Asynchronous system APIs are used by Node.js whenever possible, but where they do not exist, libuv's threadpool is used to create asynchronous node APIs based on synchronous system APIs. Node.js APIs that use the threadpool are:  all fs APIs, other than the file watcher APIs and those that are explicitly synchronous asynchronous crypto APIs such as crypto.pbkdf2(), crypto.scrypt(), crypto.randomBytes(), crypto.randomFill(), crypto.generateKeyPair() dns.lookup() all zlib APIs, other than those that are explicitly synchronous  Because libuv's threadpool has a fixed size, it means that if for whatever reason any of these APIs takes a long time, other (seemingly unrelated) APIs that run in libuv's threadpool will experience degraded performance. In order to mitigate this issue, one potential solution is to increase the size of libuv's threadpool by setting the 'UV_THREADPOOL_SIZE' environment variable to a value greater than 4 (its current default value). For more information, see the libuv threadpool documentation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_useful_v8_options","title":"Useful V8 options","description":"V8 has its own set of CLI options. Any V8 CLI option that is provided to node will be passed on to V8 to handle. V8's options have no stability guarantee. The V8 team themselves don't consider them to be part of their formal API, and reserve the right to change them at any time. Likewise, they are not covered by the Node.js stability guarantees. Many of the V8 options are of interest only to V8 developers. Despite this, there is a small set of V8 options that are widely applicable to Node.js, and they are documented here:"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_max_old_space_size_size_in_megabytes","title":"`--max-old-space-size=SIZE` (in megabytes)","description":"Sets the max memory size of V8's old memory section. As memory consumption approaches the limit, V8 will spend more time on garbage collection in an effort to free unused memory. On a machine with 2GB of memory, consider setting this to 1536 (1.5GB) to leave some memory for other uses and avoid swapping. $ node --max-old-space-size=1536 index.js"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_debugger","title":"Debugger","description":"Node.js includes an out-of-process debugging utility accessible via a V8 Inspector and built-in debugging client. To use it, start Node.js with the inspect argument followed by the path to the script to debug; a prompt will be displayed indicating successful launch of the debugger: $ node inspect myscript.js < Debugger listening on ws:\/\/127.0.0.1:9229\/80e7a814-7cd3-49fb-921a-2e02228cd5ba < For help, see: https:\/\/nodejs.org\/en\/docs\/inspector < Debugger attached. Break on start in myscript.js:1 > 1 (function (exports, require, module, __filename, __dirname) { global.x = 5;   2 setTimeout(() => {   3   console.log('world'); debug>  The Node.js debugger client is not a full-featured debugger, but simple step and inspection are possible. Inserting the statement debugger; into the source code of a script will enable a breakpoint at that position in the code:  \/\/ myscript.js global.x = 5; setTimeout(() => {   debugger;   console.log('world'); }, 1000); console.log('hello');  Once the debugger is run, a breakpoint will occur at line 3: $ node inspect myscript.js < Debugger listening on ws:\/\/127.0.0.1:9229\/80e7a814-7cd3-49fb-921a-2e02228cd5ba < For help, see: https:\/\/nodejs.org\/en\/docs\/inspector < Debugger attached. Break on start in myscript.js:1 > 1 (function (exports, require, module, __filename, __dirname) { global.x = 5;   2 setTimeout(() => {   3   debugger; debug> cont < hello break in myscript.js:3   1 (function (exports, require, module, __filename, __dirname) { global.x = 5;   2 setTimeout(() => { > 3   debugger;   4   console.log('world');   5 }, 1000); debug> next break in myscript.js:4   2 setTimeout(() => {   3   debugger; > 4   console.log('world');   5 }, 1000);   6 console.log('hello'); debug> repl Press Ctrl + C to leave debug repl > x 5 > 2 + 2 4 debug> next < world break in myscript.js:5   3   debugger;   4   console.log('world'); > 5 }, 1000);   6 console.log('hello');   7 debug> .exit  The repl command allows code to be evaluated remotely. The next command steps to the next line. Type help to see what other commands are available. Pressing enter without typing a command will repeat the previous debugger command."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_watchers","title":"Watchers","description":"It is possible to watch expression and variable values while debugging. On every breakpoint, each expression from the watchers list will be evaluated in the current context and displayed immediately before the breakpoint's source code listing. To begin watching an expression, type watch('my_expression'). The command watchers will print the active watchers. To remove a watcher, type unwatch('my_expression')."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_command_reference","title":"Command reference","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stepping","title":"Stepping","description":"cont, c: Continue execution next, n: Step next step, s: Step in out, o: Step out pause: Pause running code (like pause button in Developer Tools)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_breakpoints","title":"Breakpoints","description":"setBreakpoint(), sb(): Set breakpoint on current line setBreakpoint(line), sb(line): Set breakpoint on specific line setBreakpoint('fn()'), sb(...): Set breakpoint on a first statement in functions body setBreakpoint('script.js', 1), sb(...): Set breakpoint on first line of script.js setBreakpoint('script.js', 1, 'num < 4'), sb(...): Set conditional breakpoint on first line of script.js that only breaks when num < 4 evaluates to true clearBreakpoint('script.js', 1), cb(...): Clear breakpoint in script.js on line 1  It is also possible to set a breakpoint in a file (module) that is not loaded yet: $ node inspect main.js < Debugger listening on ws:\/\/127.0.0.1:9229\/4e3db158-9791-4274-8909-914f7facf3bd < For help, see: https:\/\/nodejs.org\/en\/docs\/inspector < Debugger attached. Break on start in main.js:1 > 1 (function (exports, require, module, __filename, __dirname) { const mod = require('.\/mod.js');   2 mod.hello();   3 mod.hello(); debug> setBreakpoint('mod.js', 22) Warning: script 'mod.js' was not loaded yet. debug> c break in mod.js:22  20 \/\/ USE OR OTHER DEALINGS IN THE SOFTWARE.  21 >22 exports.hello = function() {  23   return 'hello from module';  24 }; debug>  It is also possible to set a conditional breakpoint that only breaks when a given expression evaluates to true: $ node inspect main.js < Debugger listening on ws:\/\/127.0.0.1:9229\/ce24daa8-3816-44d4-b8ab-8273c8a66d35 < For help, see: https:\/\/nodejs.org\/en\/docs\/inspector < Debugger attached. Break on start in main.js:7   5 }   6 > 7 addOne(10);   8 addOne(-1);   9 debug> setBreakpoint('main.js', 4, 'num < 0')   1 'use strict';   2   3 function addOne(num) { > 4   return num + 1;   5 }   6   7 addOne(10);   8 addOne(-1);   9 debug> cont break in main.js:4   2   3 function addOne(num) { > 4   return num + 1;   5 }   6 debug> exec('num') -1 debug>"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_information","title":"Information","description":"backtrace, bt: Print backtrace of current execution frame list(5): List scripts source code with 5 line context (5 lines before and after) watch(expr): Add expression to watch list unwatch(expr): Remove expression from watch list watchers: List all watchers and their values (automatically listed on each breakpoint) repl: Open debugger's repl for evaluation in debugging script's context exec expr: Execute an expression in debugging script's context"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_execution_control","title":"Execution control","description":"run: Run script (automatically runs on debugger's start) restart: Restart script kill: Kill script"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_various","title":"Various","description":"scripts: List all loaded scripts version: Display V8's version"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_advanced_usage","title":"Advanced usage","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_inspector_integration_for_node_js","title":"V8 inspector integration for Node.js","description":"V8 Inspector integration allows attaching Chrome DevTools to Node.js instances for debugging and profiling. It uses the Chrome DevTools Protocol. V8 Inspector can be enabled by passing the --inspect flag when starting a Node.js application. It is also possible to supply a custom port with that flag, e.g. --inspect=9222 will accept DevTools connections on port 9222. To break on the first line of the application code, pass the --inspect-brk flag instead of --inspect. $ node --inspect index.js Debugger listening on ws:\/\/127.0.0.1:9229\/dc9010dd-f8b8-4ac5-a510-c1a114ec7d29 For help, see: https:\/\/nodejs.org\/en\/docs\/inspector  (In the example above, the UUID dc9010dd-f8b8-4ac5-a510-c1a114ec7d29 at the end of the URL is generated on the fly, it varies in different debugging sessions.) If the Chrome browser is older than 66.0.3345.0, use inspector.html instead of js_app.html in the above URL. Chrome DevTools doesn't support debugging worker threads yet. ndb can be used to debug them."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_deprecated_apis","title":"Deprecated APIs","description":"Node.js APIs might be deprecated for any of the following reasons:  Use of the API is unsafe. An improved alternative API is available. Breaking changes to the API are expected in a future major release.  Node.js uses three kinds of Deprecations:  Documentation-only Runtime End-of-Life  A Documentation-only deprecation is one that is expressed only within the Node.js API docs. These generate no side-effects while running Node.js. Some Documentation-only deprecations trigger a runtime warning when launched with --pending-deprecation flag (or its alternative, NODE_PENDING_DEPRECATION=1 environment variable), similarly to Runtime deprecations below. Documentation-only deprecations that support that flag are explicitly labeled as such in the list of Deprecated APIs. A Runtime deprecation will, by default, generate a process warning that will be printed to stderr the first time the deprecated API is used. When the --throw-deprecation command-line flag is used, a Runtime deprecation will cause an error to be thrown. An End-of-Life deprecation is used when functionality is or will soon be removed from Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_revoking_deprecations","title":"Revoking deprecations","description":"Occasionally, the deprecation of an API might be reversed. In such situations, this document will be updated with information relevant to the decision. However, the deprecation identifier will not be modified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_list_of_deprecated_apis","title":"List of deprecated APIs","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0001_http_outgoingmessage_prototype_flush","title":"DEP0001: `http.OutgoingMessage.prototype.flush`","description":"Type: End-of-Life OutgoingMessage.prototype.flush() has been removed. Use OutgoingMessage.prototype.flushHeaders() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0002_require_linklist","title":"DEP0002: `require('_linklist')`","description":"Type: End-of-Life The _linklist module is deprecated. Please use a userland alternative."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0003_writablestate_buffer","title":"DEP0003: `_writableState.buffer`","description":"Type: End-of-Life The _writableState.buffer has been removed. Use _writableState.getBuffer() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0004_cryptostream_prototype_readystate","title":"DEP0004: `CryptoStream.prototype.readyState`","description":"Type: End-of-Life The CryptoStream.prototype.readyState property was removed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0005_buffer_constructor","title":"DEP0005: `Buffer()` constructor","description":"Type: Runtime (supports --pending-deprecation) The Buffer() function and new Buffer() constructor are deprecated due to API usability issues that can lead to accidental security issues. As an alternative, use one of the following methods of constructing Buffer objects:  Buffer.alloc(size[, fill[, encoding]]): Create a Buffer with initialized memory. Buffer.allocUnsafe(size): Create a Buffer with uninitialized memory. Buffer.allocUnsafeSlow(size): Create a Buffer with uninitialized memory. Buffer.from(array): Create a Buffer with a copy of array Buffer.from(arrayBuffer[, byteOffset[, length]]) - Create a Buffer that wraps the given arrayBuffer. Buffer.from(buffer): Create a Buffer that copies buffer. Buffer.from(string[, encoding]): Create a Buffer that copies string.  Without --pending-deprecation, runtime warnings occur only for code not in node_modules. This means there will not be deprecation warnings for Buffer() usage in dependencies. With --pending-deprecation, a runtime warning results no matter where the Buffer() usage occurs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0006_child_process_options_customfds","title":"DEP0006: `child_process` `options.customFds`","description":"Type: End-of-Life Within the child_process module's spawn(), fork(), and exec() methods, the options.customFds option is deprecated. The options.stdio option should be used instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0007_replace_cluster_worker_suicide_with_worker_exitedafterdisconnect","title":"DEP0007: Replace `cluster` `worker.suicide` with `worker.exitedAfterDisconnect`","description":"Type: End-of-Life In an earlier version of the Node.js cluster, a boolean property with the name suicide was added to the Worker object. The intent of this property was to provide an indication of how and why the Worker instance exited. In Node.js 6.0.0, the old property was deprecated and replaced with a new worker.exitedAfterDisconnect property. The old property name did not precisely describe the actual semantics and was unnecessarily emotion-laden."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0008_require_constants","title":"DEP0008: `require('constants')`","description":"Type: Documentation-only The constants module is deprecated. When requiring access to constants relevant to specific Node.js builtin modules, developers should instead refer to the constants property exposed by the relevant module. For instance, require('fs').constants and require('os').constants."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0009_crypto_pbkdf2_without_digest","title":"DEP0009: `crypto.pbkdf2` without digest","description":"Type: End-of-Life Use of the crypto.pbkdf2() API without specifying a digest was deprecated in Node.js 6.0 because the method defaulted to using the non-recommended 'SHA1' digest. Previously, a deprecation warning was printed. Starting in Node.js 8.0.0, calling crypto.pbkdf2() or crypto.pbkdf2Sync() with digest set to undefined will throw a TypeError. Beginning in Node.js v11.0.0, calling these functions with digest set to null would print a deprecation warning to align with the behavior when digest is undefined. Now, however, passing either undefined or null will throw a TypeError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0010_crypto_createcredentials","title":"DEP0010: `crypto.createCredentials`","description":"Type: End-of-Life The crypto.createCredentials() API was removed. Please use tls.createSecureContext() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0011_crypto_credentials","title":"DEP0011: `crypto.Credentials`","description":"Type: End-of-Life The crypto.Credentials class was removed. Please use tls.SecureContext instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0012_domain_dispose","title":"DEP0012: `Domain.dispose`","description":"Type: End-of-Life Domain.dispose() has been removed. Recover from failed I\/O actions explicitly via error event handlers set on the domain instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0013_fs_asynchronous_function_without_callback","title":"DEP0013: `fs` asynchronous function without callback","description":"Type: End-of-Life Calling an asynchronous function without a callback throws a TypeError in Node.js 10.0.0 onwards. See https:\/\/github.com\/nodejs\/node\/pull\/12562."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0014_fs_read_legacy_string_interface","title":"DEP0014: `fs.read` legacy String interface","description":"Type: End-of-Life The fs.read() legacy String interface is deprecated. Use the Buffer API as mentioned in the documentation instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0015_fs_readsync_legacy_string_interface","title":"DEP0015: `fs.readSync` legacy String interface","description":"Type: End-of-Life The fs.readSync() legacy String interface is deprecated. Use the Buffer API as mentioned in the documentation instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0016_global_root","title":"DEP0016: `GLOBAL`\/`root`","description":"Type: End-of-Life The GLOBAL and root aliases for the global property were deprecated in Node.js 6.0.0 and have since been removed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0017_intl_v8breakiterator","title":"DEP0017: `Intl.v8BreakIterator`","description":"Type: End-of-Life Intl.v8BreakIterator was a non-standard extension and has been removed. See Intl.Segmenter."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0018_unhandled_promise_rejections","title":"DEP0018: Unhandled promise rejections","description":"Type: End-of-Life Unhandled promise rejections are deprecated. By default, promise rejections that are not handled terminate the Node.js process with a non-zero exit code. To change the way Node.js treats unhandled rejections, use the --unhandled-rejections command-line option."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0019_require_resolved_outside_directory","title":"DEP0019: `require('.')` resolved outside directory","description":"Type: End-of-Life In certain cases, require('.') could resolve outside the package directory. This behavior has been removed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0020_server_connections","title":"DEP0020: `Server.connections`","description":"Type: End-of-Life The Server.connections property was deprecated in Node.js v0.9.7 and has been removed. Please use the Server.getConnections() method instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0021_server_listenfd","title":"DEP0021: `Server.listenFD`","description":"Type: End-of-Life The Server.listenFD() method was deprecated and removed. Please use Server.listen({fd: <number>}) instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0022_os_tmpdir","title":"DEP0022: `os.tmpDir()`","description":"Type: End-of-Life The os.tmpDir() API was deprecated in Node.js 7.0.0 and has since been removed. Please use os.tmpdir() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0023_os_getnetworkinterfaces","title":"DEP0023: `os.getNetworkInterfaces()`","description":"Type: End-of-Life The os.getNetworkInterfaces() method is deprecated. Please use the os.networkInterfaces() method instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0024_replserver_prototype_converttocontext","title":"DEP0024: `REPLServer.prototype.convertToContext()`","description":"Type: End-of-Life The REPLServer.prototype.convertToContext() API has been removed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0025_require_sys","title":"DEP0025: `require('sys')`","description":"Type: Runtime The sys module is deprecated. Please use the util module instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0026_util_print","title":"DEP0026: `util.print()`","description":"Type: End-of-Life util.print() has been removed. Please use console.log() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0027_util_puts","title":"DEP0027: `util.puts()`","description":"Type: End-of-Life util.puts() has been removed. Please use console.log() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0028_util_debug","title":"DEP0028: `util.debug()`","description":"Type: End-of-Life util.debug() has been removed. Please use console.error() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0029_util_error","title":"DEP0029: `util.error()`","description":"Type: End-of-Life util.error() has been removed. Please use console.error() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0030_slowbuffer","title":"DEP0030: `SlowBuffer`","description":"Type: Documentation-only The SlowBuffer class is deprecated. Please use Buffer.allocUnsafeSlow(size) instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0031_ecdh_setpublickey","title":"DEP0031: `ecdh.setPublicKey()`","description":"Type: Documentation-only The ecdh.setPublicKey() method is now deprecated as its inclusion in the API is not useful."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0032_domain_module","title":"DEP0032: `domain` module","description":"Type: Documentation-only The domain module is deprecated and should not be used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0033_eventemitter_listenercount","title":"DEP0033: `EventEmitter.listenerCount()`","description":"Type: Documentation-only The EventEmitter.listenerCount(emitter, eventName) API is deprecated. Please use emitter.listenerCount(eventName) instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0034_fs_exists_path_callback","title":"DEP0034: `fs.exists(path, callback)`","description":"Type: Documentation-only The fs.exists(path, callback) API is deprecated. Please use fs.stat() or fs.access() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0035_fs_lchmod_path_mode_callback","title":"DEP0035: `fs.lchmod(path, mode, callback)`","description":"Type: Documentation-only The fs.lchmod(path, mode, callback) API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0036_fs_lchmodsync_path_mode","title":"DEP0036: `fs.lchmodSync(path, mode)`","description":"Type: Documentation-only The fs.lchmodSync(path, mode) API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0037_fs_lchown_path_uid_gid_callback","title":"DEP0037: `fs.lchown(path, uid, gid, callback)`","description":"Type: Deprecation revoked The fs.lchown(path, uid, gid, callback) API was deprecated. The deprecation was revoked because the requisite supporting APIs were added in libuv."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0038_fs_lchownsync_path_uid_gid","title":"DEP0038: `fs.lchownSync(path, uid, gid)`","description":"Type: Deprecation revoked The fs.lchownSync(path, uid, gid) API was deprecated. The deprecation was revoked because the requisite supporting APIs were added in libuv."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0039_require_extensions","title":"DEP0039: `require.extensions`","description":"Type: Documentation-only The require.extensions property is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0040_punycode_module","title":"DEP0040: `punycode` module","description":"Type: Documentation-only The punycode module is deprecated. Please use a userland alternative instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0041_node_repl_history_file_environment_variable","title":"DEP0041: `NODE_REPL_HISTORY_FILE` environment variable","description":"Type: End-of-Life The NODE_REPL_HISTORY_FILE environment variable was removed. Please use NODE_REPL_HISTORY instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0042_tls_cryptostream","title":"DEP0042: `tls.CryptoStream`","description":"Type: End-of-Life The tls.CryptoStream class was removed. Please use tls.TLSSocket instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0043_tls_securepair","title":"DEP0043: `tls.SecurePair`","description":"Type: Documentation-only The tls.SecurePair class is deprecated. Please use tls.TLSSocket instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0044_util_isarray","title":"DEP0044: `util.isArray()`","description":"Type: Documentation-only The util.isArray() API is deprecated. Please use Array.isArray() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0045_util_isboolean","title":"DEP0045: `util.isBoolean()`","description":"Type: Documentation-only The util.isBoolean() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0046_util_isbuffer","title":"DEP0046: `util.isBuffer()`","description":"Type: Documentation-only The util.isBuffer() API is deprecated. Please use Buffer.isBuffer() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0047_util_isdate","title":"DEP0047: `util.isDate()`","description":"Type: Documentation-only The util.isDate() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0048_util_iserror","title":"DEP0048: `util.isError()`","description":"Type: Documentation-only The util.isError() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0049_util_isfunction","title":"DEP0049: `util.isFunction()`","description":"Type: Documentation-only The util.isFunction() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0050_util_isnull","title":"DEP0050: `util.isNull()`","description":"Type: Documentation-only The util.isNull() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0051_util_isnullorundefined","title":"DEP0051: `util.isNullOrUndefined()`","description":"Type: Documentation-only The util.isNullOrUndefined() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0052_util_isnumber","title":"DEP0052: `util.isNumber()`","description":"Type: Documentation-only The util.isNumber() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0053_util_isobject","title":"DEP0053: `util.isObject()`","description":"Type: Documentation-only The util.isObject() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0054_util_isprimitive","title":"DEP0054: `util.isPrimitive()`","description":"Type: Documentation-only The util.isPrimitive() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0055_util_isregexp","title":"DEP0055: `util.isRegExp()`","description":"Type: Documentation-only The util.isRegExp() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0056_util_isstring","title":"DEP0056: `util.isString()`","description":"Type: Documentation-only The util.isString() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0057_util_issymbol","title":"DEP0057: `util.isSymbol()`","description":"Type: Documentation-only The util.isSymbol() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0058_util_isundefined","title":"DEP0058: `util.isUndefined()`","description":"Type: Documentation-only The util.isUndefined() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0059_util_log","title":"DEP0059: `util.log()`","description":"Type: Documentation-only The util.log() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0060_util_extend","title":"DEP0060: `util._extend()`","description":"Type: Documentation-only The util._extend() API is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0061_fs_syncwritestream","title":"DEP0061: `fs.SyncWriteStream`","description":"Type: End-of-Life The fs.SyncWriteStream class was never intended to be a publicly accessible API and has been removed. No alternative API is available. Please use a userland alternative."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0062_node_debug","title":"DEP0062: `node --debug`","description":"Type: End-of-Life --debug activates the legacy V8 debugger interface, which was removed as of V8 5.8. It is replaced by Inspector which is activated with --inspect instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0063_serverresponse_prototype_writeheader","title":"DEP0063: `ServerResponse.prototype.writeHeader()`","description":"Type: Documentation-only The http module ServerResponse.prototype.writeHeader() API is deprecated. Please use ServerResponse.prototype.writeHead() instead. The ServerResponse.prototype.writeHeader() method was never documented as an officially supported API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0064_tls_createsecurepair","title":"DEP0064: `tls.createSecurePair()`","description":"Type: Runtime The tls.createSecurePair() API was deprecated in documentation in Node.js 0.11.3. Users should use tls.Socket instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0065_repl_repl_mode_magic_and_node_repl_mode_magic","title":"DEP0065: `repl.REPL_MODE_MAGIC` and `NODE_REPL_MODE=magic`","description":"Type: End-of-Life The repl module's REPL_MODE_MAGIC constant, used for replMode option, has been removed. Its behavior has been functionally identical to that of REPL_MODE_SLOPPY since Node.js 6.0.0, when V8 5.0 was imported. Please use REPL_MODE_SLOPPY instead. The NODE_REPL_MODE environment variable is used to set the underlying replMode of an interactive node session. Its value, magic, is also removed. Please use sloppy instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0066_outgoingmessage_prototype_headers_outgoingmessage_prototype_headernames","title":"DEP0066: `OutgoingMessage.prototype._headers, OutgoingMessage.prototype._headerNames`","description":"Type: Runtime The http module OutgoingMessage.prototype._headers and OutgoingMessage.prototype._headerNames properties are deprecated. Use one of the public methods (e.g. OutgoingMessage.prototype.getHeader(), OutgoingMessage.prototype.getHeaders(), OutgoingMessage.prototype.getHeaderNames(), OutgoingMessage.prototype.hasHeader(), OutgoingMessage.prototype.removeHeader(), OutgoingMessage.prototype.setHeader()) for working with outgoing headers. The OutgoingMessage.prototype._headers and OutgoingMessage.prototype._headerNames properties were never documented as officially supported properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0067_outgoingmessage_prototype_renderheaders","title":"DEP0067: `OutgoingMessage.prototype._renderHeaders`","description":"Type: Documentation-only The http module OutgoingMessage.prototype._renderHeaders() API is deprecated. The OutgoingMessage.prototype._renderHeaders property was never documented as an officially supported API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0068_node_debug","title":"DEP0068: `node debug`","description":"Type: End-of-Life node debug corresponds to the legacy CLI debugger which has been replaced with a V8-inspector based CLI debugger available through node inspect."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0069_vm_runindebugcontext_string","title":"DEP0069: `vm.runInDebugContext(string)`","description":"Type: End-of-Life DebugContext has been removed in V8 and is not available in Node.js 10+. DebugContext was an experimental API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0070_async_hooks_currentid","title":"DEP0070: `async_hooks.currentId()`","description":"Type: End-of-Life async_hooks.currentId() was renamed to async_hooks.executionAsyncId() for clarity. This change was made while async_hooks was an experimental API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0071_async_hooks_triggerid","title":"DEP0071: `async_hooks.triggerId()`","description":"Type: End-of-Life async_hooks.triggerId() was renamed to async_hooks.triggerAsyncId() for clarity. This change was made while async_hooks was an experimental API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0072_async_hooks_asyncresource_triggerid","title":"DEP0072: `async_hooks.AsyncResource.triggerId()`","description":"Type: End-of-Life async_hooks.AsyncResource.triggerId() was renamed to async_hooks.AsyncResource.triggerAsyncId() for clarity. This change was made while async_hooks was an experimental API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0073_several_internal_properties_of_net_server","title":"DEP0073: Several internal properties of `net.Server`","description":"Type: End-of-Life Accessing several internal, undocumented properties of net.Server instances with inappropriate names is deprecated. As the original API was undocumented and not generally useful for non-internal code, no replacement API is provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0074_replserver_bufferedcommand","title":"DEP0074: `REPLServer.bufferedCommand`","description":"Type: End-of-Life The REPLServer.bufferedCommand property was deprecated in favor of REPLServer.clearBufferedCommand()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0075_replserver_parsereplkeyword","title":"DEP0075: `REPLServer.parseREPLKeyword()`","description":"Type: End-of-Life REPLServer.parseREPLKeyword() was removed from userland visibility."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0076_tls_parsecertstring","title":"DEP0076: `tls.parseCertString()`","description":"Type: Runtime tls.parseCertString() is a trivial parsing helper that was made public by mistake. This function can usually be replaced with: const querystring = require('querystring'); querystring.parse(str, '\\n', '=');  This function is not completely equivalent to querystring.parse(). One difference is that querystring.parse() does url decoding: > querystring.parse('%E5%A5%BD=1', '\\n', '='); { '\u597d': '1' } > tls.parseCertString('%E5%A5%BD=1'); { '%E5%A5%BD': '1' }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0077_module_debug","title":"DEP0077: `Module._debug()`","description":"Type: Runtime Module._debug() is deprecated. The Module._debug() function was never documented as an officially supported API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0078_replserver_turnoffeditormode","title":"DEP0078: `REPLServer.turnOffEditorMode()`","description":"Type: End-of-Life REPLServer.turnOffEditorMode() was removed from userland visibility."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0079_custom_inspection_function_on_objects_via_inspect","title":"DEP0079: Custom inspection function on objects via `.inspect()`","description":"Type: End-of-Life Using a property named inspect on an object to specify a custom inspection function for util.inspect() is deprecated. Use util.inspect.custom instead. For backward compatibility with Node.js prior to version 6.4.0, both can be specified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0080_path_makelong","title":"DEP0080: `path._makeLong()`","description":"Type: Documentation-only The internal path._makeLong() was not intended for public use. However, userland modules have found it useful. The internal API is deprecated and replaced with an identical, public path.toNamespacedPath() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0081_fs_truncate_using_a_file_descriptor","title":"DEP0081: `fs.truncate()` using a file descriptor","description":"Type: Runtime fs.truncate() fs.truncateSync() usage with a file descriptor is deprecated. Please use fs.ftruncate() or fs.ftruncateSync() to work with file descriptors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0082_replserver_prototype_memory","title":"DEP0082: `REPLServer.prototype.memory()`","description":"Type: End-of-Life REPLServer.prototype.memory() is only necessary for the internal mechanics of the REPLServer itself. Do not use this function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0083_disabling_ecdh_by_setting_ecdhcurve_to_false","title":"DEP0083: Disabling ECDH by setting `ecdhCurve` to `false`","description":"Type: End-of-Life. The ecdhCurve option to tls.createSecureContext() and tls.TLSSocket could be set to false to disable ECDH entirely on the server only. This mode was deprecated in preparation for migrating to OpenSSL 1.1.0 and consistency with the client and is now unsupported. Use the ciphers parameter instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0084_requiring_bundled_internal_dependencies","title":"DEP0084: requiring bundled internal dependencies","description":"Type: End-of-Life Since Node.js versions 4.4.0 and 5.2.0, several modules only intended for internal usage were mistakenly exposed to user code through require(). These modules were:  v8\/tools\/codemap v8\/tools\/consarray v8\/tools\/csvparser v8\/tools\/logreader v8\/tools\/profile_view v8\/tools\/profile v8\/tools\/SourceMap v8\/tools\/splaytree v8\/tools\/tickprocessor-driver v8\/tools\/tickprocessor node-inspect\/lib\/_inspect (from 7.6.0) node-inspect\/lib\/internal\/inspect_client (from 7.6.0) node-inspect\/lib\/internal\/inspect_repl (from 7.6.0)  The v8\/* modules do not have any exports, and if not imported in a specific order would in fact throw errors. As such there are virtually no legitimate use cases for importing them through require(). On the other hand, node-inspect can be installed locally through a package manager, as it is published on the npm registry under the same name. No source code modification is necessary if that is done."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0085_asynchooks_sensitive_api","title":"DEP0085: AsyncHooks sensitive API","description":"Type: End-of-Life The AsyncHooks sensitive API was never documented and had various minor issues. Use the AsyncResource API instead. See https:\/\/github.com\/nodejs\/node\/issues\/15572."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0086_remove_runinasyncidscope","title":"DEP0086: Remove `runInAsyncIdScope`","description":"Type: End-of-Life runInAsyncIdScope doesn't emit the 'before' or 'after' event and can thus cause a lot of issues. See https:\/\/github.com\/nodejs\/node\/issues\/14328."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0089_require_assert","title":"DEP0089: `require('assert')`","description":"Type: Deprecation revoked Importing assert directly was not recommended as the exposed functions use loose equality checks. The deprecation was revoked because use of the assert module is not discouraged, and the deprecation caused developer confusion."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0090_invalid_gcm_authentication_tag_lengths","title":"DEP0090: Invalid GCM authentication tag lengths","description":"Type: End-of-Life Node.js used to support all GCM authentication tag lengths which are accepted by OpenSSL when calling decipher.setAuthTag(). Beginning with Node.js v11.0.0, only authentication tag lengths of 128, 120, 112, 104, 96, 64, and 32 bits are allowed. Authentication tags of other lengths are invalid per NIST SP 800-38D."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0091_crypto_default_encoding","title":"DEP0091: `crypto.DEFAULT_ENCODING`","description":"Type: Runtime The crypto.DEFAULT_ENCODING property is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0092_top_level_this_bound_to_module_exports","title":"DEP0092: Top-level `this` bound to `module.exports`","description":"Type: Documentation-only Assigning properties to the top-level this as an alternative to module.exports is deprecated. Developers should use exports or module.exports instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0093_crypto_fips_is_deprecated_and_replaced","title":"DEP0093: `crypto.fips` is deprecated and replaced.","description":"Type: Documentation-only The crypto.fips property is deprecated. Please use crypto.setFips() and crypto.getFips() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0094_using_assert_fail_with_more_than_one_argument","title":"DEP0094: Using `assert.fail()` with more than one argument.","description":"Type: Runtime Using assert.fail() with more than one argument is deprecated. Use assert.fail() with only one argument or use a different assert module method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0095_timers_enroll","title":"DEP0095: `timers.enroll()`","description":"Type: Runtime timers.enroll() is deprecated. Please use the publicly documented setTimeout() or setInterval() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0096_timers_unenroll","title":"DEP0096: `timers.unenroll()`","description":"Type: Runtime timers.unenroll() is deprecated. Please use the publicly documented clearTimeout() or clearInterval() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0097_makecallback_with_domain_property","title":"DEP0097: `MakeCallback` with `domain` property","description":"Type: Runtime Users of MakeCallback that add the domain property to carry context, should start using the async_context variant of MakeCallback or CallbackScope, or the high-level AsyncResource class."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0098_asynchooks_embedder_asyncresource_emitbefore_and_asyncresource_emitafter_apis","title":"DEP0098: AsyncHooks embedder `AsyncResource.emitBefore` and `AsyncResource.emitAfter` APIs","description":"Type: End-of-Life The embedded API provided by AsyncHooks exposes .emitBefore() and .emitAfter() methods which are very easy to use incorrectly which can lead to unrecoverable errors. Use asyncResource.runInAsyncScope() API instead which provides a much safer, and more convenient, alternative. See https:\/\/github.com\/nodejs\/node\/pull\/18513."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0099_async_context_unaware_node_makecallback_c_apis","title":"DEP0099: Async context-unaware `node::MakeCallback` C++ APIs","description":"Type: Compile-time Certain versions of node::MakeCallback APIs available to native modules are deprecated. Please use the versions of the API that accept an async_context parameter."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0100_process_assert","title":"DEP0100: `process.assert()`","description":"Type: Runtime process.assert() is deprecated. Please use the assert module instead. This was never a documented feature."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0101_with_lttng","title":"DEP0101: `--with-lttng`","description":"Type: End-of-Life The --with-lttng compile-time option has been removed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0102_using_noassert_in_buffer_read_write_operations","title":"DEP0102: Using `noAssert` in `Buffer#(read|write)` operations.","description":"Type: End-of-Life Using the noAssert argument has no functionality anymore. All input is going to be verified, no matter if it is set to true or not. Skipping the verification could lead to hard to find errors and crashes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0103_process_binding_util_is_typechecks","title":"DEP0103: `process.binding('util').is[...]` typechecks","description":"Type: Documentation-only (supports --pending-deprecation) Using process.binding() in general should be avoided. The type checking methods in particular can be replaced by using util.types. This deprecation has been superseded by the deprecation of the process.binding() API (DEP0111)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0104_process_env_string_coercion","title":"DEP0104: `process.env` string coercion","description":"Type: Documentation-only (supports --pending-deprecation) When assigning a non-string property to process.env, the assigned value is implicitly converted to a string. This behavior is deprecated if the assigned value is not a string, boolean, or number. In the future, such assignment might result in a thrown error. Please convert the property to a string before assigning it to process.env."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0105_decipher_finaltol","title":"DEP0105: `decipher.finaltol`","description":"Type: End-of-Life decipher.finaltol() has never been documented and was an alias for decipher.final(). This API has been removed, and it is recommended to use decipher.final() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0106_crypto_createcipher_and_crypto_createdecipher","title":"DEP0106: `crypto.createCipher` and `crypto.createDecipher`","description":"Type: Runtime Using crypto.createCipher() and crypto.createDecipher() should be avoided as they use a weak key derivation function (MD5 with no salt) and static initialization vectors. It is recommended to derive a key using crypto.pbkdf2() or crypto.scrypt() and to use crypto.createCipheriv() and crypto.createDecipheriv() to obtain the Cipher and Decipher objects respectively."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0107_tls_convertnpnprotocols","title":"DEP0107: `tls.convertNPNProtocols()`","description":"Type: End-of-Life This was an undocumented helper function not intended for use outside Node.js core and obsoleted by the removal of NPN (Next Protocol Negotiation) support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0108_zlib_bytesread","title":"DEP0108: `zlib.bytesRead`","description":"Type: Runtime Deprecated alias for zlib.bytesWritten. This original name was chosen because it also made sense to interpret the value as the number of bytes read by the engine, but is inconsistent with other streams in Node.js that expose values under these names."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0109_http_https_and_tls_support_for_invalid_urls","title":"DEP0109: `http`, `https`, and `tls` support for invalid URLs","description":"Type: Runtime Some previously supported (but strictly invalid) URLs were accepted through the http.request(), http.get(), https.request(), https.get(), and tls.checkServerIdentity() APIs because those were accepted by the legacy url.parse() API. The mentioned APIs now use the WHATWG URL parser that requires strictly valid URLs. Passing an invalid URL is deprecated and support will be removed in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0110_vm_script_cached_data","title":"DEP0110: `vm.Script` cached data","description":"Type: Documentation-only The produceCachedData option is deprecated. Use script.createCachedData() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0111_process_binding","title":"DEP0111: `process.binding()`","description":"Type: Documentation-only (supports --pending-deprecation) process.binding() is for use by Node.js internal code only."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0112_dgram_private_apis","title":"DEP0112: `dgram` private APIs","description":"Type: Runtime The dgram module previously contained several APIs that were never meant to accessed outside of Node.js core: Socket.prototype._handle, Socket.prototype._receiving, Socket.prototype._bindState, Socket.prototype._queue, Socket.prototype._reuseAddr, Socket.prototype._healthCheck(), Socket.prototype._stopReceiving(), and dgram._createSocketHandle()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0113_cipher_setauthtag_decipher_getauthtag","title":"DEP0113: `Cipher.setAuthTag()`, `Decipher.getAuthTag()`","description":"Type: End-of-Life Cipher.setAuthTag() and Decipher.getAuthTag() are no longer available. They were never documented and would throw when called."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0114_crypto_tobuf","title":"DEP0114: `crypto._toBuf()`","description":"Type: End-of-Life The crypto._toBuf() function was not designed to be used by modules outside of Node.js core and was removed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0115_crypto_prng_crypto_pseudorandombytes_crypto_rng","title":"DEP0115: `crypto.prng()`, `crypto.pseudoRandomBytes()`, `crypto.rng()`","description":"Type: Documentation-only (supports --pending-deprecation) In recent versions of Node.js, there is no difference between crypto.randomBytes() and crypto.pseudoRandomBytes(). The latter is deprecated along with the undocumented aliases crypto.prng() and crypto.rng() in favor of crypto.randomBytes() and might be removed in a future release."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0116_legacy_url_api","title":"DEP0116: Legacy URL API","description":"Type: Documentation-only The Legacy URL API is deprecated. This includes url.format(), url.parse(), url.resolve(), and the legacy urlObject. Please use the WHATWG URL API instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0117_native_crypto_handles","title":"DEP0117: Native crypto handles","description":"Type: End-of-Life Previous versions of Node.js exposed handles to internal native objects through the _handle property of the Cipher, Decipher, DiffieHellman, DiffieHellmanGroup, ECDH, Hash, Hmac, Sign, and Verify classes. The _handle property has been removed because improper use of the native object can lead to crashing the application."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0118_dns_lookup_support_for_a_falsy_host_name","title":"DEP0118: `dns.lookup()` support for a falsy host name","description":"Type: Runtime Previous versions of Node.js supported dns.lookup() with a falsy host name like dns.lookup(false) due to backward compatibility. This behavior is undocumented and is thought to be unused in real world apps. It will become an error in future versions of Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0119_process_binding_uv_errname_private_api","title":"DEP0119: `process.binding('uv').errname()` private API","description":"Type: Documentation-only (supports --pending-deprecation) process.binding('uv').errname() is deprecated. Please use util.getSystemErrorName() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0120_windows_performance_counter_support","title":"DEP0120: Windows Performance Counter support","description":"Type: End-of-Life Windows Performance Counter support has been removed from Node.js. The undocumented COUNTER_NET_SERVER_CONNECTION(), COUNTER_NET_SERVER_CONNECTION_CLOSE(), COUNTER_HTTP_SERVER_REQUEST(), COUNTER_HTTP_SERVER_RESPONSE(), COUNTER_HTTP_CLIENT_REQUEST(), and COUNTER_HTTP_CLIENT_RESPONSE() functions have been deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0121_net_setsimultaneousaccepts","title":"DEP0121: `net._setSimultaneousAccepts()`","description":"Type: Runtime The undocumented net._setSimultaneousAccepts() function was originally intended for debugging and performance tuning when using the child_process and cluster modules on Windows. The function is not generally useful and is being removed. See discussion here: https:\/\/github.com\/nodejs\/node\/issues\/18391"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0122_tls_server_prototype_setoptions","title":"DEP0122: `tls` `Server.prototype.setOptions()`","description":"Type: Runtime Please use Server.prototype.setSecureContext() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0123_setting_the_tls_servername_to_an_ip_address","title":"DEP0123: setting the TLS ServerName to an IP address","description":"Type: Runtime Setting the TLS ServerName to an IP address is not permitted by RFC 6066. This will be ignored in a future version."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0124_using_replserver_rli","title":"DEP0124: using `REPLServer.rli`","description":"Type: End-of-Life This property is a reference to the instance itself."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0125_require_stream_wrap","title":"DEP0125: `require('_stream_wrap')`","description":"Type: Runtime The _stream_wrap module is deprecated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0126_timers_active","title":"DEP0126: `timers.active()`","description":"Type: Runtime The previously undocumented timers.active() is deprecated. Please use the publicly documented timeout.refresh() instead. If re-referencing the timeout is necessary, timeout.ref() can be used with no performance impact since Node.js 10."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0127_timers_unrefactive","title":"DEP0127: `timers._unrefActive()`","description":"Type: Runtime The previously undocumented and \"private\" timers._unrefActive() is deprecated. Please use the publicly documented timeout.refresh() instead. If unreferencing the timeout is necessary, timeout.unref() can be used with no performance impact since Node.js 10."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0128_modules_with_an_invalid_main_entry_and_an_index_js_file","title":"DEP0128: modules with an invalid `main` entry and an `index.js` file","description":"Type: Documentation-only (supports --pending-deprecation) Modules that have an invalid main entry (e.g., .\/does-not-exist.js) and also have an index.js file in the top level directory will resolve the index.js file. That is deprecated and is going to throw an error in future Node.js versions."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0129_childprocess_channel","title":"DEP0129: `ChildProcess._channel`","description":"Type: Runtime The _channel property of child process objects returned by spawn() and similar functions is not intended for public use. Use ChildProcess.channel instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0130_module_createrequirefrompath","title":"DEP0130: `Module.createRequireFromPath()`","description":"Type: Runtime Module.createRequireFromPath() is deprecated. Please use module.createRequire() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0131_legacy_http_parser","title":"DEP0131: Legacy HTTP parser","description":"Type: End-of-Life The legacy HTTP parser, used by default in versions of Node.js prior to 12.0.0, is deprecated and has been removed in v13.0.0. Prior to v13.0.0, the --http-parser=legacy command-line flag could be used to revert to using the legacy parser."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0132_worker_terminate_with_callback","title":"DEP0132: `worker.terminate()` with callback","description":"Type: Runtime Passing a callback to worker.terminate() is deprecated. Use the returned Promise instead, or a listener to the worker\u2019s 'exit' event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0133_http_connection","title":"DEP0133: `http` `connection`","description":"Type: Documentation-only Prefer response.socket over response.connection and request.socket over request.connection."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0134_process_tickcallback","title":"DEP0134: `process._tickCallback`","description":"Type: Documentation-only (supports --pending-deprecation) The process._tickCallback property was never documented as an officially supported API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0135_writestream_open_and_readstream_open_are_internal","title":"DEP0135: `WriteStream.open()` and `ReadStream.open()` are internal","description":"Type: Runtime WriteStream.open() and ReadStream.open() are undocumented internal APIs that do not make sense to use in userland. File streams should always be opened through their corresponding factory methods fs.createWriteStream() and fs.createReadStream()) or by passing a file descriptor in options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0136_http_finished","title":"DEP0136: `http` `finished`","description":"Type: Documentation-only response.finished indicates whether response.end() has been called, not whether 'finish' has been emitted and the underlying data is flushed. Use response.writableFinished or response.writableEnded accordingly instead to avoid the ambigiuty. To maintain existing behaviour response.finished should be replaced with response.writableEnded."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0137_closing_fs_filehandle_on_garbage_collection","title":"DEP0137: Closing fs.FileHandle on garbage collection","description":"Type: Runtime Allowing a fs.FileHandle object to be closed on garbage collection is deprecated. In the future, doing so might result in a thrown error that will terminate the process. Please ensure that all fs.FileHandle objects are explicitly closed using FileHandle.prototype.close() when the fs.FileHandle is no longer needed: const fsPromises = require('fs').promises; async function openAndClose() {   let filehandle;   try {     filehandle = await fsPromises.open('thefile.txt', 'r');   } finally {     if (filehandle !== undefined)       await filehandle.close();   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0138_process_mainmodule","title":"DEP0138: `process.mainModule`","description":"Type: Documentation-only process.mainModule is a CommonJS-only feature while process global object is shared with non-CommonJS environment. Its use within ECMAScript modules is unsupported. It is deprecated in favor of require.main, because it serves the same purpose and is only available on CommonJS environment."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0139_process_umask_with_no_arguments","title":"DEP0139: `process.umask()` with no arguments","description":"Type: Documentation-only Calling process.umask() with no argument causes the process-wide umask to be written twice. This introduces a race condition between threads, and is a potential security vulnerability. There is no safe, cross-platform alternative API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0140_use_request_destroy_instead_of_request_abort","title":"DEP0140: Use `request.destroy()` instead of `request.abort()`","description":"Type: Documentation-only Use request.destroy() instead of request.abort()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0141_repl_inputstream_and_repl_outputstream","title":"DEP0141: `repl.inputStream` and `repl.outputStream`","description":"Type: Documentation-only (supports --pending-deprecation) The repl module exported the input and output stream twice. Use .input instead of .inputStream and .output instead of .outputStream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0142_repl_builtinlibs","title":"DEP0142: `repl._builtinLibs`","description":"Type: Documentation-only The repl module exports a _builtinLibs property that contains an array with native modules. It was incomplete so far and instead it's better to rely upon require('module').builtinModules."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0143_transform_transformstate","title":"DEP0143: `Transform._transformState`","description":"Type: Runtime Transform._transformState will be removed in future versions where it is no longer required due to simplification of the implementation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0144_module_parent","title":"DEP0144: `module.parent`","description":"Type: Documentation-only (supports --pending-deprecation) A CommonJS module can access the first module that required it using module.parent. This feature is deprecated because it does not work consistently in the presence of ECMAScript modules and because it gives an inaccurate representation of the CommonJS module graph. Some modules use it to check if they are the entry point of the current process. Instead, it is recommended to compare require.main and module: if (require.main === module) {   \/\/ Code section that will run only if current file is the entry point. }  When looking for the CommonJS modules that have required the current one, require.cache and module.children can be used: const moduleParents = Object.values(require.cache)   .filter((m) => m.children.includes(module));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0145_socket_buffersize","title":"DEP0145: `socket.bufferSize`","description":"Type: Documentation-only socket.bufferSize is just an alias for writable.writableLength."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0146_new_crypto_certificate","title":"DEP0146: `new crypto.Certificate()`","description":"Type: Documentation-only The crypto.Certificate() constructor is deprecated. Use static methods of crypto.Certificate() instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0147_fs_rmdir_path_recursive_true","title":"DEP0147: `fs.rmdir(path, { recursive: true })`","description":"Type: Runtime In future versions of Node.js, fs.rmdir(path, { recursive: true }) will throw if path does not exist or is a file. Use fs.rm(path, { recursive: true, force: true }) instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dep0148_folder_mappings_in_exports_trailing","title":"DEP0148: Folder mappings in `\"exports\"` (trailing `\"\/\"`)","description":"Type: Runtime (supports --pending-deprecation) Prior to subpath patterns support, it was possible to define subpath folder mappings in the subpath exports or subpath imports fields using a trailing \"\/\". Without --pending-deprecation, runtime warnings occur only for exports resolutions not in node_modules. This means there will not be deprecation warnings for \"exports\" in dependencies. With --pending-deprecation, a runtime warning results no matter where the \"exports\" usage occurs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_errors","title":"Errors","description":"Applications running in Node.js will generally experience four categories of errors:  Standard JavaScript errors such as <EvalError>, <SyntaxError>, <RangeError>, <ReferenceError>, <TypeError>, and <URIError>. System errors triggered by underlying operating system constraints such as attempting to open a file that does not exist or attempting to send data over a closed socket. User-specified errors triggered by application code. AssertionErrors are a special class of error that can be triggered when Node.js detects an exceptional logic violation that should never occur. These are raised typically by the assert module.  All JavaScript and system errors raised by Node.js inherit from, or are instances of, the standard JavaScript <Error> class and are guaranteed to provide at least the properties available on that class."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_propagation_and_interception","title":"Error propagation and interception","description":"Node.js supports several mechanisms for propagating and handling errors that occur while an application is running. How these errors are reported and handled depends entirely on the type of Error and the style of the API that is called. All JavaScript errors are handled as exceptions that immediately generate and throw an error using the standard JavaScript throw mechanism. These are handled using the try\u2026catch construct provided by the JavaScript language. \/\/ Throws with a ReferenceError because z is not defined. try {   const m = 1;   const n = m + z; } catch (err) {   \/\/ Handle the error here. }  Any use of the JavaScript throw mechanism will raise an exception that must be handled using try\u2026catch or the Node.js process will exit immediately. With few exceptions, Synchronous APIs (any blocking method that does not accept a callback function, such as fs.readFileSync), will use throw to report errors. Errors that occur within Asynchronous APIs may be reported in multiple ways:  Most asynchronous methods that accept a callback function will accept an Error object passed as the first argument to that function. If that first argument is not null and is an instance of Error, then an error occurred that should be handled.   const fs = require('fs'); fs.readFile('a file that does not exist', (err, data) => {   if (err) {     console.error('There was an error reading the file!', err);     return;   }   \/\/ Otherwise handle the data });    When an asynchronous method is called on an object that is an EventEmitter, errors can be routed to that object's 'error' event. const net = require('net'); const connection = net.connect('localhost');  \/\/ Adding an 'error' event handler to a stream: connection.on('error', (err) => {   \/\/ If the connection is reset by the server, or if it can't   \/\/ connect at all, or on any sort of error encountered by   \/\/ the connection, the error will be sent here.   console.error(err); });  connection.pipe(process.stdout);    A handful of typically asynchronous methods in the Node.js API may still use the throw mechanism to raise exceptions that must be handled using try\u2026catch. There is no comprehensive list of such methods; please refer to the documentation of each method to determine the appropriate error handling mechanism required.   The use of the 'error' event mechanism is most common for stream-based and event emitter-based APIs, which themselves represent a series of asynchronous operations over time (as opposed to a single operation that may pass or fail). For all EventEmitter objects, if an 'error' event handler is not provided, the error will be thrown, causing the Node.js process to report an uncaught exception and crash unless either: The domain module is used appropriately or a handler has been registered for the 'uncaughtException' event. const EventEmitter = require('events'); const ee = new EventEmitter();  setImmediate(() => {   \/\/ This will crash the process because no 'error' event   \/\/ handler has been added.   ee.emit('error', new Error('This will crash')); });  Errors generated in this way cannot be intercepted using try\u2026catch as they are thrown after the calling code has already exited. Developers must refer to the documentation for each method to determine exactly how errors raised by those methods are propagated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_first_callbacks","title":"Error-first callbacks","description":"Most asynchronous methods exposed by the Node.js core API follow an idiomatic pattern referred to as an error-first callback. With this pattern, a callback function is passed to the method as an argument. When the operation either completes or an error is raised, the callback function is called with the Error object (if any) passed as the first argument. If no error was raised, the first argument will be passed as null. const fs = require('fs');  function errorFirstCallback(err, data) {   if (err) {     console.error('There was an error', err);     return;   }   console.log(data); }  fs.readFile('\/some\/file\/that\/does-not-exist', errorFirstCallback); fs.readFile('\/some\/file\/that\/does-exist', errorFirstCallback);  The JavaScript try\u2026catch mechanism cannot be used to intercept errors generated by asynchronous APIs. A common mistake for beginners is to try to use throw inside an error-first callback: \/\/ THIS WILL NOT WORK: const fs = require('fs');  try {   fs.readFile('\/some\/file\/that\/does-not-exist', (err, data) => {     \/\/ Mistaken assumption: throwing here...     if (err) {       throw err;     }   }); } catch (err) {   \/\/ This will not catch the throw!   console.error(err); }  This will not work because the callback function passed to fs.readFile() is called asynchronously. By the time the callback has been called, the surrounding code, including the try\u2026catch block, will have already exited. Throwing an error inside the callback can crash the Node.js process in most cases. If domains are enabled, or a handler has been registered with process.on('uncaughtException'), such errors can be intercepted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exceptions_vs_errors","title":"Exceptions vs. errors","description":"A JavaScript exception is a value that is thrown as a result of an invalid operation or as the target of a throw statement. While it is not required that these values are instances of Error or classes which inherit from Error, all exceptions thrown by Node.js or the JavaScript runtime will be instances of Error. Some exceptions are unrecoverable at the JavaScript layer. Such exceptions will always cause the Node.js process to crash. Examples include assert() checks or abort() calls in the C++ layer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_openssl_errors","title":"OpenSSL errors","description":"Errors originating in crypto or tls are of class Error, and in addition to the standard .code and .message properties, may have some additional OpenSSL-specific properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_js_error_codes","title":"Node.js error codes","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_ambiguous_argument","title":"`ERR_AMBIGUOUS_ARGUMENT`","description":"A function argument is being used in a way that suggests that the function signature may be misunderstood. This is thrown by the assert module when the message parameter in assert.throws(block, message) matches the error message thrown by block because that usage suggests that the user believes message is the expected message rather than the message the AssertionError will display if block does not throw."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_arg_not_iterable","title":"`ERR_ARG_NOT_ITERABLE`","description":"An iterable argument (i.e. a value that works with for...of loops) was required, but not provided to a Node.js API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_assertion","title":"`ERR_ASSERTION`","description":"A special type of error that can be triggered whenever Node.js detects an exceptional logic violation that should never occur. These are raised typically by the assert module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_async_callback","title":"`ERR_ASYNC_CALLBACK`","description":"An attempt was made to register something that is not a function as an AsyncHooks callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_async_type","title":"`ERR_ASYNC_TYPE`","description":"The type of an asynchronous resource was invalid. Users are also able to define their own types if using the public embedder API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_brotli_compression_failed","title":"`ERR_BROTLI_COMPRESSION_FAILED`","description":"Data passed to a Brotli stream was not successfully compressed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_brotli_invalid_param","title":"`ERR_BROTLI_INVALID_PARAM`","description":"An invalid parameter key was passed during construction of a Brotli stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_buffer_context_not_available","title":"`ERR_BUFFER_CONTEXT_NOT_AVAILABLE`","description":"An attempt was made to create a Node.js Buffer instance from addon or embedder code, while in a JS engine Context that is not associated with a Node.js instance. The data passed to the Buffer method will have been released by the time the method returns. When encountering this error, a possible alternative to creating a Buffer instance is to create a normal Uint8Array, which only differs in the prototype of the resulting object. Uint8Arrays are generally accepted in all Node.js core APIs where Buffers are; they are available in all Contexts."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_buffer_out_of_bounds","title":"`ERR_BUFFER_OUT_OF_BOUNDS`","description":"An operation outside the bounds of a Buffer was attempted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_buffer_too_large","title":"`ERR_BUFFER_TOO_LARGE`","description":"An attempt has been made to create a Buffer larger than the maximum allowed size."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_cannot_watch_sigint","title":"`ERR_CANNOT_WATCH_SIGINT`","description":"Node.js was unable to watch for the SIGINT signal."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_child_closed_before_reply","title":"`ERR_CHILD_CLOSED_BEFORE_REPLY`","description":"A child process was closed before the parent received a reply."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_child_process_ipc_required","title":"`ERR_CHILD_PROCESS_IPC_REQUIRED`","description":"Used when a child process is being forked without specifying an IPC channel."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_child_process_stdio_maxbuffer","title":"`ERR_CHILD_PROCESS_STDIO_MAXBUFFER`","description":"Used when the main process is trying to read data from the child process's STDERR\/STDOUT, and the data's length is longer than the maxBuffer option."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_console_writable_stream","title":"`ERR_CONSOLE_WRITABLE_STREAM`","description":"Console was instantiated without stdout stream, or Console has a non-writable stdout or stderr stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_construct_call_invalid","title":"`ERR_CONSTRUCT_CALL_INVALID`","description":"A class constructor was called that is not callable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_construct_call_required","title":"`ERR_CONSTRUCT_CALL_REQUIRED`","description":"A constructor for a class was called without new."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_context_not_initialized","title":"`ERR_CONTEXT_NOT_INITIALIZED`","description":"The vm context passed into the API is not yet initialized. This could happen when an error occurs (and is caught) during the creation of the context, for example, when the allocation fails or the maximum call stack size is reached when the context is created."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_custom_engine_not_supported","title":"`ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED`","description":"A client certificate engine was requested that is not supported by the version of OpenSSL being used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_ecdh_invalid_format","title":"`ERR_CRYPTO_ECDH_INVALID_FORMAT`","description":"An invalid value for the format argument was passed to the crypto.ECDH() class getPublicKey() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_ecdh_invalid_public_key","title":"`ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY`","description":"An invalid value for the key argument has been passed to the crypto.ECDH() class computeSecret() method. It means that the public key lies outside of the elliptic curve."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_engine_unknown","title":"`ERR_CRYPTO_ENGINE_UNKNOWN`","description":"An invalid crypto engine identifier was passed to require('crypto').setEngine()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_fips_forced","title":"`ERR_CRYPTO_FIPS_FORCED`","description":"The --force-fips command-line argument was used but there was an attempt to enable or disable FIPS mode in the crypto module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_fips_unavailable","title":"`ERR_CRYPTO_FIPS_UNAVAILABLE`","description":"An attempt was made to enable or disable FIPS mode, but FIPS mode was not available."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_hash_finalized","title":"`ERR_CRYPTO_HASH_FINALIZED`","description":"hash.digest() was called multiple times. The hash.digest() method must be called no more than one time per instance of a Hash object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_hash_update_failed","title":"`ERR_CRYPTO_HASH_UPDATE_FAILED`","description":"hash.update() failed for any reason. This should rarely, if ever, happen."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_incompatible_key","title":"`ERR_CRYPTO_INCOMPATIBLE_KEY`","description":"The given crypto keys are incompatible with the attempted operation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_incompatible_key_options","title":"`ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS`","description":"The selected public or private key encoding is incompatible with other options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_initialization_failed","title":"`ERR_CRYPTO_INITIALIZATION_FAILED`","description":"Initialization of the crypto subsystem failed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_auth_tag","title":"`ERR_CRYPTO_INVALID_AUTH_TAG`","description":"An invalid authentication tag was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_counter","title":"`ERR_CRYPTO_INVALID_COUNTER`","description":"An invalid counter was provided for a counter-mode cipher."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_curve","title":"`ERR_CRYPTO_INVALID_CURVE`","description":"An invalid elliptic-curve was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_digest","title":"`ERR_CRYPTO_INVALID_DIGEST`","description":"An invalid crypto digest algorithm was specified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_iv","title":"`ERR_CRYPTO_INVALID_IV`","description":"An invalid initialization vector was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_jwk","title":"`ERR_CRYPTO_INVALID_JWK`","description":"An invalid JSON Web Key was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_key_object_type","title":"`ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE`","description":"The given crypto key object's type is invalid for the attempted operation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_keylen","title":"`ERR_CRYPTO_INVALID_KEYLEN`","description":"An invalid key length was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_keypair","title":"`ERR_CRYPTO_INVALID_KEYPAIR`","description":"An invalid key pair was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_keytype","title":"`ERR_CRYPTO_INVALID_KEYTYPE`","description":"An invalid key type was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_messagelen","title":"`ERR_CRYPTO_INVALID_MESSAGELEN`","description":"An invalid message length was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_scrypt_params","title":"`ERR_CRYPTO_INVALID_SCRYPT_PARAMS`","description":"Invalid scrypt algorithm parameters were provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_state","title":"`ERR_CRYPTO_INVALID_STATE`","description":"A crypto method was used on an object that was in an invalid state. For instance, calling cipher.getAuthTag() before calling cipher.final()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_invalid_tag_length","title":"`ERR_CRYPTO_INVALID_TAG_LENGTH`","description":"An invalid authentication tag length was provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_job_init_failed","title":"`ERR_CRYPTO_JOB_INIT_FAILED`","description":"Initialization of an asynchronous crypto operation failed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_operation_failed","title":"`ERR_CRYPTO_OPERATION_FAILED`","description":"A crypto operation failed for an otherwise unspecified reason."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_pbkdf2_error","title":"`ERR_CRYPTO_PBKDF2_ERROR`","description":"The PBKDF2 algorithm failed for unspecified reasons. OpenSSL does not provide more details and therefore neither does Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_scrypt_invalid_parameter","title":"`ERR_CRYPTO_SCRYPT_INVALID_PARAMETER`","description":"One or more crypto.scrypt() or crypto.scryptSync() parameters are outside their legal range."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_scrypt_not_supported","title":"`ERR_CRYPTO_SCRYPT_NOT_SUPPORTED`","description":"Node.js was compiled without scrypt support. Not possible with the official release binaries but can happen with custom builds, including distro builds."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_sign_key_required","title":"`ERR_CRYPTO_SIGN_KEY_REQUIRED`","description":"A signing key was not provided to the sign.sign() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_timing_safe_equal_length","title":"`ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH`","description":"crypto.timingSafeEqual() was called with Buffer, TypedArray, or DataView arguments of different lengths."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_unknown_cipher","title":"`ERR_CRYPTO_UNKNOWN_CIPHER`","description":"An unknown cipher was specified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_unknown_dh_group","title":"`ERR_CRYPTO_UNKNOWN_DH_GROUP`","description":"An unknown Diffie-Hellman group name was given. See crypto.getDiffieHellman() for a list of valid group names."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_dlopen_failed","title":"`ERR_DLOPEN_FAILED`","description":"A call to process.dlopen() failed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_dir_closed","title":"`ERR_DIR_CLOSED`","description":"The fs.Dir was previously closed. <a id\"ERR_CRYPTO_UNSUPPORTED_OPERATION\">"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_unsupported_operation","title":"`ERR_CRYPTO_UNSUPPORTED_OPERATION`","description":"An attempt to invoke an unsupported crypto operation was made."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_dir_concurrent_operation","title":"`ERR_DIR_CONCURRENT_OPERATION`","description":"A synchronous read or close call was attempted on an fs.Dir which has ongoing asynchronous operations."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_dns_set_servers_failed","title":"`ERR_DNS_SET_SERVERS_FAILED`","description":"c-ares failed to set the DNS server."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_domain_callback_not_available","title":"`ERR_DOMAIN_CALLBACK_NOT_AVAILABLE`","description":"The domain module was not usable since it could not establish the required error handling hooks, because process.setUncaughtExceptionCaptureCallback() had been called at an earlier point in time."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_domain_cannot_set_uncaught_exception_capture","title":"`ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE`","description":"process.setUncaughtExceptionCaptureCallback() could not be called because the domain module has been loaded at an earlier point in time. The stack trace is extended to include the point in time at which the domain module had been loaded."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_encoding_invalid_encoded_data","title":"`ERR_ENCODING_INVALID_ENCODED_DATA`","description":"Data provided to TextDecoder() API was invalid according to the encoding provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_encoding_not_supported","title":"`ERR_ENCODING_NOT_SUPPORTED`","description":"Encoding provided to TextDecoder() API was not one of the WHATWG Supported Encodings."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_eval_esm_cannot_print","title":"`ERR_EVAL_ESM_CANNOT_PRINT`","description":"--print cannot be used with ESM input."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_event_recursion","title":"`ERR_EVENT_RECURSION`","description":"Thrown when an attempt is made to recursively dispatch an event on EventTarget."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_execution_environment_not_available","title":"`ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE`","description":"The JS execution context is not associated with a Node.js environment. This may occur when Node.js is used as an embedded library and some hooks for the JS engine are not set up properly."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_falsy_value_rejection","title":"`ERR_FALSY_VALUE_REJECTION`","description":"A Promise that was callbackified via util.callbackify() was rejected with a falsy value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_feature_unavailable_on_platform","title":"`ERR_FEATURE_UNAVAILABLE_ON_PLATFORM`","description":"Used when a feature that is not available to the current platform which is running Node.js is used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_fs_eisdir","title":"`ERR_FS_EISDIR`","description":"Path is a directory."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_fs_file_too_large","title":"`ERR_FS_FILE_TOO_LARGE`","description":"An attempt has been made to read a file whose size is larger than the maximum allowed size for a Buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_fs_invalid_symlink_type","title":"`ERR_FS_INVALID_SYMLINK_TYPE`","description":"An invalid symlink type was passed to the fs.symlink() or fs.symlinkSync() methods."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http_headers_sent","title":"`ERR_HTTP_HEADERS_SENT`","description":"An attempt was made to add more headers after the headers had already been sent."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http_invalid_header_value","title":"`ERR_HTTP_INVALID_HEADER_VALUE`","description":"An invalid HTTP header value was specified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http_invalid_status_code","title":"`ERR_HTTP_INVALID_STATUS_CODE`","description":"Status code was outside the regular status code range (100-999)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http_request_timeout","title":"`ERR_HTTP_REQUEST_TIMEOUT`","description":"The client has not sent the entire request within the allowed time."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http_socket_encoding","title":"`ERR_HTTP_SOCKET_ENCODING`","description":"Changing the socket encoding is not allowed per RFC 7230 Section 3."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http_trailer_invalid","title":"`ERR_HTTP_TRAILER_INVALID`","description":"The Trailer header was set even though the transfer encoding does not support that."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_altsvc_invalid_origin","title":"`ERR_HTTP2_ALTSVC_INVALID_ORIGIN`","description":"HTTP\/2 ALTSVC frames require a valid origin."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_altsvc_length","title":"`ERR_HTTP2_ALTSVC_LENGTH`","description":"HTTP\/2 ALTSVC frames are limited to a maximum of 16,382 payload bytes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_connect_authority","title":"`ERR_HTTP2_CONNECT_AUTHORITY`","description":"For HTTP\/2 requests using the CONNECT method, the :authority pseudo-header is required."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_connect_path","title":"`ERR_HTTP2_CONNECT_PATH`","description":"For HTTP\/2 requests using the CONNECT method, the :path pseudo-header is forbidden."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_connect_scheme","title":"`ERR_HTTP2_CONNECT_SCHEME`","description":"For HTTP\/2 requests using the CONNECT method, the :scheme pseudo-header is forbidden."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_error","title":"`ERR_HTTP2_ERROR`","description":"A non-specific HTTP\/2 error has occurred."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_goaway_session","title":"`ERR_HTTP2_GOAWAY_SESSION`","description":"New HTTP\/2 Streams may not be opened after the Http2Session has received a GOAWAY frame from the connected peer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_header_single_value","title":"`ERR_HTTP2_HEADER_SINGLE_VALUE`","description":"Multiple values were provided for an HTTP\/2 header field that was required to have only a single value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_headers_after_respond","title":"`ERR_HTTP2_HEADERS_AFTER_RESPOND`","description":"An additional headers was specified after an HTTP\/2 response was initiated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_headers_sent","title":"`ERR_HTTP2_HEADERS_SENT`","description":"An attempt was made to send multiple response headers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_info_status_not_allowed","title":"`ERR_HTTP2_INFO_STATUS_NOT_ALLOWED`","description":"Informational HTTP status codes (1xx) may not be set as the response status code on HTTP\/2 responses."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_connection_headers","title":"`ERR_HTTP2_INVALID_CONNECTION_HEADERS`","description":"HTTP\/1 connection specific headers are forbidden to be used in HTTP\/2 requests and responses."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_header_value","title":"`ERR_HTTP2_INVALID_HEADER_VALUE`","description":"An invalid HTTP\/2 header value was specified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_info_status","title":"`ERR_HTTP2_INVALID_INFO_STATUS`","description":"An invalid HTTP informational status code has been specified. Informational status codes must be an integer between 100 and 199 (inclusive)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_origin","title":"`ERR_HTTP2_INVALID_ORIGIN`","description":"HTTP\/2 ORIGIN frames require a valid origin."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_packed_settings_length","title":"`ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH`","description":"Input Buffer and Uint8Array instances passed to the http2.getUnpackedSettings() API must have a length that is a multiple of six."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_pseudoheader","title":"`ERR_HTTP2_INVALID_PSEUDOHEADER`","description":"Only valid HTTP\/2 pseudoheaders (:status, :path, :authority, :scheme, and :method) may be used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_session","title":"`ERR_HTTP2_INVALID_SESSION`","description":"An action was performed on an Http2Session object that had already been destroyed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_setting_value","title":"`ERR_HTTP2_INVALID_SETTING_VALUE`","description":"An invalid value has been specified for an HTTP\/2 setting."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_invalid_stream","title":"`ERR_HTTP2_INVALID_STREAM`","description":"An operation was performed on a stream that had already been destroyed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_max_pending_settings_ack","title":"`ERR_HTTP2_MAX_PENDING_SETTINGS_ACK`","description":"Whenever an HTTP\/2 SETTINGS frame is sent to a connected peer, the peer is required to send an acknowledgment that it has received and applied the new SETTINGS. By default, a maximum number of unacknowledged SETTINGS frames may be sent at any given time. This error code is used when that limit has been reached."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_nested_push","title":"`ERR_HTTP2_NESTED_PUSH`","description":"An attempt was made to initiate a new push stream from within a push stream. Nested push streams are not permitted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_no_socket_manipulation","title":"`ERR_HTTP2_NO_SOCKET_MANIPULATION`","description":"An attempt was made to directly manipulate (read, write, pause, resume, etc.) a socket attached to an Http2Session."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_origin_length","title":"`ERR_HTTP2_ORIGIN_LENGTH`","description":"HTTP\/2 ORIGIN frames are limited to a length of 16382 bytes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_out_of_streams","title":"`ERR_HTTP2_OUT_OF_STREAMS`","description":"The number of streams created on a single HTTP\/2 session reached the maximum limit."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_payload_forbidden","title":"`ERR_HTTP2_PAYLOAD_FORBIDDEN`","description":"A message payload was specified for an HTTP response code for which a payload is forbidden."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_ping_cancel","title":"`ERR_HTTP2_PING_CANCEL`","description":"An HTTP\/2 ping was canceled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_ping_length","title":"`ERR_HTTP2_PING_LENGTH`","description":"HTTP\/2 ping payloads must be exactly 8 bytes in length."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_pseudoheader_not_allowed","title":"`ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED`","description":"An HTTP\/2 pseudo-header has been used inappropriately. Pseudo-headers are header key names that begin with the : prefix."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_push_disabled","title":"`ERR_HTTP2_PUSH_DISABLED`","description":"An attempt was made to create a push stream, which had been disabled by the client."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_send_file","title":"`ERR_HTTP2_SEND_FILE`","description":"An attempt was made to use the Http2Stream.prototype.responseWithFile() API to send a directory."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_send_file_noseek","title":"`ERR_HTTP2_SEND_FILE_NOSEEK`","description":"An attempt was made to use the Http2Stream.prototype.responseWithFile() API to send something other than a regular file, but offset or length options were provided."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_session_error","title":"`ERR_HTTP2_SESSION_ERROR`","description":"The Http2Session closed with a non-zero error code."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_settings_cancel","title":"`ERR_HTTP2_SETTINGS_CANCEL`","description":"The Http2Session settings canceled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_socket_bound","title":"`ERR_HTTP2_SOCKET_BOUND`","description":"An attempt was made to connect a Http2Session object to a net.Socket or tls.TLSSocket that had already been bound to another Http2Session object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_socket_unbound","title":"`ERR_HTTP2_SOCKET_UNBOUND`","description":"An attempt was made to use the socket property of an Http2Session that has already been closed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_status_101","title":"`ERR_HTTP2_STATUS_101`","description":"Use of the 101 Informational status code is forbidden in HTTP\/2."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_status_invalid","title":"`ERR_HTTP2_STATUS_INVALID`","description":"An invalid HTTP status code has been specified. Status codes must be an integer between 100 and 599 (inclusive)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_stream_cancel","title":"`ERR_HTTP2_STREAM_CANCEL`","description":"An Http2Stream was destroyed before any data was transmitted to the connected peer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_stream_error","title":"`ERR_HTTP2_STREAM_ERROR`","description":"A non-zero error code was been specified in an RST_STREAM frame."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_stream_self_dependency","title":"`ERR_HTTP2_STREAM_SELF_DEPENDENCY`","description":"When setting the priority for an HTTP\/2 stream, the stream may be marked as a dependency for a parent stream. This error code is used when an attempt is made to mark a stream and dependent of itself."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_trailers_already_sent","title":"`ERR_HTTP2_TRAILERS_ALREADY_SENT`","description":"Trailing headers have already been sent on the Http2Stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_trailers_not_ready","title":"`ERR_HTTP2_TRAILERS_NOT_READY`","description":"The http2stream.sendTrailers() method cannot be called until after the 'wantTrailers' event is emitted on an Http2Stream object. The 'wantTrailers' event will only be emitted if the waitForTrailers option is set for the Http2Stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_unsupported_protocol","title":"`ERR_HTTP2_UNSUPPORTED_PROTOCOL`","description":"http2.connect() was passed a URL that uses any protocol other than http: or https:."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_incompatible_option_pair","title":"`ERR_INCOMPATIBLE_OPTION_PAIR`","description":"An option pair is incompatible with each other and cannot be used at the same time."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_input_type_not_allowed","title":"`ERR_INPUT_TYPE_NOT_ALLOWED`","description":"The --input-type flag was used to attempt to execute a file. This flag can only be used with input via --eval, --print or STDIN."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_already_activated","title":"`ERR_INSPECTOR_ALREADY_ACTIVATED`","description":"While using the inspector module, an attempt was made to activate the inspector when it already started to listen on a port. Use inspector.close() before activating it on a different address."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_already_connected","title":"`ERR_INSPECTOR_ALREADY_CONNECTED`","description":"While using the inspector module, an attempt was made to connect when the inspector was already connected."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_closed","title":"`ERR_INSPECTOR_CLOSED`","description":"While using the inspector module, an attempt was made to use the inspector after the session had already closed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_command","title":"`ERR_INSPECTOR_COMMAND`","description":"An error occurred while issuing a command via the inspector module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_not_active","title":"`ERR_INSPECTOR_NOT_ACTIVE`","description":"The inspector is not active when inspector.waitForDebugger() is called."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_not_available","title":"`ERR_INSPECTOR_NOT_AVAILABLE`","description":"The inspector module is not available for use."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_not_connected","title":"`ERR_INSPECTOR_NOT_CONNECTED`","description":"While using the inspector module, an attempt was made to use the inspector before it was connected."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_inspector_not_worker","title":"`ERR_INSPECTOR_NOT_WORKER`","description":"An API was called on the main thread that can only be used from the worker thread."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_internal_assertion","title":"`ERR_INTERNAL_ASSERTION`","description":"There was a bug in Node.js or incorrect usage of Node.js internals. To fix the error, open an issue at https:\/\/github.com\/nodejs\/node\/issues."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_address_family","title":"`ERR_INVALID_ADDRESS_FAMILY`","description":"The provided address family is not understood by the Node.js API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_arg_type","title":"`ERR_INVALID_ARG_TYPE`","description":"An argument of the wrong type was passed to a Node.js API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_arg_value","title":"`ERR_INVALID_ARG_VALUE`","description":"An invalid or unsupported value was passed for a given argument."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_async_id","title":"`ERR_INVALID_ASYNC_ID`","description":"An invalid asyncId or triggerAsyncId was passed using AsyncHooks. An id less than -1 should never happen."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_buffer_size","title":"`ERR_INVALID_BUFFER_SIZE`","description":"A swap was performed on a Buffer but its size was not compatible with the operation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_callback","title":"`ERR_INVALID_CALLBACK`","description":"A callback function was required but was not been provided to a Node.js API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_char","title":"`ERR_INVALID_CHAR`","description":"Invalid characters were detected in headers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_cursor_pos","title":"`ERR_INVALID_CURSOR_POS`","description":"A cursor on a given stream cannot be moved to a specified row without a specified column."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_fd","title":"`ERR_INVALID_FD`","description":"A file descriptor ('fd') was not valid (e.g. it was a negative value)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_fd_type","title":"`ERR_INVALID_FD_TYPE`","description":"A file descriptor ('fd') type was not valid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_file_url_host","title":"`ERR_INVALID_FILE_URL_HOST`","description":"A Node.js API that consumes file: URLs (such as certain functions in the fs module) encountered a file URL with an incompatible host. This situation can only occur on Unix-like systems where only localhost or an empty host is supported."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_file_url_path","title":"`ERR_INVALID_FILE_URL_PATH`","description":"A Node.js API that consumes file: URLs (such as certain functions in the fs module) encountered a file URL with an incompatible path. The exact semantics for determining whether a path can be used is platform-dependent."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_handle_type","title":"`ERR_INVALID_HANDLE_TYPE`","description":"An attempt was made to send an unsupported \"handle\" over an IPC communication channel to a child process. See subprocess.send() and process.send() for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_http_token","title":"`ERR_INVALID_HTTP_TOKEN`","description":"An invalid HTTP token was supplied."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_ip_address","title":"`ERR_INVALID_IP_ADDRESS`","description":"An IP address is not valid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_module","title":"`ERR_INVALID_MODULE`","description":"An attempt was made to load a module that does not exist or was otherwise not valid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_module_specifier","title":"`ERR_INVALID_MODULE_SPECIFIER`","description":"The imported module string is an invalid URL, package name, or package subpath specifier."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_package_config","title":"`ERR_INVALID_PACKAGE_CONFIG`","description":"An invalid package.json file failed parsing."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_package_target","title":"`ERR_INVALID_PACKAGE_TARGET`","description":"The package.json \"exports\" field contains an invalid target mapping value for the attempted module resolution."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_performance_mark","title":"`ERR_INVALID_PERFORMANCE_MARK`","description":"While using the Performance Timing API (perf_hooks), a performance mark is invalid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_protocol","title":"`ERR_INVALID_PROTOCOL`","description":"An invalid options.protocol was passed to http.request()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_repl_eval_config","title":"`ERR_INVALID_REPL_EVAL_CONFIG`","description":"Both breakEvalOnSigint and eval options were set in the REPL config, which is not supported."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_repl_input","title":"`ERR_INVALID_REPL_INPUT`","description":"The input may not be used in the REPL. All prohibited inputs are documented in the REPL's documentation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_return_property","title":"`ERR_INVALID_RETURN_PROPERTY`","description":"Thrown in case a function option does not provide a valid value for one of its returned object properties on execution."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_return_property_value","title":"`ERR_INVALID_RETURN_PROPERTY_VALUE`","description":"Thrown in case a function option does not provide an expected value type for one of its returned object properties on execution."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_return_value","title":"`ERR_INVALID_RETURN_VALUE`","description":"Thrown in case a function option does not return an expected value type on execution, such as when a function is expected to return a promise."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_state","title":"`ERR_INVALID_STATE`","description":"Indicates that an operation cannot be completed due to an invalid state. For instance, an object may have already been destroyed, or may be performing another operation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_sync_fork_input","title":"`ERR_INVALID_SYNC_FORK_INPUT`","description":"A Buffer, TypedArray, DataView or string was provided as stdio input to an asynchronous fork. See the documentation for the child_process module for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_this","title":"`ERR_INVALID_THIS`","description":"A Node.js API function was called with an incompatible this value. const urlSearchParams = new URLSearchParams('foo=bar&baz=new');  const buf = Buffer.alloc(1); urlSearchParams.has.call(buf, 'foo'); \/\/ Throws a TypeError with code 'ERR_INVALID_THIS'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_transfer_object","title":"`ERR_INVALID_TRANSFER_OBJECT`","description":"An invalid transfer object was passed to postMessage()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_tuple","title":"`ERR_INVALID_TUPLE`","description":"An element in the iterable provided to the WHATWG URLSearchParams constructor did not represent a [name, value] tuple \u2013 that is, if an element is not iterable, or does not consist of exactly two elements."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_uri","title":"`ERR_INVALID_URI`","description":"An invalid URI was passed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_url","title":"`ERR_INVALID_URL`","description":"An invalid URL was passed to the WHATWG URL constructor to be parsed. The thrown error object typically has an additional property 'input' that contains the URL that failed to parse."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_url_scheme","title":"`ERR_INVALID_URL_SCHEME`","description":"An attempt was made to use a URL of an incompatible scheme (protocol) for a specific purpose. It is only used in the WHATWG URL API support in the fs module (which only accepts URLs with 'file' scheme), but may be used in other Node.js APIs as well in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_ipc_channel_closed","title":"`ERR_IPC_CHANNEL_CLOSED`","description":"An attempt was made to use an IPC communication channel that was already closed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_ipc_disconnected","title":"`ERR_IPC_DISCONNECTED`","description":"An attempt was made to disconnect an IPC communication channel that was already disconnected. See the documentation for the child_process module for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_ipc_one_pipe","title":"`ERR_IPC_ONE_PIPE`","description":"An attempt was made to create a child Node.js process using more than one IPC communication channel. See the documentation for the child_process module for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_ipc_sync_fork","title":"`ERR_IPC_SYNC_FORK`","description":"An attempt was made to open an IPC communication channel with a synchronously forked Node.js process. See the documentation for the child_process module for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_manifest_assert_integrity","title":"`ERR_MANIFEST_ASSERT_INTEGRITY`","description":"An attempt was made to load a resource, but the resource did not match the integrity defined by the policy manifest. See the documentation for policy manifests for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_manifest_dependency_missing","title":"`ERR_MANIFEST_DEPENDENCY_MISSING`","description":"An attempt was made to load a resource, but the resource was not listed as a dependency from the location that attempted to load it. See the documentation for policy manifests for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_manifest_integrity_mismatch","title":"`ERR_MANIFEST_INTEGRITY_MISMATCH`","description":"An attempt was made to load a policy manifest, but the manifest had multiple entries for a resource which did not match each other. Update the manifest entries to match in order to resolve this error. See the documentation for policy manifests for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_manifest_invalid_resource_field","title":"`ERR_MANIFEST_INVALID_RESOURCE_FIELD`","description":"A policy manifest resource had an invalid value for one of its fields. Update the manifest entry to match in order to resolve this error. See the documentation for policy manifests for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_manifest_parse_policy","title":"`ERR_MANIFEST_PARSE_POLICY`","description":"An attempt was made to load a policy manifest, but the manifest was unable to be parsed. See the documentation for policy manifests for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_manifest_tdz","title":"`ERR_MANIFEST_TDZ`","description":"An attempt was made to read from a policy manifest, but the manifest initialization has not yet taken place. This is likely a bug in Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_manifest_unknown_onerror","title":"`ERR_MANIFEST_UNKNOWN_ONERROR`","description":"A policy manifest was loaded, but had an unknown value for its \"onerror\" behavior. See the documentation for policy manifests for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_memory_allocation_failed","title":"`ERR_MEMORY_ALLOCATION_FAILED`","description":"An attempt was made to allocate memory (usually in the C++ layer) but it failed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_message_target_context_unavailable","title":"`ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE`","description":"A message posted to a MessagePort could not be deserialized in the target vm Context. Not all Node.js objects can be successfully instantiated in any context at this time, and attempting to transfer them using postMessage() can fail on the receiving side in that case."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_method_not_implemented","title":"`ERR_METHOD_NOT_IMPLEMENTED`","description":"A method is required but not implemented."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_missing_args","title":"`ERR_MISSING_ARGS`","description":"A required argument of a Node.js API was not passed. This is only used for strict compliance with the API specification (which in some cases may accept func(undefined) but not func()). In most native Node.js APIs, func(undefined) and func() are treated identically, and the ERR_INVALID_ARG_TYPE error code may be used instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_missing_option","title":"`ERR_MISSING_OPTION`","description":"For APIs that accept options objects, some options might be mandatory. This code is thrown if a required option is missing."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_missing_passphrase","title":"`ERR_MISSING_PASSPHRASE`","description":"An attempt was made to read an encrypted key without specifying a passphrase."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_missing_platform_for_worker","title":"`ERR_MISSING_PLATFORM_FOR_WORKER`","description":"The V8 platform used by this instance of Node.js does not support creating Workers. This is caused by lack of embedder support for Workers. In particular, this error will not occur with standard builds of Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_missing_transferable_in_transfer_list","title":"`ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST`","description":"An object that needs to be explicitly listed in the transferList argument is in the object passed to a postMessage() call, but is not provided in the transferList for that call. Usually, this is a MessagePort. In Node.js versions prior to v15.0.0, the error code being used here was ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST. However, the set of transferable object types has been expanded to cover more types than MessagePort."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_module_not_found","title":"`ERR_MODULE_NOT_FOUND`","description":"An ES Module could not be resolved."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_multiple_callback","title":"`ERR_MULTIPLE_CALLBACK`","description":"A callback was called more than once. A callback is almost always meant to only be called once as the query can either be fulfilled or rejected but not both at the same time. The latter would be possible by calling a callback more than once."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_cons_function","title":"`ERR_NAPI_CONS_FUNCTION`","description":"While using N-API, a constructor passed was not a function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_invalid_dataview_args","title":"`ERR_NAPI_INVALID_DATAVIEW_ARGS`","description":"While calling napi_create_dataview(), a given offset was outside the bounds of the dataview or offset + length was larger than a length of given buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_invalid_typedarray_alignment","title":"`ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT`","description":"While calling napi_create_typedarray(), the provided offset was not a multiple of the element size."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_invalid_typedarray_length","title":"`ERR_NAPI_INVALID_TYPEDARRAY_LENGTH`","description":"While calling napi_create_typedarray(), (length * size_of_element) + byte_offset was larger than the length of given buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_tsfn_call_js","title":"`ERR_NAPI_TSFN_CALL_JS`","description":"An error occurred while invoking the JavaScript portion of the thread-safe function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_tsfn_get_undefined","title":"`ERR_NAPI_TSFN_GET_UNDEFINED`","description":"An error occurred while attempting to retrieve the JavaScript undefined value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_tsfn_start_idle_loop","title":"`ERR_NAPI_TSFN_START_IDLE_LOOP`","description":"On the main thread, values are removed from the queue associated with the thread-safe function in an idle loop. This error indicates that an error has occurred when attempting to start the loop."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_tsfn_stop_idle_loop","title":"`ERR_NAPI_TSFN_STOP_IDLE_LOOP`","description":"Once no more items are left in the queue, the idle loop must be suspended. This error indicates that the idle loop has failed to stop."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_no_crypto","title":"`ERR_NO_CRYPTO`","description":"An attempt was made to use crypto features while Node.js was not compiled with OpenSSL crypto support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_no_icu","title":"`ERR_NO_ICU`","description":"An attempt was made to use features that require ICU, but Node.js was not compiled with ICU support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_non_context_aware_disabled","title":"`ERR_NON_CONTEXT_AWARE_DISABLED`","description":"A non-context-aware native addon was loaded in a process that disallows them."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_out_of_range","title":"`ERR_OUT_OF_RANGE`","description":"A given value is out of the accepted range."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_package_import_not_defined","title":"`ERR_PACKAGE_IMPORT_NOT_DEFINED`","description":"The package.json \"imports\" field does not define the given internal package specifier mapping."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_package_path_not_exported","title":"`ERR_PACKAGE_PATH_NOT_EXPORTED`","description":"The package.json \"exports\" field does not export the requested subpath. Because exports are encapsulated, private internal modules that are not exported cannot be imported through the package resolution, unless using an absolute URL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_proto_access","title":"`ERR_PROTO_ACCESS`","description":"Accessing Object.prototype.__proto__ has been forbidden using --disable-proto=throw. Object.getPrototypeOf and Object.setPrototypeOf should be used to get and set the prototype of an object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_quic_failed_to_create_session","title":"`ERR_QUIC_FAILED_TO_CREATE_SESSION`","description":"An unspecified failure occured trying to initialize a new QuicClientSession."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_quic_invalid_remote_transport_params","title":"`ERR_QUIC_INVALID_REMOTE_TRANSPORT_PARAMS`","description":"An attempt to resume a QuicClientSession using remembered remote transport parameters failed because the transport parameters were invalid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_quic_invalid_tls_session_ticket","title":"`ERR_QUIC_INVALID_TLS_SESSION_TICKET`","description":"An attempt resume a QuicClientSession using a remembered TLS session ticket failed because the session ticket was invalid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_quic_version_negotiation","title":"`ERR_QUIC_VERSION_NEGOTIATION`","description":"A QuicClientSession received a version negotiation request from the server and was shutdown accordingly."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_require_esm","title":"`ERR_REQUIRE_ESM`","description":"An attempt was made to require() an ES Module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_script_execution_interrupted","title":"`ERR_SCRIPT_EXECUTION_INTERRUPTED`","description":"Script execution was interrupted by SIGINT (For example, Ctrl+C was pressed.)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_script_execution_timeout","title":"`ERR_SCRIPT_EXECUTION_TIMEOUT`","description":"Script execution timed out, possibly due to bugs in the script being executed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_server_already_listen","title":"`ERR_SERVER_ALREADY_LISTEN`","description":"The server.listen() method was called while a net.Server was already listening. This applies to all instances of net.Server, including HTTP, HTTPS, and HTTP\/2 Server instances."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_server_not_running","title":"`ERR_SERVER_NOT_RUNNING`","description":"The server.close() method was called when a net.Server was not running. This applies to all instances of net.Server, including HTTP, HTTPS, and HTTP\/2 Server instances."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_already_bound","title":"`ERR_SOCKET_ALREADY_BOUND`","description":"An attempt was made to bind a socket that has already been bound."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_bad_buffer_size","title":"`ERR_SOCKET_BAD_BUFFER_SIZE`","description":"An invalid (negative) size was passed for either the recvBufferSize or sendBufferSize options in dgram.createSocket()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_bad_port","title":"`ERR_SOCKET_BAD_PORT`","description":"An API function expecting a port >= 0 and < 65536 received an invalid value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_bad_type","title":"`ERR_SOCKET_BAD_TYPE`","description":"An API function expecting a socket type (udp4 or udp6) received an invalid value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_buffer_size","title":"`ERR_SOCKET_BUFFER_SIZE`","description":"While using dgram.createSocket(), the size of the receive or send Buffer could not be determined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_closed","title":"`ERR_SOCKET_CLOSED`","description":"An attempt was made to operate on an already closed socket."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_dgram_is_connected","title":"`ERR_SOCKET_DGRAM_IS_CONNECTED`","description":"A dgram.connect() call was made on an already connected socket."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_dgram_not_connected","title":"`ERR_SOCKET_DGRAM_NOT_CONNECTED`","description":"A dgram.disconnect() or dgram.remoteAddress() call was made on a disconnected socket."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_dgram_not_running","title":"`ERR_SOCKET_DGRAM_NOT_RUNNING`","description":"A call was made and the UDP subsystem was not running."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_sri_parse","title":"`ERR_SRI_PARSE`","description":"A string was provided for a Subresource Integrity check, but was unable to be parsed. Check the format of integrity attributes by looking at the Subresource Integrity specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_already_finished","title":"`ERR_STREAM_ALREADY_FINISHED`","description":"A stream method was called that cannot complete because the stream was finished."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_cannot_pipe","title":"`ERR_STREAM_CANNOT_PIPE`","description":"An attempt was made to call stream.pipe() on a Writable stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_destroyed","title":"`ERR_STREAM_DESTROYED`","description":"A stream method was called that cannot complete because the stream was destroyed using stream.destroy()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_null_values","title":"`ERR_STREAM_NULL_VALUES`","description":"An attempt was made to call stream.write() with a null chunk."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_premature_close","title":"`ERR_STREAM_PREMATURE_CLOSE`","description":"An error returned by stream.finished() and stream.pipeline(), when a stream or a pipeline ends non gracefully with no explicit error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_push_after_eof","title":"`ERR_STREAM_PUSH_AFTER_EOF`","description":"An attempt was made to call stream.push() after a null(EOF) had been pushed to the stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_unshift_after_end_event","title":"`ERR_STREAM_UNSHIFT_AFTER_END_EVENT`","description":"An attempt was made to call stream.unshift() after the 'end' event was emitted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_wrap","title":"`ERR_STREAM_WRAP`","description":"Prevents an abort if a string decoder was set on the Socket or if the decoder is in objectMode. const Socket = require('net').Socket; const instance = new Socket();  instance.setEncoding('utf8');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_write_after_end","title":"`ERR_STREAM_WRITE_AFTER_END`","description":"An attempt was made to call stream.write() after stream.end() has been called."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_string_too_long","title":"`ERR_STRING_TOO_LONG`","description":"An attempt has been made to create a string longer than the maximum allowed length."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_synthetic","title":"`ERR_SYNTHETIC`","description":"An artificial error object used to capture the call stack for diagnostic reports."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_system_error","title":"`ERR_SYSTEM_ERROR`","description":"An unspecified or non-specific system error has occurred within the Node.js process. The error object will have an err.info object property with additional details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_cert_altname_invalid","title":"`ERR_TLS_CERT_ALTNAME_INVALID`","description":"While using TLS, the host name\/IP of the peer did not match any of the subjectAltNames in its certificate."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_dh_param_size","title":"`ERR_TLS_DH_PARAM_SIZE`","description":"While using TLS, the parameter offered for the Diffie-Hellman (DH) key-agreement protocol is too small. By default, the key length must be greater than or equal to 1024 bits to avoid vulnerabilities, even though it is strongly recommended to use 2048 bits or larger for stronger security."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_handshake_timeout","title":"`ERR_TLS_HANDSHAKE_TIMEOUT`","description":"A TLS\/SSL handshake timed out. In this case, the server must also abort the connection."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_invalid_context","title":"`ERR_TLS_INVALID_CONTEXT`","description":"The context must be a SecureContext."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_invalid_protocol_method","title":"`ERR_TLS_INVALID_PROTOCOL_METHOD`","description":"The specified  secureProtocol method is invalid. It is  either unknown, or disabled because it is insecure."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_invalid_protocol_version","title":"`ERR_TLS_INVALID_PROTOCOL_VERSION`","description":"Valid TLS protocol versions are 'TLSv1', 'TLSv1.1', or 'TLSv1.2'."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_invalid_state","title":"`ERR_TLS_INVALID_STATE`","description":"The TLS socket must be connected and securily established. Ensure the 'secure' event is emitted before continuing."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_protocol_version_conflict","title":"`ERR_TLS_PROTOCOL_VERSION_CONFLICT`","description":"Attempting to set a TLS protocol minVersion or maxVersion conflicts with an attempt to set the secureProtocol explicitly. Use one mechanism or the other."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_psk_set_identiy_hint_failed","title":"`ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED`","description":"Failed to set PSK identity hint. Hint may be too long."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_renegotiation_disabled","title":"`ERR_TLS_RENEGOTIATION_DISABLED`","description":"An attempt was made to renegotiate TLS on a socket instance with TLS disabled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_required_server_name","title":"`ERR_TLS_REQUIRED_SERVER_NAME`","description":"While using TLS, the server.addContext() method was called without providing a host name in the first parameter."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_session_attack","title":"`ERR_TLS_SESSION_ATTACK`","description":"An excessive amount of TLS renegotiations is detected, which is a potential vector for denial-of-service attacks."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_sni_from_server","title":"`ERR_TLS_SNI_FROM_SERVER`","description":"An attempt was made to issue Server Name Indication from a TLS server-side socket, which is only valid from a client."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_trace_events_category_required","title":"`ERR_TRACE_EVENTS_CATEGORY_REQUIRED`","description":"The trace_events.createTracing() method requires at least one trace event category."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_trace_events_unavailable","title":"`ERR_TRACE_EVENTS_UNAVAILABLE`","description":"The trace_events module could not be loaded because Node.js was compiled with the --without-v8-platform flag."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_transform_already_transforming","title":"`ERR_TRANSFORM_ALREADY_TRANSFORMING`","description":"A Transform stream finished while it was still transforming."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_transform_with_length_0","title":"`ERR_TRANSFORM_WITH_LENGTH_0`","description":"A Transform stream finished with data still in the write buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tty_init_failed","title":"`ERR_TTY_INIT_FAILED`","description":"The initialization of a TTY failed due to a system error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unavailable_during_exit","title":"`ERR_UNAVAILABLE_DURING_EXIT`","description":"Function was called within a process.on('exit') handler that shouldn't be called within process.on('exit') handler."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_uncaught_exception_capture_already_set","title":"`ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET`","description":"process.setUncaughtExceptionCaptureCallback() was called twice, without first resetting the callback to null. This error is designed to prevent accidentally overwriting a callback registered from another module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unescaped_characters","title":"`ERR_UNESCAPED_CHARACTERS`","description":"A string that contained unescaped characters was received."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unhandled_error","title":"`ERR_UNHANDLED_ERROR`","description":"An unhandled error occurred (for instance, when an 'error' event is emitted by an EventEmitter but an 'error' handler is not registered)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_builtin_module","title":"`ERR_UNKNOWN_BUILTIN_MODULE`","description":"Used to identify a specific kind of internal Node.js error that should not typically be triggered by user code. Instances of this error point to an internal bug within the Node.js binary itself."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_credential","title":"`ERR_UNKNOWN_CREDENTIAL`","description":"A Unix group or user identifier that does not exist was passed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_encoding","title":"`ERR_UNKNOWN_ENCODING`","description":"An invalid or unknown encoding option was passed to an API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_file_extension","title":"`ERR_UNKNOWN_FILE_EXTENSION`","description":"An attempt was made to load a module with an unknown or unsupported file extension."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_module_format","title":"`ERR_UNKNOWN_MODULE_FORMAT`","description":"An attempt was made to load a module with an unknown or unsupported format."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_signal","title":"`ERR_UNKNOWN_SIGNAL`","description":"An invalid or unknown process signal was passed to an API expecting a valid signal (such as subprocess.kill())."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unsupported_dir_import","title":"`ERR_UNSUPPORTED_DIR_IMPORT`","description":"import a directory URL is unsupported. Instead, self-reference a package using its name and define a custom subpath in the \"exports\" field of the package.json file.  import '.\/'; \/\/ unsupported import '.\/index.js'; \/\/ supported import 'package-name'; \/\/ supported"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unsupported_esm_url_scheme","title":"`ERR_UNSUPPORTED_ESM_URL_SCHEME`","description":"import with URL schemes other than file and data is unsupported."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_valid_performance_entry_type","title":"`ERR_VALID_PERFORMANCE_ENTRY_TYPE`","description":"While using the Performance Timing API (perf_hooks), no valid performance entry types are found."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_dynamic_import_callback_missing","title":"`ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING`","description":"A dynamic import callback was not specified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_already_linked","title":"`ERR_VM_MODULE_ALREADY_LINKED`","description":"The module attempted to be linked is not eligible for linking, because of one of the following reasons:  It has already been linked (linkingStatus is 'linked') It is being linked (linkingStatus is 'linking') Linking has failed for this module (linkingStatus is 'errored')"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_cached_data_rejected","title":"`ERR_VM_MODULE_CACHED_DATA_REJECTED`","description":"The cachedData option passed to a module constructor is invalid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_cannot_create_cached_data","title":"`ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA`","description":"Cached data cannot be created for modules which have already been evaluated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_different_context","title":"`ERR_VM_MODULE_DIFFERENT_CONTEXT`","description":"The module being returned from the linker function is from a different context than the parent module. Linked modules must share the same context."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_linking_errored","title":"`ERR_VM_MODULE_LINKING_ERRORED`","description":"The linker function returned a module for which linking has failed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_not_module","title":"`ERR_VM_MODULE_NOT_MODULE`","description":"The fulfilled value of a linking promise is not a vm.Module object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_status","title":"`ERR_VM_MODULE_STATUS`","description":"The current module's status does not allow for this operation. The specific meaning of the error depends on the specific function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_wasi_already_started","title":"`ERR_WASI_ALREADY_STARTED`","description":"The WASI instance has already started."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_wasi_not_started","title":"`ERR_WASI_NOT_STARTED`","description":"The WASI instance has not been started."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_init_failed","title":"`ERR_WORKER_INIT_FAILED`","description":"The Worker initialization failed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_invalid_exec_argv","title":"`ERR_WORKER_INVALID_EXEC_ARGV`","description":"The execArgv option passed to the Worker constructor contains invalid flags."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_not_running","title":"`ERR_WORKER_NOT_RUNNING`","description":"An operation failed because the Worker instance is not currently running."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_out_of_memory","title":"`ERR_WORKER_OUT_OF_MEMORY`","description":"The Worker instance terminated because it reached its memory limit."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_path","title":"`ERR_WORKER_PATH`","description":"The path for the main script of a worker is neither an absolute path nor a relative path starting with .\/ or ..\/."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_unserializable_error","title":"`ERR_WORKER_UNSERIALIZABLE_ERROR`","description":"All attempts at serializing an uncaught exception from a worker thread failed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_unsupported_extension","title":"`ERR_WORKER_UNSUPPORTED_EXTENSION`","description":"The pathname used for the main script of a worker has an unknown file extension."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_worker_unsupported_operation","title":"`ERR_WORKER_UNSUPPORTED_OPERATION`","description":"The requested functionality is not supported in worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_zlib_initialization_failed","title":"`ERR_ZLIB_INITIALIZATION_FAILED`","description":"Creation of a zlib object failed due to incorrect configuration."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_hpe_header_overflow","title":"`HPE_HEADER_OVERFLOW`","description":"Too much HTTP header data was received. In order to protect against malicious or malconfigured clients, if more than 8KB of HTTP header data is received then HTTP parsing will abort without a request or response object being created, and an Error with this code will be emitted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_hpe_unexpected_content_length","title":"`HPE_UNEXPECTED_CONTENT_LENGTH`","description":"Server is sending both a Content-Length header and Transfer-Encoding: chunked. Transfer-Encoding: chunked allows the server to maintain an HTTP persistent connection for dynamically generated content. In this case, the Content-Length HTTP header cannot be used. Use Content-Length or Transfer-Encoding: chunked."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_not_found","title":"`MODULE_NOT_FOUND`","description":"A module file could not be resolved while attempting a require() or import operation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_legacy_node_js_error_codes","title":"Legacy Node.js error codes","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_cannot_transfer_object","title":"`ERR_CANNOT_TRANSFER_OBJECT`","description":"The value passed to postMessage() contained an object that is not supported for transferring."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_closed_message_port","title":"`ERR_CLOSED_MESSAGE_PORT`","description":"There was an attempt to use a MessagePort instance in a closed state, usually after .close() has been called."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_crypto_hash_digest_no_utf16","title":"`ERR_CRYPTO_HASH_DIGEST_NO_UTF16`","description":"The UTF-16 encoding was used with hash.digest(). While the hash.digest() method does allow an encoding argument to be passed in, causing the method to return a string rather than a Buffer, the UTF-16 encoding (e.g. ucs or utf16le) is not supported."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_frame_error","title":"`ERR_HTTP2_FRAME_ERROR`","description":"Used when a failure occurs sending an individual frame on the HTTP\/2 session."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_headers_object","title":"`ERR_HTTP2_HEADERS_OBJECT`","description":"Used when an HTTP\/2 Headers Object is expected."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_header_required","title":"`ERR_HTTP2_HEADER_REQUIRED`","description":"Used when a required header is missing in an HTTP\/2 message."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_info_headers_after_respond","title":"`ERR_HTTP2_INFO_HEADERS_AFTER_RESPOND`","description":"HTTP\/2 informational headers must only be sent prior to calling the Http2Stream.prototype.respond() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http2_stream_closed","title":"`ERR_HTTP2_STREAM_CLOSED`","description":"Used when an action has been performed on an HTTP\/2 Stream that has already been closed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_http_invalid_char","title":"`ERR_HTTP_INVALID_CHAR`","description":"Used when an invalid character is found in an HTTP response status message (reason phrase)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_index_out_of_range","title":"`ERR_INDEX_OUT_OF_RANGE`","description":"A given index was out of the accepted range (e.g. negative offsets)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_opt_value","title":"`ERR_INVALID_OPT_VALUE`","description":"An invalid or unexpected value was passed in an options object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_invalid_opt_value_encoding","title":"`ERR_INVALID_OPT_VALUE_ENCODING`","description":"An invalid or unknown file encoding was passed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_missing_message_port_in_transfer_list","title":"`ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST`","description":"This error code was replaced by ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST in Node.js v15.0.0, because it is no longer accurate as other types of transferable objects also exist now."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_napi_cons_prototype_object","title":"`ERR_NAPI_CONS_PROTOTYPE_OBJECT`","description":"Used by the N-API when Constructor.prototype is not an object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_no_longer_supported","title":"`ERR_NO_LONGER_SUPPORTED`","description":"A Node.js API was called in an unsupported manner, such as Buffer.write(string, encoding, offset[, length])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_operation_failed","title":"`ERR_OPERATION_FAILED`","description":"An operation failed. This is typically used to signal the general failure of an asynchronous operation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_outofmemory","title":"`ERR_OUTOFMEMORY`","description":"Used generically to identify that an operation caused an out of memory condition."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_parse_history_data","title":"`ERR_PARSE_HISTORY_DATA`","description":"The repl module was unable to parse data from the REPL history file."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_socket_cannot_send","title":"`ERR_SOCKET_CANNOT_SEND`","description":"Data could not be sent on a socket."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stderr_close","title":"`ERR_STDERR_CLOSE`","description":"An attempt was made to close the process.stderr stream. By design, Node.js does not allow stdout or stderr streams to be closed by user code."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stdout_close","title":"`ERR_STDOUT_CLOSE`","description":"An attempt was made to close the process.stdout stream. By design, Node.js does not allow stdout or stderr streams to be closed by user code."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_stream_read_not_implemented","title":"`ERR_STREAM_READ_NOT_IMPLEMENTED`","description":"Used when an attempt is made to use a readable stream that has not implemented readable._read()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_tls_renegotiation_failed","title":"`ERR_TLS_RENEGOTIATION_FAILED`","description":"Used when a TLS renegotiation request has failed in a non-specific way."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_transferring_externalized_sharedarraybuffer","title":"`ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER`","description":"A SharedArrayBuffer whose memory is not managed by the JavaScript engine or by Node.js was encountered during serialization. Such a SharedArrayBuffer cannot be serialized. This can only happen when native addons create SharedArrayBuffers in \"externalized\" mode, or put existing SharedArrayBuffer into externalized mode."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_stdin_type","title":"`ERR_UNKNOWN_STDIN_TYPE`","description":"An attempt was made to launch a Node.js process with an unknown stdin file type. This error is usually an indication of a bug within Node.js itself, although it is possible for user code to trigger it."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_unknown_stream_type","title":"`ERR_UNKNOWN_STREAM_TYPE`","description":"An attempt was made to launch a Node.js process with an unknown stdout or stderr file type. This error is usually an indication of a bug within Node.js itself, although it is possible for user code to trigger it."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_v8breakiterator","title":"`ERR_V8BREAKITERATOR`","description":"The V8 BreakIterator API was used but the full ICU data set is not installed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_value_out_of_range","title":"`ERR_VALUE_OUT_OF_RANGE`","description":"Used when a given value is out of the accepted range."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_vm_module_not_linked","title":"`ERR_VM_MODULE_NOT_LINKED`","description":"The module must be successfully linked before instantiation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_zlib_binding_closed","title":"`ERR_ZLIB_BINDING_CLOSED`","description":"Used when an attempt is made to use a zlib object after it has already been closed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_err_cpu_usage","title":"`ERR_CPU_USAGE`","description":"The native call from process.cpuUsage could not be processed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_global_objects","title":"Global objects","description":"These objects are available in all modules. The following variables may appear to be global but are not. They exist only in the scope of modules, see the module system documentation:  __dirname __filename exports module require()  The objects listed here are specific to Node.js. There are built-in objects that are part of the JavaScript language itself, which are also globally accessible."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_abortcontroller","title":"Class: `AbortController`","description":"Stability: 1 - Experimental  A utility class used to signal cancelation in selected Promise-based APIs. The API is based on the Web API AbortController. const ac = new AbortController();  ac.signal.addEventListener('abort', () => console.log('Aborted!'),                            { once: true });  ac.abort();  console.log(ac.signal.aborted);  \/\/ Prints True"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_abortcontroller_abort","title":"`abortController.abort()`","description":"Triggers the abort signal, causing the abortController.signal to emit the 'abort' event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_buffer","title":"Class: `Buffer`","description":"<Function>  Used to handle binary data. See the buffer section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearimmediate_immediateobject","title":"`clearImmediate(immediateObject)`","description":"clearImmediate is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearinterval_intervalobject","title":"`clearInterval(intervalObject)`","description":"clearInterval is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cleartimeout_timeoutobject","title":"`clearTimeout(timeoutObject)`","description":"clearTimeout is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console","title":"`console`","description":"<Object>  Used to print to stdout and stderr. See the console section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_event","title":"`Event`","description":"A browser-compatible implementation of the Event class. See EventTarget and Event API for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_eventtarget","title":"`EventTarget`","description":"A browser-compatible implementation of the EventTarget class. See EventTarget and Event API for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_global","title":"`global`","description":"<Object> The global namespace object.  In browsers, the top-level scope is the global scope. This means that within the browser var something will define a new global variable. In Node.js this is different. The top-level scope is not the global scope; var something inside a Node.js module will be local to that module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_messagechannel","title":"`MessageChannel`","description":"The MessageChannel class. See MessageChannel for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_messageevent","title":"`MessageEvent`","description":"The MessageEvent class. See MessageEvent for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_messageport","title":"`MessagePort`","description":"The MessagePort class. See MessagePort for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_process","title":"`process`","description":"<Object>  The process object. See the process object section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_queuemicrotask_callback","title":"`queueMicrotask(callback)`","description":"callback <Function> Function to be queued.  The queueMicrotask() method queues a microtask to invoke callback. If callback throws an exception, the process object 'uncaughtException' event will be emitted. The microtask queue is managed by V8 and may be used in a similar manner to the process.nextTick() queue, which is managed by Node.js. The process.nextTick() queue is always processed before the microtask queue within each turn of the Node.js event loop. \/\/ Here, `queueMicrotask()` is used to ensure the 'load' event is always \/\/ emitted asynchronously, and therefore consistently. Using \/\/ `process.nextTick()` here would result in the 'load' event always emitting \/\/ before any other promise jobs.  DataHandler.prototype.load = async function load(key) {   const hit = this._cache.get(url);   if (hit !== undefined) {     queueMicrotask(() => {       this.emit('load', hit);     });     return;   }    const data = await fetchData(key);   this._cache.set(url, data);   this.emit('load', data); };"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setimmediate_callback_args","title":"`setImmediate(callback[, ...args])`","description":"setImmediate is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setinterval_callback_delay_args","title":"`setInterval(callback, delay[, ...args])`","description":"setInterval is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_settimeout_callback_delay_args","title":"`setTimeout(callback, delay[, ...args])`","description":"setTimeout is described in the timers section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_textdecoder","title":"`TextDecoder`","description":"The WHATWG TextDecoder class. See the TextDecoder section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_textencoder","title":"`TextEncoder`","description":"The WHATWG TextEncoder class. See the TextEncoder section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url","title":"`URL`","description":"The WHATWG URL class. See the URL section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_urlsearchparams","title":"`URLSearchParams`","description":"The WHATWG URLSearchParams class. See the URLSearchParams section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_webassembly","title":"`WebAssembly`","description":"<Object>  The object that acts as the namespace for all W3C WebAssembly related functionality. See the Mozilla Developer Network for usage and compatibility."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require","title":"`require()`","description":"This variable may appear to be global but is not. See require()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all__dirname","title":"`__dirname`","description":"This variable may appear to be global but is not. See __dirname."},{"url":"http:\/\/nodejs.org\/api\/all.html#all__filename","title":"`__filename`","description":"This variable may appear to be global but is not. See __filename."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exports","title":"`exports`","description":"This variable may appear to be global but is not. See exports."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module","title":"`module`","description":"This variable may appear to be global but is not. See module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_internationalization_support","title":"Internationalization support","description":"Node.js has many features that make it easier to write internationalized programs. Some of them are:  Locale-sensitive or Unicode-aware functions in the ECMAScript Language Specification:  String.prototype.normalize() String.prototype.toLowerCase() String.prototype.toUpperCase()   All functionality described in the ECMAScript Internationalization API Specification (aka ECMA-402):  Intl object Locale-sensitive methods like String.prototype.localeCompare() and Date.prototype.toLocaleString()   The WHATWG URL parser's internationalized domain names (IDNs) support require('buffer').transcode() More accurate REPL line editing require('util').TextDecoder RegExp Unicode Property Escapes  Node.js (and its underlying V8 engine) uses ICU to implement these features in native C\/C++ code. The full ICU data set is provided by Node.js by default. However, due to the size of the ICU data file, several options are provided for customizing the ICU data set either when building or running Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_options_for_building_node_js","title":"Options for building Node.js","description":"To control how ICU is used in Node.js, four configure options are available during compilation. Additional details on how to compile Node.js are documented in BUILDING.md.  --with-intl=none\/--without-intl --with-intl=system-icu --with-intl=small-icu --with-intl=full-icu (default)  An overview of available Node.js and JavaScript features for each configure option:     none system-icu small-icu full-icu     String.prototype.normalize() none (function is no-op) full full full   String.prototype.to*Case() full full full full   Intl none (object does not exist) partial\/full (depends on OS) partial (English-only) full   String.prototype.localeCompare() partial (not locale-aware) full full full   String.prototype.toLocale*Case() partial (not locale-aware) full full full   Number.prototype.toLocaleString() partial (not locale-aware) partial\/full (depends on OS) partial (English-only) full   Date.prototype.toLocale*String() partial (not locale-aware) partial\/full (depends on OS) partial (English-only) full   WHATWG URL Parser partial (no IDN support) full full full   require('buffer').transcode() none (function does not exist) full full full   REPL partial (inaccurate line editing) full full full   require('util').TextDecoder partial (basic encodings support) partial\/full (depends on OS) partial (Unicode-only) full   RegExp Unicode Property Escapes none (invalid RegExp error) full full full    The \"(not locale-aware)\" designation denotes that the function carries out its operation just like the non-Locale version of the function, if one exists. For example, under none mode, Date.prototype.toLocaleString()'s operation is identical to that of Date.prototype.toString()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_disable_all_internationalization_features_none","title":"Disable all internationalization features (`none`)","description":"If this option is chosen, ICU is disabled and most internationalization features mentioned above will be unavailable in the resulting node binary."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_build_with_a_pre_installed_icu_system_icu","title":"Build with a pre-installed ICU (`system-icu`)","description":"Node.js can link against an ICU build already installed on the system. In fact, most Linux distributions already come with ICU installed, and this option would make it possible to reuse the same set of data used by other components in the OS. Functionalities that only require the ICU library itself, such as String.prototype.normalize() and the WHATWG URL parser, are fully supported under system-icu. Features that require ICU locale data in addition, such as Intl.DateTimeFormat may be fully or partially supported, depending on the completeness of the ICU data installed on the system."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_embed_a_limited_set_of_icu_data_small_icu","title":"Embed a limited set of ICU data (`small-icu`)","description":"This option makes the resulting binary link against the ICU library statically, and includes a subset of ICU data (typically only the English locale) within the node executable. Functionalities that only require the ICU library itself, such as String.prototype.normalize() and the WHATWG URL parser, are fully supported under small-icu. Features that require ICU locale data in addition, such as Intl.DateTimeFormat, generally only work with the English locale: const january = new Date(9e8); const english = new Intl.DateTimeFormat('en', { month: 'long' }); const spanish = new Intl.DateTimeFormat('es', { month: 'long' });  console.log(english.format(january)); \/\/ Prints \"January\" console.log(spanish.format(january)); \/\/ Prints \"M01\" on small-icu \/\/ Should print \"enero\"  This mode provides a balance between features and binary size."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_providing_icu_data_at_runtime","title":"Providing ICU data at runtime","description":"If the small-icu option is used, one can still provide additional locale data at runtime so that the JS methods would work for all ICU locales. Assuming the data file is stored at \/some\/directory, it can be made available to ICU through either:   The NODE_ICU_DATA environment variable: env NODE_ICU_DATA=\/some\/directory node    The --icu-data-dir CLI parameter: node --icu-data-dir=\/some\/directory    (If both are specified, the --icu-data-dir CLI parameter takes precedence.) ICU is able to automatically find and load a variety of data formats, but the data must be appropriate for the ICU version, and the file correctly named. The most common name for the data file is icudt6X[bl].dat, where 6X denotes the intended ICU version, and b or l indicates the system's endianness. Check \"ICU Data\" article in the ICU User Guide for other supported formats and more details on ICU data in general. The full-icu npm module can greatly simplify ICU data installation by detecting the ICU version of the running node executable and downloading the appropriate data file. After installing the module through npm i full-icu, the data file will be available at .\/node_modules\/full-icu. This path can be then passed either to NODE_ICU_DATA or --icu-data-dir as shown above to enable full Intl support."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_embed_the_entire_icu_full_icu","title":"Embed the entire ICU (`full-icu`)","description":"This option makes the resulting binary link against ICU statically and include a full set of ICU data. A binary created this way has no further external dependencies and supports all locales, but might be rather large. This is the default behavior if no --with-intl flag is passed. The official binaries are also built in this mode."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_detecting_internationalization_support","title":"Detecting internationalization support","description":"To verify that ICU is enabled at all (system-icu, small-icu, or full-icu), simply checking the existence of Intl should suffice: const hasICU = typeof Intl === 'object';  Alternatively, checking for process.versions.icu, a property defined only when ICU is enabled, works too: const hasICU = typeof process.versions.icu === 'string';  To check for support for a non-English locale (i.e. full-icu or system-icu), Intl.DateTimeFormat can be a good distinguishing factor: const hasFullICU = (() => {   try {     const january = new Date(9e8);     const spanish = new Intl.DateTimeFormat('es', { month: 'long' });     return spanish.format(january) === 'enero';   } catch (err) {     return false;   } })();  For more verbose tests for Intl support, the following resources may be found to be helpful:  btest402: Generally used to check whether Node.js with Intl support is built correctly. Test262: ECMAScript's official conformance test suite includes a section dedicated to ECMA-402."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_modules_ecmascript_modules","title":"Modules: ECMAScript modules","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_introduction","title":"Introduction","description":"ECMAScript modules are the official standard format to package JavaScript code for reuse. Modules are defined using a variety of import and export statements. The following example of an ES module exports a function: \/\/ addTwo.mjs function addTwo(num) {   return num + 2; }  export { addTwo };  The following example of an ES module imports the function from addTwo.mjs: \/\/ app.mjs import { addTwo } from '.\/addTwo.mjs';  \/\/ Prints: 6 console.log(addTwo(4));  Node.js fully supports ECMAScript modules as they are currently specified and provides limited interoperability between them and the existing module format, CommonJS. Node.js contains support for ES Modules based upon the Node.js EP for ES Modules and the ECMAScript-modules implementation. Expect major changes in the implementation including interoperability support, specifier resolution, and default behavior."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_enabling","title":"Enabling","description":"Node.js treats JavaScript code as CommonJS modules by default. Authors can tell Node.js to treat JavaScript code as ECMAScript modules via the .mjs file extension, the package.json \"type\" field, or the --input-type flag. See Modules: Packages for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_packages","title":"Packages","description":"This section was moved to Modules: Packages."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_import_specifiers","title":"`import` Specifiers","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_terminology","title":"Terminology","description":"The specifier of an import statement is the string after the from keyword, e.g. 'path' in import { sep } from 'path'. Specifiers are also used in export from statements, and as the argument to an import() expression. There are four types of specifiers:   Bare specifiers like 'some-package'. They refer to an entry point of a package by the package name.   Deep import specifiers like 'some-package\/lib\/shuffle.mjs'. They refer to a path within a package prefixed by the package name.   Relative specifiers like '.\/startup.js' or '..\/config.mjs'. They refer to a path relative to the location of the importing file.   Absolute specifiers like 'file:\/\/\/opt\/nodejs\/config.js'. They refer directly and explicitly to a full path.   Bare specifiers, and the bare specifier portion of deep import specifiers, are strings; but everything else in a specifier is a URL. file:, node:, and data: URLs are supported. A specifier like 'https:\/\/example.com\/app.js' may be supported by browsers but it is not supported in Node.js. Specifiers may not begin with \/ or \/\/. These are reserved for potential future use. The root of the current volume may be referenced via file:\/\/\/."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_imports","title":"`node:` Imports","description":"node: URLs are supported as a means to load Node.js builtin modules. This URL scheme allows for builtin modules to be referenced by valid absolute URL strings. import fs from 'node:fs\/promises';"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_data_imports","title":"`data:` Imports","description":"data: URLs are supported for importing with the following MIME types:  text\/javascript for ES Modules application\/json for JSON application\/wasm for Wasm  data: URLs only resolve Bare specifiers for builtin modules and Absolute specifiers. Resolving Relative specifiers does not work because data: is not a special scheme. For example, attempting to load .\/foo from data:text\/javascript,import \".\/foo\"; fails to resolve because there is no concept of relative resolution for data: URLs. An example of a data: URLs being used is: import 'data:text\/javascript,console.log(\"hello!\");'; import _ from 'data:application\/json,\"world!\"';"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_differences_between_es_modules_and_commonjs","title":"Differences between ES modules and CommonJS","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_mandatory_file_extensions","title":"Mandatory file extensions","description":"A file extension must be provided when using the import keyword. Directory indexes (e.g. '.\/startup\/index.js') must also be fully specified. This behavior matches how import behaves in browser environments, assuming a typically configured server."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_node_path","title":"No `NODE_PATH`","description":"NODE_PATH is not part of resolving import specifiers. Please use symlinks if this behavior is desired."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_require_exports_module_exports__filename__dirname","title":"No `require`, `exports`, `module.exports`, `__filename`, `__dirname`","description":"These CommonJS variables are not available in ES modules. require can be imported into an ES module using module.createRequire(). Equivalents of __filename and __dirname can be created inside of each file via import.meta.url. import { fileURLToPath } from 'url'; import { dirname } from 'path';  const __filename = fileURLToPath(import.meta.url); const __dirname = dirname(__filename);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_require_resolve","title":"No `require.resolve`","description":"Former use cases relying on require.resolve to determine the resolved path of a module can be supported via import.meta.resolve, which is experimental and supported via the --experimental-import-meta-resolve flag: (async () => {   const dependencyAsset = await import.meta.resolve('component-lib\/asset.css'); })();  import.meta.resolve also accepts a second argument which is the parent module from which to resolve from: (async () => {   \/\/ Equivalent to import.meta.resolve('.\/dep')   await import.meta.resolve('.\/dep', import.meta.url); })();  This function is asynchronous because the ES module resolver in Node.js is asynchronous. With the introduction of Top-Level Await, these use cases will be easier as they won't require an async function wrapper."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_require_extensions","title":"No `require.extensions`","description":"require.extensions is not used by import. The expectation is that loader hooks can provide this workflow in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_no_require_cache","title":"No `require.cache`","description":"require.cache is not used by import. It has a separate cache."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_based_paths","title":"URL-based paths","description":"ES modules are resolved and cached based upon URL semantics. This means that files containing special characters such as # and ? need to be escaped. Modules are loaded multiple times if the import specifier used to resolve them has a different query or fragment. import '.\/foo.mjs?query=1'; \/\/ loads .\/foo.mjs with query of \"?query=1\" import '.\/foo.mjs?query=2'; \/\/ loads .\/foo.mjs with query of \"?query=2\"  For now, only modules using the file: protocol can be loaded."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_interoperability_with_commonjs","title":"Interoperability with CommonJS","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require","title":"`require`","description":"require always treats the files it references as CommonJS. This applies whether require is used the traditional way within a CommonJS environment, or in an ES module environment using module.createRequire(). To include an ES module into CommonJS, use import()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_import_statements","title":"`import` statements","description":"An import statement can reference an ES module or a CommonJS module. import statements are permitted only in ES modules. For similar functionality in CommonJS, see import(). When importing CommonJS modules, the module.exports object is provided as the default export. Named exports may be available, provided by static analysis as a convenience for better ecosystem compatibility. Additional experimental flags are available for importing Wasm modules or JSON modules. For importing native modules or JSON modules unflagged, see module.createRequire(). The specifier of an import statement (the string after the from keyword) can either be an URL-style relative path like '.\/file.mjs' or a package name like 'fs'. Like in CommonJS, files within packages can be accessed by appending a path to the package name; unless the package\u2019s package.json contains an \"exports\" field, in which case files within packages need to be accessed via the path defined in \"exports\". import { sin, cos } from 'geometry\/trigonometry-functions.mjs';"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_import_expressions","title":"`import()` expressions","description":"Dynamic import() is supported in both CommonJS and ES modules. It can be used to include ES module files from CommonJS code."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_commonjs_namespaces","title":"CommonJS Namespaces","description":"CommonJS modules consist of a module.exports object which can be of any type. When importing a CommonJS module, it can be reliably imported using the ES module default import or its corresponding sugar syntax:  import { default as cjs } from 'cjs';  \/\/ The following import statement is \"syntax sugar\" (equivalent but sweeter) \/\/ for `{ default as cjsSugar }` in the above import statement: import cjsSugar from 'cjs';  console.log(cjs); console.log(cjs === cjsSugar); \/\/ Prints: \/\/   <module.exports> \/\/   true  The ECMAScript Module Namespace representation of a CommonJS module is always a namespace with a default export key pointing to the CommonJS module.exports value. This Module Namespace Exotic Object can be directly observed either when using import * as m from 'cjs' or a dynamic import:  import * as m from 'cjs'; console.log(m); console.log(m === await import('cjs')); \/\/ Prints: \/\/   [Module] { default: <module.exports> } \/\/   true  For better compatibility with existing usage in the JS ecosystem, Node.js in addition attempts to determine the CommonJS named exports of every imported CommonJS module to provide them as separate ES module exports using a static analysis process. For example, consider a CommonJS module written: \/\/ cjs.cjs exports.name = 'exported';  The preceding module supports named imports in ES modules:  import { name } from '.\/cjs.cjs'; console.log(name); \/\/ Prints: 'exported'  import cjs from '.\/cjs.cjs'; console.log(cjs); \/\/ Prints: { name: 'exported' }  import * as m from '.\/cjs.cjs'; console.log(m); \/\/ Prints: [Module] { default: { name: 'exported' }, name: 'exported' }  As can be seen from the last example of the Module Namespace Exotic Object being logged, the name export is copied off of the module.exports object and set directly on the ES module namespace when the module is imported. Live binding updates or new exports added to module.exports are not detected for these named exports. The detection of named exports is based on common syntax patterns but does not always correctly detect named exports. In these cases, using the default import form described above can be a better option. Named exports detection covers many common export patterns, reexport patterns and build tool and transpiler outputs. See cjs-module-lexer for the exact semantics implemented."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_builtin_modules","title":"Builtin modules","description":"Core modules provide named exports of their public API. A default export is also provided which is the value of the CommonJS exports. The default export can be used for, among other things, modifying the named exports. Named exports of builtin modules are updated only by calling module.syncBuiltinESMExports(). import EventEmitter from 'events'; const e = new EventEmitter();  import { readFile } from 'fs'; readFile('.\/foo.txt', (err, source) => {   if (err) {     console.error(err);   } else {     console.log(source);   } });  import fs, { readFileSync } from 'fs'; import { syncBuiltinESMExports } from 'module';  fs.readFileSync = () => Buffer.from('Hello, ESM'); syncBuiltinESMExports();  fs.readFileSync === readFileSync;"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_commonjs_json_and_native_modules","title":"CommonJS, JSON, and native modules","description":"CommonJS, JSON, and native modules can be used with module.createRequire(). \/\/ cjs.cjs module.exports = 'cjs';  \/\/ esm.mjs import { createRequire } from 'module';  const require = createRequire(import.meta.url);  const cjs = require('.\/cjs.cjs'); cjs === 'cjs'; \/\/ true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_json_modules","title":"Experimental JSON modules","description":"Currently importing JSON modules are only supported in the commonjs mode and are loaded using the CJS loader. WHATWG JSON modules specification are still being standardized, and are experimentally supported by including the additional flag --experimental-json-modules when running Node.js. When the --experimental-json-modules flag is included, both the commonjs and module mode use the new experimental JSON loader. The imported JSON only exposes a default. There is no support for named exports. A cache entry is created in the CommonJS cache to avoid duplication. The same object is returned in CommonJS if the JSON module has already been imported from the same path. Assuming an index.mjs with  import packageConfig from '.\/package.json';  The --experimental-json-modules flag is needed for the module to work. node index.mjs # fails node --experimental-json-modules index.mjs # works"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_wasm_modules","title":"Experimental Wasm modules","description":"Importing Web Assembly modules is supported under the --experimental-wasm-modules flag, allowing any .wasm files to be imported as normal modules while also supporting their module imports. This integration is in line with the ES Module Integration Proposal for Web Assembly. For example, an index.mjs containing: import * as M from '.\/module.wasm'; console.log(M);  executed under: node --experimental-wasm-modules index.mjs  would provide the exports interface for the instantiation of module.wasm."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_top_level_await","title":"Experimental top-level `await`","description":"The await keyword may be used in the top level (outside of async functions) within modules as per the ECMAScript Top-Level await proposal. Assuming an a.mjs with  export const five = await Promise.resolve(5);  And a b.mjs with import { five } from '.\/a.mjs';  console.log(five); \/\/ Logs `5`  node b.mjs # works"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_experimental_loaders","title":"Experimental loaders","description":"Note: This API is currently being redesigned and will still change. To customize the default module resolution, loader hooks can optionally be provided via a --experimental-loader .\/loader-name.mjs argument to Node.js. When hooks are used they only apply to ES module loading and not to any CommonJS modules loaded."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_hooks","title":"Hooks","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_resolve_specifier_context_defaultresolve","title":"`resolve(specifier, context, defaultResolve)`","description":"Note: The loaders API is being redesigned. This hook may disappear or its signature may change. Do not rely on the API described below.   specifier <string> context <Object>  conditions <string[]> parentURL <string>   defaultResolve <Function> Returns: <Object>  url <string>    The resolve hook returns the resolved file URL for a given module specifier and parent URL. The module specifier is the string in an import statement or import() expression, and the parent URL is the URL of the module that imported this one, or undefined if this is the main entry point for the application. The conditions property on the context is an array of conditions for Conditional exports that apply to this resolution request. They can be used for looking up conditional mappings elsewhere or to modify the list when calling the default resolution logic. The current package exports conditions are always in the context.conditions array passed into the hook. To guarantee default Node.js module specifier resolution behavior when calling defaultResolve, the context.conditions array passed to it must include all elements of the context.conditions array originally passed into the resolve hook. \/**  * @param {string} specifier  * @param {{  *   conditions: !Array<string>,  *   parentURL: !(string | undefined),  * }} context  * @param {Function} defaultResolve  * @returns {Promise<{ url: string }>}  *\/ export async function resolve(specifier, context, defaultResolve) {   const { parentURL = null } = context;   if (Math.random() > 0.5) { \/\/ Some condition.     \/\/ For some or all specifiers, do some custom logic for resolving.     \/\/ Always return an object of the form {url: <string>}.     return {       url: parentURL ?         new URL(specifier, parentURL).href :         new URL(specifier).href,     };   }   if (Math.random() < 0.5) { \/\/ Another condition.     \/\/ When calling `defaultResolve`, the arguments can be modified. In this     \/\/ case it's adding another value for matching conditional exports.     return defaultResolve(specifier, {       ...context,       conditions: [...context.conditions, 'another-condition'],     });   }   \/\/ Defer to Node.js for all other specifiers.   return defaultResolve(specifier, context, defaultResolve); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_getformat_url_context_defaultgetformat","title":"`getFormat(url, context, defaultGetFormat)`","description":"Note: The loaders API is being redesigned. This hook may disappear or its signature may change. Do not rely on the API described below.   url <string> context <Object> defaultGetFormat <Function> Returns: <Object>  format <string>    The getFormat hook provides a way to define a custom method of determining how a URL should be interpreted. The format returned also affects what the acceptable forms of source values are for a module when parsing. This can be one of the following:    format Description Acceptable Types For source Returned by getSource or transformSource     'builtin' Load a Node.js builtin module Not applicable   'commonjs' Load a Node.js CommonJS module Not applicable   'json' Load a JSON file { string, ArrayBuffer, TypedArray }   'module' Load an ES module { string, ArrayBuffer, TypedArray }   'wasm' Load a WebAssembly module { ArrayBuffer, TypedArray }    Note: These types all correspond to classes defined in ECMAScript.  The specific ArrayBuffer object is a SharedArrayBuffer. The specific TypedArray object is a Uint8Array.  Note: If the source value of a text-based format (i.e., 'json', 'module') is not a string, it is converted to a string using util.TextDecoder. \/**  * @param {string} url  * @param {Object} context (currently empty)  * @param {Function} defaultGetFormat  * @returns {Promise<{ format: string }>}  *\/ export async function getFormat(url, context, defaultGetFormat) {   if (Math.random() > 0.5) { \/\/ Some condition.     \/\/ For some or all URLs, do some custom logic for determining format.     \/\/ Always return an object of the form {format: <string>}, where the     \/\/ format is one of the strings in the preceding table.     return {       format: 'module',     };   }   \/\/ Defer to Node.js for all other URLs.   return defaultGetFormat(url, context, defaultGetFormat); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_getsource_url_context_defaultgetsource","title":"`getSource(url, context, defaultGetSource)`","description":"Note: The loaders API is being redesigned. This hook may disappear or its signature may change. Do not rely on the API described below.   url <string> context <Object>  format <string>   defaultGetSource <Function> Returns: <Object>  source <string> | <SharedArrayBuffer> | <Uint8Array>    The getSource hook provides a way to define a custom method for retrieving the source code of an ES module specifier. This would allow a loader to potentially avoid reading files from disk. \/**  * @param {string} url  * @param {{ format: string }} context  * @param {Function} defaultGetSource  * @returns {Promise<{ source: !(string | SharedArrayBuffer | Uint8Array) }>}  *\/ export async function getSource(url, context, defaultGetSource) {   const { format } = context;   if (Math.random() > 0.5) { \/\/ Some condition.     \/\/ For some or all URLs, do some custom logic for retrieving the source.     \/\/ Always return an object of the form {source: <string|buffer>}.     return {       source: '...',     };   }   \/\/ Defer to Node.js for all other URLs.   return defaultGetSource(url, context, defaultGetSource); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_transformsource_source_context_defaulttransformsource","title":"`transformSource(source, context, defaultTransformSource)`","description":"Note: The loaders API is being redesigned. This hook may disappear or its signature may change. Do not rely on the API described below.   source <string> | <SharedArrayBuffer> | <Uint8Array> context <Object>  format <string> url <string>   Returns: <Object>  source <string> | <SharedArrayBuffer> | <Uint8Array>    The transformSource hook provides a way to modify the source code of a loaded ES module file after the source string has been loaded but before Node.js has done anything with it. If this hook is used to convert unknown-to-Node.js file types into executable JavaScript, a resolve hook is also necessary in order to register any unknown-to-Node.js file extensions. See the transpiler loader example below. \/**  * @param {!(string | SharedArrayBuffer | Uint8Array)} source  * @param {{  *   format: string,  *   url: string,  * }} context  * @param {Function} defaultTransformSource  * @returns {Promise<{ source: !(string | SharedArrayBuffer | Uint8Array) }>}  *\/ export async function transformSource(source, context, defaultTransformSource) {   const { url, format } = context;   if (Math.random() > 0.5) { \/\/ Some condition.     \/\/ For some or all URLs, do some custom logic for modifying the source.     \/\/ Always return an object of the form {source: <string|buffer>}.     return {       source: '...',     };   }   \/\/ Defer to Node.js for all other sources.   return defaultTransformSource(source, context, defaultTransformSource); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_getglobalpreloadcode","title":"`getGlobalPreloadCode()`","description":"Note: The loaders API is being redesigned. This hook may disappear or its signature may change. Do not rely on the API described below.   Returns: <string>  Sometimes it might be necessary to run some code inside of the same global scope that the application runs in. This hook allows the return of a string that is run as sloppy-mode script on startup. Similar to how CommonJS wrappers work, the code runs in an implicit function scope. The only argument is a require-like function that can be used to load builtins like \"fs\": getBuiltin(request: string). If the code needs more advanced require features, it has to construct its own require using  module.createRequire(). \/**  * @returns {string} Code to run before application startup  *\/ export function getGlobalPreloadCode() {   return `\\ globalThis.someInjectedProperty = 42; console.log('I just set some globals!');  const { createRequire } = getBuiltin('module');  const require = createRequire(process.cwd() + '\/<preload>'); \/\/ [...] `; }  Examples The various loader hooks can be used together to accomplish wide-ranging customizations of Node.js\u2019 code loading and evaluation behaviors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_loader","title":"HTTPS loader","description":"In current Node.js, specifiers starting with https:\/\/ are unsupported. The loader below registers hooks to enable rudimentary support for such specifiers. While this may seem like a significant improvement to Node.js core functionality, there are substantial downsides to actually using this loader: performance is much slower than loading files from disk, there is no caching, and there is no security. \/\/ https-loader.mjs import { get } from 'https';  export function resolve(specifier, context, defaultResolve) {   const { parentURL = null } = context;    \/\/ Normally Node.js would error on specifiers starting with 'https:\/\/', so   \/\/ this hook intercepts them and converts them into absolute URLs to be   \/\/ passed along to the later hooks below.   if (specifier.startsWith('https:\/\/')) {     return {       url: specifier     };   } else if (parentURL && parentURL.startsWith('https:\/\/')) {     return {       url: new URL(specifier, parentURL).href     };   }    \/\/ Let Node.js handle all other specifiers.   return defaultResolve(specifier, context, defaultResolve); }  export function getFormat(url, context, defaultGetFormat) {   \/\/ This loader assumes all network-provided JavaScript is ES module code.   if (url.startsWith('https:\/\/')) {     return {       format: 'module'     };   }    \/\/ Let Node.js handle all other URLs.   return defaultGetFormat(url, context, defaultGetFormat); }  export function getSource(url, context, defaultGetSource) {   \/\/ For JavaScript to be loaded over the network, we need to fetch and   \/\/ return it.   if (url.startsWith('https:\/\/')) {     return new Promise((resolve, reject) => {       get(url, (res) => {         let data = '';         res.on('data', (chunk) => data += chunk);         res.on('end', () => resolve({ source: data }));       }).on('error', (err) => reject(err));     });   }    \/\/ Let Node.js handle all other URLs.   return defaultGetSource(url, context, defaultGetSource); }  \/\/ main.mjs import { VERSION } from 'https:\/\/coffeescript.org\/browser-compiler-modern\/coffeescript.js';  console.log(VERSION);  With the preceding loader, running node --experimental-loader .\/https-loader.mjs .\/main.mjs prints the current version of CoffeeScript per the module at the URL in main.mjs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_transpiler_loader","title":"Transpiler loader","description":"Sources that are in formats Node.js doesn\u2019t understand can be converted into JavaScript using the transformSource hook. Before that hook gets called, however, other hooks need to tell Node.js not to throw an error on unknown file types; and to tell Node.js how to load this new file type. This is less performant than transpiling source files before running Node.js; a transpiler loader should only be used for development and testing purposes. \/\/ coffeescript-loader.mjs import { URL, pathToFileURL } from 'url'; import CoffeeScript from 'coffeescript';  const baseURL = pathToFileURL(`${process.cwd()}\/`).href;  \/\/ CoffeeScript files end in .coffee, .litcoffee or .coffee.md. const extensionsRegex = \/\\.coffee$|\\.litcoffee$|\\.coffee\\.md$\/;  export function resolve(specifier, context, defaultResolve) {   const { parentURL = baseURL } = context;    \/\/ Node.js normally errors on unknown file extensions, so return a URL for   \/\/ specifiers ending in the CoffeeScript file extensions.   if (extensionsRegex.test(specifier)) {     return {       url: new URL(specifier, parentURL).href     };   }    \/\/ Let Node.js handle all other specifiers.   return defaultResolve(specifier, context, defaultResolve); }  export function getFormat(url, context, defaultGetFormat) {   \/\/ Now that we patched resolve to let CoffeeScript URLs through, we need to   \/\/ tell Node.js what format such URLs should be interpreted as. For the   \/\/ purposes of this loader, all CoffeeScript URLs are ES modules.   if (extensionsRegex.test(url)) {     return {       format: 'module'     };   }    \/\/ Let Node.js handle all other URLs.   return defaultGetFormat(url, context, defaultGetFormat); }  export function transformSource(source, context, defaultTransformSource) {   const { url, format } = context;    if (extensionsRegex.test(url)) {     return {       source: CoffeeScript.compile(source, { bare: true })     };   }    \/\/ Let Node.js handle all other sources.   return defaultTransformSource(source, context, defaultTransformSource); }  # main.coffee import { scream } from '.\/scream.coffee' console.log scream 'hello, world'  import { version } from 'process' console.log \"Brought to you by Node.js version #{version}\"  # scream.coffee export scream = (str) -> str.toUpperCase()  With the preceding loader, running node --experimental-loader .\/coffeescript-loader.mjs main.coffee causes main.coffee to be turned into JavaScript after its source code is loaded from disk but before Node.js executes it; and so on for any .coffee, .litcoffee or .coffee.md files referenced via import statements of any loaded file."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_resolution_algorithm","title":"Resolution algorithm","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_features","title":"Features","description":"The resolver has the following properties:  FileURL-based resolution as is used by ES modules Support for builtin module loading Relative and absolute URL resolution No default extensions No folder mains Bare specifier package resolution lookup through node_modules"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_resolver_algorithm","title":"Resolver algorithm","description":"The algorithm to load an ES module specifier is given through the ESM_RESOLVE method below. It returns the resolved URL for a module specifier relative to a parentURL. The algorithm to determine the module format of a resolved URL is provided by ESM_FORMAT, which returns the unique module format for any file. The \"module\" format is returned for an ECMAScript Module, while the \"commonjs\" format is used to indicate loading through the legacy CommonJS loader. Additional formats such as \"addon\" can be extended in future updates. In the following algorithms, all subroutine errors are propagated as errors of these top-level routines unless stated otherwise. defaultConditions is the conditional environment name array, [\"node\", \"import\"]. The resolver can throw the following errors:  Invalid Module Specifier: Module specifier is an invalid URL, package name or package subpath specifier. Invalid Package Configuration: package.json configuration is invalid or contains an invalid configuration. Invalid Package Target: Package exports or imports define a target module for the package that is an invalid type or string target. Package Path Not Exported: Package exports do not define or permit a target subpath in the package for the given module. Package Import Not Defined: Package imports do not define the specifier. Module Not Found: The package or module requested does not exist."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_resolver_algorithm_specification","title":"Resolver Algorithm Specification","description":"ESM_RESOLVE(specifier, parentURL)   Let resolved be undefined. If specifier is a valid URL, then  Set resolved to the result of parsing and reserializing specifier as a URL.   Otherwise, if specifier starts with \"\/\", \".\/\" or \"..\/\", then  Set resolved to the URL resolution of specifier relative to parentURL.   Otherwise, if specifier starts with \"#\", then  Set resolved to the destructured value of the result of PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, defaultConditions).   Otherwise,  Note: specifier is now a bare specifier. Set resolved the result of PACKAGE_RESOLVE(specifier, parentURL).   If resolved contains any percent encodings of \"\/\" or \"\\\" (\"%2f\" and \"%5C\" respectively), then  Throw an Invalid Module Specifier error.   If the file at resolved is a directory, then  Throw an Unsupported Directory Import error.   If the file at resolved does not exist, then  Throw a Module Not Found error.   Set resolved to the real path of resolved. Let format be the result of ESM_FORMAT(resolved). Load resolved as module format, format. Return resolved.   PACKAGE_RESOLVE(packageSpecifier, parentURL)   Let packageName be undefined. If packageSpecifier is an empty string, then  Throw an Invalid Module Specifier error.   If packageSpecifier does not start with \"@\", then  Set packageName to the substring of packageSpecifier until the first \"\/\" separator or the end of the string.   Otherwise,  If packageSpecifier does not contain a \"\/\" separator, then  Throw an Invalid Module Specifier error.   Set packageName to the substring of packageSpecifier until the second \"\/\" separator or the end of the string.   If packageName starts with \".\" or contains \"\\\" or \"%\", then  Throw an Invalid Module Specifier error.   Let packageSubpath be \".\" concatenated with the substring of packageSpecifier from the position at the length of packageName. Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL). If selfUrl is not undefined, return selfUrl. If packageSubpath is \".\" and packageName is a Node.js builtin module, then  Return the string \"node:\" concatenated with packageSpecifier.   While parentURL is not the file system root,  Let packageURL be the URL resolution of \"node_modules\/\" concatenated with packageSpecifier, relative to parentURL. Set parentURL to the parent folder URL of parentURL. If the folder at packageURL does not exist, then  Set parentURL to the parent URL path of parentURL. Continue the next loop iteration.   Let pjson be the result of READ_PACKAGE_JSON(packageURL). If pjson is not null and pjson.exports is not null or undefined, then  Let exports be pjson.exports. Return the resolved destructured value of the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).   Otherwise, if packageSubpath is equal to \".\", then  Return the result applying the legacy LOAD_AS_DIRECTORY CommonJS resolver to packageURL, throwing a Module Not Found error for no resolution.   Otherwise,  Return the URL resolution of packageSubpath in packageURL.     Throw a Module Not Found error.   PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL)   Let packageURL be the result of READ_PACKAGE_SCOPE(parentURL). If packageURL is null, then  Return undefined.   Let pjson be the result of READ_PACKAGE_JSON(packageURL). If pjson is null or if pjson.exports is null or undefined, then  Return undefined.   If pjson.name is equal to packageName, then  Return the resolved destructured value of the result of PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, pjson.exports, defaultConditions).   Otherwise, return undefined.   PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)   If exports is an Object with both a key starting with \".\" and a key not starting with \".\", throw an Invalid Package Configuration error. If subpath is equal to \".\", then  Let mainExport be undefined. If exports is a String or Array, or an Object containing no keys starting with \".\", then  Set mainExport to exports.   Otherwise if exports is an Object containing a \".\" property, then  Set mainExport to exports[\".\"].   If mainExport is not undefined, then  Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, \"\", false, false, conditions). If resolved is not null or undefined, then  Return resolved.       Otherwise, if exports is an Object and all keys of exports start with \".\", then  Let matchKey be the string \".\/\" concatenated with subpath. Let resolvedMatch be result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( matchKey, exports, packageURL, false, conditions). If resolvedMatch.resolve is not null or undefined, then  Return resolvedMatch.     Throw a Package Path Not Exported error.   PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)   Assert: specifier begins with \"#\". If specifier is exactly equal to \"#\" or starts with \"#\/\", then  Throw an Invalid Module Specifier error.   Let packageURL be the result of READ_PACKAGE_SCOPE(parentURL). If packageURL is not null, then  Let pjson be the result of READ_PACKAGE_JSON(packageURL). If pjson.imports is a non-null Object, then  Let resolvedMatch be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE(specifier, pjson.imports, packageURL, true, conditions). If resolvedMatch.resolve is not null or undefined, then  Return resolvedMatch.       Throw a Package Import Not Defined error.   PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports, conditions)   If matchKey is a key of matchObj, and does not end in \"*\", then  Let target be the value of matchObj[matchKey]. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, target, \"\", false, isImports, conditions). Return the object { resolved, exact: true }.   Let expansionKeys be the list of keys of matchObj ending in \"\/\" or \"*\", sorted by length descending. For each key expansionKey in expansionKeys, do  If expansionKey ends in \"*\" and matchKey starts with but is not equal to the substring of expansionKey excluding the last \"*\" character, then  Let target be the value of matchObj[expansionKey]. Let subpath be the substring of matchKey starting at the index of the length of expansionKey minus one. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, target, subpath, true, isImports, conditions). Return the object { resolved, exact: true }.   If matchKey starts with expansionKey, then  Let target be the value of matchObj[expansionKey]. Let subpath be the substring of matchKey starting at the index of the length of expansionKey. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, target, subpath, false, isImports, conditions). Return the object { resolved, exact: false }.     Return the object { resolved: null, exact: true }.   PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, pattern, internal, conditions)   If target is a String, then  If pattern is false, subpath has non-zero length and target does not end with \"\/\", throw an Invalid Module Specifier error. If target does not start with \".\/\", then  If internal is true and target does not start with \"..\/\" or \"\/\" and is not a valid URL, then  If pattern is true, then  Return PACKAGE_RESOLVE(target with every instance of \"*\" replaced by subpath, packageURL + \"\/\")_.   Return PACKAGE_RESOLVE(target + subpath, packageURL + \"\/\")_.   Otherwise, throw an Invalid Package Target error.   If target split on \"\/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments after the first segment, throw an Invalid Package Target error. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target. Assert: resolvedTarget is contained in packageURL. If subpath split on \"\/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments, throw an Invalid Module Specifier error. If pattern is true, then  Return the URL resolution of resolvedTarget with every instance of \"*\" replaced with subpath.   Otherwise,  Return the URL resolution of the concatenation of subpath and resolvedTarget.     Otherwise, if target is a non-null Object, then  If exports contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error. For each property p of target, in object insertion order as,  If p equals \"default\" or conditions contains an entry for p, then  Let targetValue be the value of the p property in target. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions). If resolved is equal to undefined, continue the loop. Return resolved.     Return undefined.   Otherwise, if target is an Array, then  If _target.length is zero, return null. For each item targetValue in target, do  Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions), continuing the loop on any Invalid Package Target error. If resolved is undefined, continue the loop. Return resolved.   Return or throw the last fallback resolution null return or error.   Otherwise, if target is null, return null. Otherwise throw an Invalid Package Target error.   ESM_FORMAT(url)   Assert: url corresponds to an existing file. Let pjson be the result of READ_PACKAGE_SCOPE(url). If url ends in \".mjs\", then  Return \"module\".   If url ends in \".cjs\", then  Return \"commonjs\".   If pjson?.type exists and is \"module\", then  If url ends in \".js\", then  Return \"module\".   Throw an Unsupported File Extension error.   Otherwise,  Throw an Unsupported File Extension error.     READ_PACKAGE_SCOPE(url)   Let scopeURL be url. While scopeURL is not the file system root,  Set scopeURL to the parent URL of scopeURL. If scopeURL ends in a \"node_modules\" path segment, return null. Let pjson be the result of READ_PACKAGE_JSON(scopeURL). If pjson is not null, then  Return pjson.     Return null.   READ_PACKAGE_JSON(packageURL)   Let pjsonURL be the resolution of \"package.json\" within packageURL. If the file at pjsonURL does not exist, then  Return null.   If the file at packageURL does not parse as valid JSON, then  Throw an Invalid Package Configuration error.   Return the parsed JSON source of the file at pjsonURL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_customizing_esm_specifier_resolution_algorithm","title":"Customizing ESM specifier resolution algorithm","description":"The current specifier resolution does not support all default behavior of the CommonJS loader. One of the behavior differences is automatic resolution of file extensions and the ability to import directories that have an index file. The --experimental-specifier-resolution=[mode] flag can be used to customize the extension resolution algorithm. The default mode is explicit, which requires the full path to a module be provided to the loader. To enable the automatic extension resolution and importing from directories that include an index file use the node mode. $ node index.mjs success! $ node index # Failure! Error: Cannot find module $ node --experimental-specifier-resolution=node index success!"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_modules_packages","title":"Modules: Packages","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_introduction","title":"Introduction","description":"A package is a folder tree described by a package.json file. The package consists of the folder containing the package.json file and all subfolders until the next folder containing another package.json file, or a folder named node_modules. This page provides guidance for package authors writing package.json files along with a reference for the package.json fields defined by Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_determining_module_system","title":"Determining module system","description":"Node.js will treat the following as ES modules when passed to node as the initial input, or when referenced by import statements within ES module code:   Files ending in .mjs.   Files ending in .js when the nearest parent package.json file contains a top-level \"type\" field with a value of \"module\".   Strings passed in as an argument to --eval, or piped to node via STDIN, with the flag --input-type=module.   Node.js will treat as CommonJS all other forms of input, such as .js files where the nearest parent package.json file contains no top-level \"type\" field, or string input without the flag --input-type. This behavior is to preserve backward compatibility. However, now that Node.js supports both CommonJS and ES modules, it is best to be explicit whenever possible. Node.js will treat the following as CommonJS when passed to node as the initial input, or when referenced by import statements within ES module code:   Files ending in .cjs.   Files ending in .js when the nearest parent package.json file contains a top-level field \"type\" with a value of \"commonjs\".   Strings passed in as an argument to --eval or --print, or piped to node via STDIN, with the flag --input-type=commonjs.   Package authors should include the \"type\" field, even in packages where all sources are CommonJS. Being explicit about the type of the package will future-proof the package in case the default type of Node.js ever changes, and it will also make things easier for build tools and loaders to determine how the files in the package should be interpreted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_package_json_and_file_extensions","title":"`package.json` and file extensions","description":"Within a package, the package.json \"type\" field defines how Node.js should interpret .js files. If a package.json file does not have a \"type\" field, .js files are treated as CommonJS. A package.json \"type\" value of \"module\" tells Node.js to interpret .js files within that package as using ES module syntax. The \"type\" field applies not only to initial entry points (node my-app.js) but also to files referenced by import statements and import() expressions. \/\/ my-app.js, treated as an ES module because there is a package.json \/\/ file in the same folder with \"type\": \"module\".  import '.\/startup\/init.js'; \/\/ Loaded as ES module since .\/startup contains no package.json file, \/\/ and therefore inherits the \"type\" value from one level up.  import 'commonjs-package'; \/\/ Loaded as CommonJS since .\/node_modules\/commonjs-package\/package.json \/\/ lacks a \"type\" field or contains \"type\": \"commonjs\".  import '.\/node_modules\/commonjs-package\/index.js'; \/\/ Loaded as CommonJS since .\/node_modules\/commonjs-package\/package.json \/\/ lacks a \"type\" field or contains \"type\": \"commonjs\".  Files ending with .mjs are always loaded as ES modules regardless of the nearest parent package.json. Files ending with .cjs are always loaded as CommonJS regardless of the nearest parent package.json. import '.\/legacy-file.cjs'; \/\/ Loaded as CommonJS since .cjs is always loaded as CommonJS.  import 'commonjs-package\/src\/index.mjs'; \/\/ Loaded as ES module since .mjs is always loaded as ES module.  The .mjs and .cjs extensions can be used to mix types within the same package:   Within a \"type\": \"module\" package, Node.js can be instructed to interpret a particular file as CommonJS by naming it with a .cjs extension (since both .js and .mjs files are treated as ES modules within a \"module\" package).   Within a \"type\": \"commonjs\" package, Node.js can be instructed to interpret a particular file as an ES module by naming it with an .mjs extension (since both .js and .cjs files are treated as CommonJS within a \"commonjs\" package)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_input_type_flag","title":"`--input-type` flag","description":"Strings passed in as an argument to --eval (or -e), or piped to node via STDIN, are treated as ES modules when the --input-type=module flag is set. node --input-type=module --eval \"import { sep } from 'path'; console.log(sep);\"  echo \"import { sep } from 'path'; console.log(sep);\" | node --input-type=module  For completeness there is also --input-type=commonjs, for explicitly running string input as CommonJS. This is the default behavior if --input-type is unspecified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_package_entry_points","title":"Package entry points","description":"In a package\u2019s package.json file, two fields can define entry points for a package: \"main\" and \"exports\". The \"main\" field is supported in all versions of Node.js, but its capabilities are limited: it only defines the main entry point of the package. The \"exports\" field provides an alternative to \"main\" where the package main entry point can be defined while also encapsulating the package, preventing any other entry points besides those defined in \"exports\". This encapsulation allows module authors to define a public interface for their package. If both \"exports\" and \"main\" are defined, the \"exports\" field takes precedence over \"main\". \"exports\" are not specific to ES modules or CommonJS; \"main\" is overridden by \"exports\" if it exists. As such \"main\" cannot be used as a fallback for CommonJS but it can be used as a fallback for legacy versions of Node.js that do not support the \"exports\" field. Conditional exports can be used within \"exports\" to define different package entry points per environment, including whether the package is referenced via require or via import. For more information about supporting both CommonJS and ES Modules in a single package please consult the dual CommonJS\/ES module packages section. Warning: Introducing the \"exports\" field prevents consumers of a package from using any entry points that are not defined, including the package.json (e.g. require('your-package\/package.json'). This will likely be a breaking change. To make the introduction of \"exports\" non-breaking, ensure that every previously supported entry point is exported. It is best to explicitly specify entry points so that the package\u2019s public API is well-defined. For example, a project that previous exported main, lib, feature, and the package.json could use the following package.exports: {   \"name\": \"my-mod\",   \"exports\": {     \".\": \".\/lib\/index.js\",     \".\/lib\": \".\/lib\/index.js\",     \".\/lib\/index\": \".\/lib\/index.js\",     \".\/lib\/index.js\": \".\/lib\/index.js\",     \".\/feature\": \".\/feature\/index.js\",     \".\/feature\/index.js\": \".\/feature\/index.js\",     \".\/package.json\": \".\/package.json\"   } }  Alternatively a project could choose to export entire folders: {   \"name\": \"my-mod\",   \"exports\": {     \".\": \".\/lib\/index.js\",     \".\/lib\": \".\/lib\/index.js\",     \".\/lib\/*\": \".\/lib\/*.js\",     \".\/feature\": \".\/feature\/index.js\",     \".\/feature\/*\": \".\/feature\/*.js\",     \".\/package.json\": \".\/package.json\"   } }  As a last resort, package encapsulation can be disabled entirely by creating an export for the root of the package \".\/*\": \".\/*\". This exposes every file in the package at the cost of disabling the encapsulation and potential tooling benefits this provides. As the ES Module loader in Node.js enforces the use of the full specifier path, exporting the root rather than being explicit about entry is less expressive than either of the prior examples. Not only is encapsulation lost but module consumers are unable to import feature from 'my-mod\/feature' as they need to provide the full path import feature from 'my-mod\/feature\/index.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_main_entry_point_export","title":"Main entry point export","description":"To set the main entry point for a package, it is advisable to define both \"exports\" and \"main\" in the package\u2019s package.json file: {   \"main\": \".\/main.js\",   \"exports\": \".\/main.js\" }  When the \"exports\" field is defined, all subpaths of the package are encapsulated and no longer available to importers. For example, require('pkg\/subpath.js') throws an ERR_PACKAGE_PATH_NOT_EXPORTED error. This encapsulation of exports provides more reliable guarantees about package interfaces for tools and when handling semver upgrades for a package. It is not a strong encapsulation since a direct require of any absolute subpath of the package such as require('\/path\/to\/node_modules\/pkg\/subpath.js') will still load subpath.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_subpath_exports","title":"Subpath exports","description":"When using the \"exports\" field, custom subpaths can be defined along with the main entry point by treating the main entry point as the \".\" subpath: {   \"main\": \".\/main.js\",   \"exports\": {     \".\": \".\/main.js\",     \".\/submodule\": \".\/src\/submodule.js\"   } }  Now only the defined subpath in \"exports\" can be imported by a consumer: import submodule from 'es-module-package\/submodule'; \/\/ Loads .\/node_modules\/es-module-package\/src\/submodule.js  While other subpaths will error: import submodule from 'es-module-package\/private-module.js'; \/\/ Throws ERR_PACKAGE_PATH_NOT_EXPORTED"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_subpath_imports","title":"Subpath imports","description":"In addition to the \"exports\" field, it is possible to define internal package import maps that only apply to import specifiers from within the package itself. Entries in the imports field must always start with # to ensure they are disambiguated from package specifiers. For example, the imports field can be used to gain the benefits of conditional exports for internal modules: \/\/ package.json {   \"imports\": {     \"#dep\": {       \"node\": \"dep-node-native\",       \"default\": \".\/dep-polyfill.js\"     }   },   \"dependencies\": {     \"dep-node-native\": \"^1.0.0\"   } }  where import '#dep' does not get the resolution of the external package dep-node-native (including its exports in turn), and instead gets the local file .\/dep-polyfill.js relative to the package in other environments. Unlike the \"exports\" field, the \"imports\" field permits mapping to external packages. The resolution rules for the imports field are otherwise analogous to the exports field."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_subpath_patterns","title":"Subpath patterns","description":"For packages with a small number of exports or imports, we recommend explicitly listing each exports subpath entry. But for packages that have large numbers of subpaths, this might cause package.json bloat and maintenance issues. For these use cases, subpath export patterns can be used instead: \/\/ .\/node_modules\/es-module-package\/package.json {   \"exports\": {     \".\/features\/*\": \".\/src\/features\/*.js\"   },   \"imports\": {     \"#internal\/*\": \".\/src\/internal\/*.js\"   } }  The left hand matching pattern must always end in *. All instances of * on the right hand side will then be replaced with this value, including if it contains any \/ separators. import featureX from 'es-module-package\/features\/x'; \/\/ Loads .\/node_modules\/es-module-package\/src\/features\/x.js  import featureY from 'es-module-package\/features\/y\/y'; \/\/ Loads .\/node_modules\/es-module-package\/src\/features\/y\/y.js  import internalZ from '#internal\/z'; \/\/ Loads .\/node_modules\/es-module-package\/src\/internal\/z.js  This is a direct static replacement without any special handling for file extensions. In the previous example, pkg\/features\/x.json would be resolved to .\/src\/features\/x.json.js in the mapping. The property of exports being statically enumerable is maintained with exports patterns since the individual exports for a package can be determined by treating the right hand side target pattern as a ** glob against the list of files within the package. Because node_modules paths are forbidden in exports targets, this expansion is dependent on only the files of the package itself."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_subpath_folder_mappings","title":"Subpath folder mappings","description":"Before subpath patterns were supported, a trailing \"\/\" suffix was used to support folder mappings: {   \"exports\": {     \".\/features\/\": \".\/features\/\"   } }  This feature will be removed in a future release. Instead, use direct subpath patterns: {   \"exports\": {     \".\/features\/*\": \".\/features\/*.js\"   } }  The benefit of patterns over folder exports is that packages can always be imported by consumers without subpath file extensions being necessary."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exports_sugar","title":"Exports sugar","description":"If the \".\" export is the only export, the \"exports\" field provides sugar for this case being the direct \"exports\" field value. If the \".\" export has a fallback array or string value, then the \"exports\" field can be set to this value directly. {   \"exports\": {     \".\": \".\/main.js\"   } }  can be written: {   \"exports\": \".\/main.js\" }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_conditional_exports","title":"Conditional exports","description":"Conditional exports provide a way to map to different paths depending on certain conditions. They are supported for both CommonJS and ES module imports. For example, a package that wants to provide different ES module exports for require() and import can be written: \/\/ package.json {   \"main\": \".\/main-require.cjs\",   \"exports\": {     \"import\": \".\/main-module.js\",     \"require\": \".\/main-require.cjs\"   },   \"type\": \"module\" }  Node.js supports the following conditions out of the box:  \"import\" - matches when the package is loaded via import or import(), or via any top-level import or resolve operation by the ECMAScript module loader. Applies regardless of the module format of the target file. Always mutually exclusive with \"require\". \"require\" - matches when the package is loaded via require(). The referenced file should be loadable with require() although the condition matches regardless of the module format of the target file. Expected formats include CommonJS, JSON, and native addons but not ES modules as require() doesn't support them. Always mutually exclusive with \"import\". \"node\" - matches for any Node.js environment. Can be a CommonJS or ES module file. This condition should always come after \"import\" or \"require\". \"default\" - the generic fallback that always matches. Can be a CommonJS or ES module file. This condition should always come last.  Within the \"exports\" object, key order is significant. During condition matching, earlier entries have higher priority and take precedence over later entries. The general rule is that conditions should be from most specific to least specific in object order. Other conditions such as \"browser\", \"electron\", \"deno\", \"react-native\", etc., are unknown to Node.js, and thus ignored. Runtimes or tools other than Node.js can use them at their discretion. Further restrictions, definitions, or guidance on condition names might occur in the future. Using the \"import\" and \"require\" conditions can lead to some hazards, which are further explained in the dual CommonJS\/ES module packages section. Conditional exports can also be extended to exports subpaths, for example: {   \"main\": \".\/main.js\",   \"exports\": {     \".\": \".\/main.js\",     \".\/feature\": {       \"node\": \".\/feature-node.js\",       \"default\": \".\/feature.js\"     }   } }  Defines a package where require('pkg\/feature') and import 'pkg\/feature' could provide different implementations between Node.js and other JS environments. When using environment branches, always include a \"default\" condition where possible. Providing a \"default\" condition ensures that any unknown JS environments are able to use this universal implementation, which helps avoid these JS environments from having to pretend to be existing environments in order to support packages with conditional exports. For this reason, using \"node\" and \"default\" condition branches is usually preferable to using \"node\" and \"browser\" condition branches."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_nested_conditions","title":"Nested conditions","description":"In addition to direct mappings, Node.js also supports nested condition objects. For example, to define a package that only has dual mode entry points for use in Node.js but not the browser: {   \"main\": \".\/main.js\",   \"exports\": {     \"node\": {       \"import\": \".\/feature-node.mjs\",       \"require\": \".\/feature-node.cjs\"     },     \"default\": \".\/feature.mjs\",   } }  Conditions continue to be matched in order as with flat conditions. If a nested conditional does not have any mapping it will continue checking the remaining conditions of the parent condition. In this way nested conditions behave analogously to nested JavaScript if statements."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_resolving_user_conditions","title":"Resolving user conditions","description":"When running Node.js, custom user conditions can be added with the --conditions flag: node --conditions=development main.js  which would then resolve the \"development\" condition in package imports and exports, while resolving the existing \"node\", \"default\", \"import\", and \"require\" conditions as appropriate. Any number of custom conditions can be set with repeat flags."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_self_referencing_a_package_using_its_name","title":"Self-referencing a package using its name","description":"Within a package, the values defined in the package\u2019s package.json \"exports\" field can be referenced via the package\u2019s name. For example, assuming the package.json is: \/\/ package.json {   \"name\": \"a-package\",   \"exports\": {     \".\": \".\/main.mjs\",     \".\/foo\": \".\/foo.js\"   } }  Then any module in that package can reference an export in the package itself: \/\/ .\/a-module.mjs import { something } from 'a-package'; \/\/ Imports \"something\" from .\/main.mjs.  Self-referencing is available only if package.json has \"exports\", and will allow importing only what that \"exports\" (in the package.json) allows. So the code below, given the previous package, will generate a runtime error: \/\/ .\/another-module.mjs  \/\/ Imports \"another\" from .\/m.mjs. Fails because \/\/ the \"package.json\" \"exports\" field \/\/ does not provide an export named \".\/m.mjs\". import { another } from 'a-package\/m.mjs';  Self-referencing is also available when using require, both in an ES module, and in a CommonJS one. For example, this code will also work: \/\/ .\/a-module.js const { something } = require('a-package\/foo'); \/\/ Loads from .\/foo.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dual_commonjs_es_module_packages","title":"Dual CommonJS\/ES module packages","description":"Prior to the introduction of support for ES modules in Node.js, it was a common pattern for package authors to include both CommonJS and ES module JavaScript sources in their package, with package.json \"main\" specifying the CommonJS entry point and package.json \"module\" specifying the ES module entry point. This enabled Node.js to run the CommonJS entry point while build tools such as bundlers used the ES module entry point, since Node.js ignored (and still ignores) the top-level \"module\" field. Node.js can now run ES module entry points, and a package can contain both CommonJS and ES module entry points (either via separate specifiers such as 'pkg' and 'pkg\/es-module', or both at the same specifier via Conditional exports). Unlike in the scenario where \"module\" is only used by bundlers, or ES module files are transpiled into CommonJS on the fly before evaluation by Node.js, the files referenced by the ES module entry point are evaluated as ES modules."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dual_package_hazard","title":"Dual package hazard","description":"When an application is using a package that provides both CommonJS and ES module sources, there is a risk of certain bugs if both versions of the package get loaded. This potential comes from the fact that the pkgInstance created by const pkgInstance = require('pkg') is not the same as the pkgInstance created by import pkgInstance from 'pkg' (or an alternative main path like 'pkg\/module'). This is the \u201cdual package hazard,\u201d where two versions of the same package can be loaded within the same runtime environment. While it is unlikely that an application or package would intentionally load both versions directly, it is common for an application to load one version while a dependency of the application loads the other version. This hazard can happen because Node.js supports intermixing CommonJS and ES modules, and can lead to unexpected behavior. If the package main export is a constructor, an instanceof comparison of instances created by the two versions returns false, and if the export is an object, properties added to one (like pkgInstance.foo = 3) are not present on the other. This differs from how import and require statements work in all-CommonJS or all-ES module environments, respectively, and therefore is surprising to users. It also differs from the behavior users are familiar with when using transpilation via tools like Babel or esm."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_writing_dual_packages_while_avoiding_or_minimizing_hazards","title":"Writing dual packages while avoiding or minimizing hazards","description":"First, the hazard described in the previous section occurs when a package contains both CommonJS and ES module sources and both sources are provided for use in Node.js, either via separate main entry points or exported paths. A package might instead be written where any version of Node.js receives only CommonJS sources, and any separate ES module sources the package might contain are intended only for other environments such as browsers. Such a package would be usable by any version of Node.js, since import can refer to CommonJS files; but it would not provide any of the advantages of using ES module syntax. A package might also switch from CommonJS to ES module syntax in a breaking change version bump. This has the disadvantage that the newest version of the package would only be usable in ES module-supporting versions of Node.js. Every pattern has tradeoffs, but there are two broad approaches that satisfy the following conditions:  The package is usable via both require and import. The package is usable in both current Node.js and older versions of Node.js that lack support for ES modules. The package main entry point, e.g. 'pkg' can be used by both require to resolve to a CommonJS file and by import to resolve to an ES module file. (And likewise for exported paths, e.g. 'pkg\/feature'.) The package provides named exports, e.g. import { name } from 'pkg' rather than import pkg from 'pkg'; pkg.name. The package is potentially usable in other ES module environments such as browsers. The hazards described in the previous section are avoided or minimized."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_approach_1_use_an_es_module_wrapper","title":"Approach #1: Use an ES module wrapper","description":"Write the package in CommonJS or transpile ES module sources into CommonJS, and create an ES module wrapper file that defines the named exports. Using Conditional exports, the ES module wrapper is used for import and the CommonJS entry point for require. \/\/ .\/node_modules\/pkg\/package.json {   \"type\": \"module\",   \"main\": \".\/index.cjs\",   \"exports\": {     \"import\": \".\/wrapper.mjs\",     \"require\": \".\/index.cjs\"   } }  The preceding example uses explicit extensions .mjs and .cjs. If your files use the .js extension, \"type\": \"module\" will cause such files to be treated as ES modules, just as \"type\": \"commonjs\" would cause them to be treated as CommonJS. See Enabling. \/\/ .\/node_modules\/pkg\/index.cjs exports.name = 'value';  \/\/ .\/node_modules\/pkg\/wrapper.mjs import cjsModule from '.\/index.cjs'; export const name = cjsModule.name;  In this example, the name from import { name } from 'pkg' is the same singleton as the name from const { name } = require('pkg'). Therefore === returns true when comparing the two names and the divergent specifier hazard is avoided. If the module is not simply a list of named exports, but rather contains a unique function or object export like module.exports = function () { ... }, or if support in the wrapper for the import pkg from 'pkg' pattern is desired, then the wrapper would instead be written to export the default optionally along with any named exports as well: import cjsModule from '.\/index.cjs'; export const name = cjsModule.name; export default cjsModule;  This approach is appropriate for any of the following use cases:  The package is currently written in CommonJS and the author would prefer not to refactor it into ES module syntax, but wishes to provide named exports for ES module consumers. The package has other packages that depend on it, and the end user might install both this package and those other packages. For example a utilities package is used directly in an application, and a utilities-plus package adds a few more functions to utilities. Because the wrapper exports underlying CommonJS files, it doesn\u2019t matter if utilities-plus is written in CommonJS or ES module syntax; it will work either way. The package stores internal state, and the package author would prefer not to refactor the package to isolate its state management. See the next section.  A variant of this approach not requiring conditional exports for consumers could be to add an export, e.g. \".\/module\", to point to an all-ES module-syntax version of the package. This could be used via import 'pkg\/module' by users who are certain that the CommonJS version will not be loaded anywhere in the application, such as by dependencies; or if the CommonJS version can be loaded but doesn\u2019t affect the ES module version (for example, because the package is stateless): \/\/ .\/node_modules\/pkg\/package.json {   \"type\": \"module\",   \"main\": \".\/index.cjs\",   \"exports\": {     \".\": \".\/index.cjs\",     \".\/module\": \".\/wrapper.mjs\"   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_approach_2_isolate_state","title":"Approach #2: Isolate state","description":"A package.json file can define the separate CommonJS and ES module entry points directly: \/\/ .\/node_modules\/pkg\/package.json {   \"type\": \"module\",   \"main\": \".\/index.cjs\",   \"exports\": {     \"import\": \".\/index.mjs\",     \"require\": \".\/index.cjs\"   } }  This can be done if both the CommonJS and ES module versions of the package are equivalent, for example because one is the transpiled output of the other; and the package\u2019s management of state is carefully isolated (or the package is stateless). The reason that state is an issue is because both the CommonJS and ES module versions of the package might get used within an application; for example, the user\u2019s application code could import the ES module version while a dependency requires the CommonJS version. If that were to occur, two copies of the package would be loaded in memory and therefore two separate states would be present. This would likely cause hard-to-troubleshoot bugs. Aside from writing a stateless package (if JavaScript\u2019s Math were a package, for example, it would be stateless as all of its methods are static), there are some ways to isolate state so that it\u2019s shared between the potentially loaded CommonJS and ES module instances of the package:   If possible, contain all state within an instantiated object. JavaScript\u2019s Date, for example, needs to be instantiated to contain state; if it were a package, it would be used like this: import Date from 'date'; const someDate = new Date(); \/\/ someDate contains state; Date does not  The new keyword isn\u2019t required; a package\u2019s function can return a new object, or modify a passed-in object, to keep the state external to the package.   Isolate the state in one or more CommonJS files that are shared between the CommonJS and ES module versions of the package. For example, if the CommonJS and ES module entry points are index.cjs and index.mjs, respectively: \/\/ .\/node_modules\/pkg\/index.cjs const state = require('.\/state.cjs'); module.exports.state = state;  \/\/ .\/node_modules\/pkg\/index.mjs import state from '.\/state.cjs'; export {   state };  Even if pkg is used via both require and import in an application (for example, via import in application code and via require by a dependency) each reference of pkg will contain the same state; and modifying that state from either module system will apply to both.   Any plugins that attach to the package\u2019s singleton would need to separately attach to both the CommonJS and ES module singletons. This approach is appropriate for any of the following use cases:  The package is currently written in ES module syntax and the package author wants that version to be used wherever such syntax is supported. The package is stateless or its state can be isolated without too much difficulty. The package is unlikely to have other public packages that depend on it, or if it does, the package is stateless or has state that need not be shared between dependencies or with the overall application.  Even with isolated state, there is still the cost of possible extra code execution between the CommonJS and ES module versions of a package. As with the previous approach, a variant of this approach not requiring conditional exports for consumers could be to add an export, e.g. \".\/module\", to point to an all-ES module-syntax version of the package: \/\/ .\/node_modules\/pkg\/package.json {   \"type\": \"module\",   \"main\": \".\/index.cjs\",   \"exports\": {     \".\": \".\/index.cjs\",     \".\/module\": \".\/index.mjs\"   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_js_package_json_field_definitions","title":"Node.js `package.json` field definitions","description":"This section describes the fields used by the Node.js runtime. Other tools (such as npm) use additional fields which are ignored by Node.js and not documented here. The following fields in package.json files are used in Node.js:  \"name\" - Relevant when using named imports within a package. Also used by package managers as the name of the package. \"main\" - The default module when loading the package, if exports is not specified, and in versions of Node.js prior to the introduction of exports. \"type\" - The package type determining whether to load .js files as CommonJS or ES modules. \"exports\" - Package exports and conditional exports. When present, limits which submodules can be loaded from within the package. \"imports\" - Package imports, for use by modules within the package itself."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_name","title":"`\"name\"`","description":"Type: <string>  {   \"name\": \"package-name\" }  The \"name\" field defines your package\u2019s name. Publishing to the npm registry requires a name that satisfies certain requirements. The \"name\" field can be used in addition to the \"exports\" field to self-reference a package using its name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_main","title":"`\"main\"`","description":"Type: <string>  {   \"main\": \".\/main.js\" }  The \"main\" field defines the script that is used when the package directory is loaded via require(). Its value is a path. require('.\/path\/to\/directory'); \/\/ This resolves to .\/path\/to\/directory\/main.js.  When a package has an \"exports\" field, this will take precedence over the \"main\" field when importing the package by name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_type","title":"`\"type\"`","description":"Type: <string>  The \"type\" field defines the module format that Node.js uses for all .js files that have that package.json file as their nearest parent. Files ending with .js are loaded as ES modules when the nearest parent package.json file contains a top-level field \"type\" with a value of \"module\". The nearest parent package.json is defined as the first package.json found when searching in the current folder, that folder\u2019s parent, and so on up until a node_modules folder or the volume root is reached. \/\/ package.json {   \"type\": \"module\" }  # In same folder as preceding package.json node my-app.js # Runs as ES module  If the nearest parent package.json lacks a \"type\" field, or contains \"type\": \"commonjs\", .js files are treated as CommonJS. If the volume root is reached and no package.json is found, .js files are treated as CommonJS. import statements of .js files are treated as ES modules if the nearest parent package.json contains \"type\": \"module\". \/\/ my-app.js, part of the same example as above import '.\/startup.js'; \/\/ Loaded as ES module because of package.json  Regardless of the value of the \"type\" field, .mjs files are always treated as ES modules and .cjs files are always treated as CommonJS."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exports","title":"`\"exports\"`","description":"Type: <Object> | <string> | <string[]>  {   \"exports\": \".\/index.js\" }  The \"exports\" field allows defining the entry points of a package when imported by name loaded either via a node_modules lookup or a self-reference to its own name. It is supported in Node.js 12+ as an alternative to the \"main\" that can support defining subpath exports and conditional exports while encapsulating internal unexported modules. Conditional Exports can also be used within \"exports\" to define different package entry points per environment, including whether the package is referenced via require or via import. All paths defined in the \"exports\" must be relative file URLs starting with .\/."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_imports","title":"`\"imports\"`","description":"Type: <Object>  \/\/ package.json {   \"imports\": {     \"#dep\": {       \"node\": \"dep-node-native\",       \"default\": \".\/dep-polyfill.js\"     }   },   \"dependencies\": {     \"dep-node-native\": \"^1.0.0\"   } }  Entries in the imports field must be strings starting with #. Import maps permit mapping to external packages. This field defines subpath imports for the current package."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_policies","title":"Policies","description":"Node.js contains experimental support for creating policies on loading code. Policies are a security feature intended to allow guarantees about what code Node.js is able to load. The use of policies assumes safe practices for the policy files such as ensuring that policy files cannot be overwritten by the Node.js application by using file permissions. A best practice would be to ensure that the policy manifest is read-only for the running Node.js application and that the file cannot be changed by the running Node.js application in any way. A typical setup would be to create the policy file as a different user id than the one running Node.js and granting read permissions to the user id running Node.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_enabling","title":"Enabling","description":"The --experimental-policy flag can be used to enable features for policies when loading modules. Once this has been set, all modules must conform to a policy manifest file passed to the flag: node --experimental-policy=policy.json app.js  The policy manifest will be used to enforce constraints on code loaded by Node.js. To mitigate tampering with policy files on disk, an integrity for the policy file itself may be provided via --policy-integrity. This allows running node and asserting the policy file contents even if the file is changed on disk. node --experimental-policy=policy.json --policy-integrity=\"sha384-SggXRQHwCG8g+DktYYzxkXRIkTiEYWBHqev0xnpCxYlqMBufKZHAHQM3\/boDaI\/0\" app.js"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_features","title":"Features","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_behavior","title":"Error behavior","description":"When a policy check fails, Node.js by default will throw an error. It is possible to change the error behavior to one of a few possibilities by defining an \"onerror\" field in a policy manifest. The following values are available to change the behavior:  \"exit\": will exit the process immediately. No cleanup code will be allowed to run. \"log\": will log the error at the site of the failure. \"throw\": will throw a JS error at the site of the failure. This is the default.  {   \"onerror\": \"log\",   \"resources\": {     \".\/app\/checked.js\": {       \"integrity\": \"sha384-SggXRQHwCG8g+DktYYzxkXRIkTiEYWBHqev0xnpCxYlqMBufKZHAHQM3\/boDaI\/0\"     }   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_integrity_checks","title":"Integrity checks","description":"Policy files must use integrity checks with Subresource Integrity strings compatible with the browser integrity attribute associated with absolute URLs. When using require() all resources involved in loading are checked for integrity if a policy manifest has been specified. If a resource does not match the integrity listed in the manifest, an error will be thrown. An example policy file that would allow loading a file checked.js: {   \"resources\": {     \".\/app\/checked.js\": {       \"integrity\": \"sha384-SggXRQHwCG8g+DktYYzxkXRIkTiEYWBHqev0xnpCxYlqMBufKZHAHQM3\/boDaI\/0\"     }   } }  Each resource listed in the policy manifest can be of one the following formats to determine its location:  A relative-URL string to a resource from the manifest such as .\/resource.js, ..\/resource.js, or \/resource.js. A complete URL string to a resource such as file:\/\/\/resource.js.  When loading resources the entire URL must match including search parameters and hash fragment. .\/a.js?b will not be used when attempting to load .\/a.js and vice versa. To generate integrity strings, a script such as printf \"sha384-$(cat checked.js | openssl dgst -sha384 -binary | base64)\" can be used. Integrity can be specified as the boolean value true to accept any body for the resource which can be useful for local development. It is not recommended in production since it would allow unexpected alteration of resources to be considered valid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dependency_redirection","title":"Dependency redirection","description":"An application may need to ship patched versions of modules or to prevent modules from allowing all modules access to all other modules. Redirection can be used by intercepting attempts to load the modules wishing to be replaced. {   \"resources\": {     \".\/app\/checked.js\": {       \"dependencies\": {         \"fs\": true,         \"os\": \".\/app\/node_modules\/alt-os\",         \"http\": { \"import\": true }       }     }   } }  The dependencies are keyed by the requested specifier string and have values of either true, null, a string pointing to a module to be resolved, or a conditions object. The specifier string does not perform any searching and must match exactly what is provided to the require() or import. Therefore, multiple specifiers may be needed in the policy if it uses multiple different strings to point to the same module (such as excluding the extension). If the value of the redirection is true the default searching algorithms are used to find the module. If the value of the redirection is a string, it is resolved relative to the manifest and then immediately used without searching. Any specifier string for which resolution is attempted and that is not listed in the dependencies results in an error according to the policy. Redirection does not prevent access to APIs through means such as direct access to require.cache or through module.constructor which allow access to loading modules. Policy redirection only affects specifiers to require() and import. Other means, such as to prevent undesired access to APIs through variables, are necessary to lock down that path of loading modules. A boolean value of true for the dependencies map can be specified to allow a module to load any specifier without redirection. This can be useful for local development and may have some valid usage in production, but should be used only with care after auditing a module to ensure its behavior is valid. Similar to \"exports\" in package.json, dependencies can also be specified to be objects containing conditions which branch how dependencies are loaded. In the preceding example, \"http\" is allowed when the \"import\" condition is part of loading it. A value of null for the resolved value causes the resolution to fail. This can be used to ensure some kinds of dynamic access are explicitly prevented. Unknown values for the resolved module location cause failures but are not guaranteed to be forward compatible. Example: Patched dependency Redirected dependencies can provide attenuated or modified functionality as fits the application. For example, log data about timing of function durations by wrapping the original: const original = require('fn'); module.exports = function fn(...args) {   console.time();   try {     return new.target ?       Reflect.construct(original, args) :       Reflect.apply(original, this, args);   } finally {     console.timeEnd();   } };"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_scopes","title":"Scopes","description":"Use the \"scopes\" field of a manifest to set configuration for many resources at once. The \"scopes\" field works by matching resources by their segments. If a scope or resource includes \"cascade\": true, unknown specifiers will be searched for in their containing scope. The containing scope for cascading is found by recursively reducing the resource URL by removing segments for special schemes, keeping trailing \"\/\" suffixes, and removing the query and hash fragment. This leads to the eventual reduction of the URL to its origin. If the URL is non-special the scope will be located by the URL's origin. If no scope is found for the origin or in the case of opaque origins, a protocol string can be used as a scope. Note, blob: URLs adopt their origin from the path they contain, and so a scope of \"blob:https:\/\/nodejs.org\" will have no effect since no URL can have an origin of blob:https:\/\/nodejs.org; URLs starting with blob:https:\/\/nodejs.org\/ will use https:\/\/nodejs.org for its origin and thus https: for its protocol scope. For opaque origin blob: URLs they will have blob: for their protocol scope since they do not adopt origins."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_integrity_using_scopes","title":"Integrity using scopes","description":"Setting an integrity to true on a scope will set the integrity for any resource not found in the manifest to true. Setting an integrity to null on a scope will set the integrity for any resource not found in the manifest to fail matching. Not including an integrity is the same as setting the integrity to null. \"cascade\" for integrity checks will be ignored if \"integrity\" is explicitly set. The following example allows loading any file: {   \"scopes\": {     \"file:\": {       \"integrity\": true     }   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dependency_redirection_using_scopes","title":"Dependency redirection using scopes","description":"The following example, would allow access to fs for all resources within .\/app\/: {   \"resources\": {     \".\/app\/checked.js\": {       \"cascade\": true,       \"integrity\": true     }   },   \"scopes\": {     \".\/app\/\": {       \"dependencies\": {         \"fs\": true       }     }   } }  The following example, would allow access to fs for all data: resources: {   \"resources\": {     \"data:text\/javascript,import('fs');\": {       \"cascade\": true,       \"integrity\": true     }   },   \"scopes\": {     \"data:\": {       \"dependencies\": {         \"fs\": true       }     }   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_diagnostic_report","title":"Diagnostic report","description":"Delivers a JSON-formatted diagnostic summary, written to a file. The report is intended for development, test and production use, to capture and preserve information for problem determination. It includes JavaScript and native stack traces, heap statistics, platform information, resource usage etc. With the report option enabled, diagnostic reports can be triggered on unhandled exceptions, fatal errors and user signals, in addition to triggering programmatically through API calls. A complete example report that was generated on an uncaught exception is provided below for reference. {   \"header\": {     \"reportVersion\": 1,     \"event\": \"exception\",     \"trigger\": \"Exception\",     \"filename\": \"report.20181221.005011.8974.0.001.json\",     \"dumpEventTime\": \"2018-12-21T00:50:11Z\",     \"dumpEventTimeStamp\": \"1545371411331\",     \"processId\": 8974,     \"cwd\": \"\/home\/nodeuser\/project\/node\",     \"commandLine\": [       \"\/home\/nodeuser\/project\/node\/out\/Release\/node\",       \"--report-uncaught-exception\",       \"\/home\/nodeuser\/project\/node\/test\/report\/test-exception.js\",       \"child\"     ],     \"nodejsVersion\": \"v12.0.0-pre\",     \"glibcVersionRuntime\": \"2.17\",     \"glibcVersionCompiler\": \"2.17\",     \"wordSize\": \"64 bit\",     \"arch\": \"x64\",     \"platform\": \"linux\",     \"componentVersions\": {       \"node\": \"12.0.0-pre\",       \"v8\": \"7.1.302.28-node.5\",       \"uv\": \"1.24.1\",       \"zlib\": \"1.2.11\",       \"ares\": \"1.15.0\",       \"modules\": \"68\",       \"nghttp2\": \"1.34.0\",       \"napi\": \"3\",       \"llhttp\": \"1.0.1\",       \"openssl\": \"1.1.0j\"     },     \"release\": {       \"name\": \"node\"     },     \"osName\": \"Linux\",     \"osRelease\": \"3.10.0-862.el7.x86_64\",     \"osVersion\": \"#1 SMP Wed Mar 21 18:14:51 EDT 2018\",     \"osMachine\": \"x86_64\",     \"cpus\": [       {         \"model\": \"Intel(R) Core(TM) i7-6820HQ CPU @ 2.70GHz\",         \"speed\": 2700,         \"user\": 88902660,         \"nice\": 0,         \"sys\": 50902570,         \"idle\": 241732220,         \"irq\": 0       },       {         \"model\": \"Intel(R) Core(TM) i7-6820HQ CPU @ 2.70GHz\",         \"speed\": 2700,         \"user\": 88902660,         \"nice\": 0,         \"sys\": 50902570,         \"idle\": 241732220,         \"irq\": 0       }     ],     \"networkInterfaces\": [       {         \"name\": \"en0\",         \"internal\": false,         \"mac\": \"13:10:de:ad:be:ef\",         \"address\": \"10.0.0.37\",         \"netmask\": \"255.255.255.0\",         \"family\": \"IPv4\"       }     ],     \"host\": \"test_machine\"   },   \"javascriptStack\": {     \"message\": \"Error: *** test-exception.js: throwing uncaught Error\",     \"stack\": [       \"at myException (\/home\/nodeuser\/project\/node\/test\/report\/test-exception.js:9:11)\",       \"at Object.<anonymous> (\/home\/nodeuser\/project\/node\/test\/report\/test-exception.js:12:3)\",       \"at Module._compile (internal\/modules\/cjs\/loader.js:718:30)\",       \"at Object.Module._extensions..js (internal\/modules\/cjs\/loader.js:729:10)\",       \"at Module.load (internal\/modules\/cjs\/loader.js:617:32)\",       \"at tryModuleLoad (internal\/modules\/cjs\/loader.js:560:12)\",       \"at Function.Module._load (internal\/modules\/cjs\/loader.js:552:3)\",       \"at Function.Module.runMain (internal\/modules\/cjs\/loader.js:771:12)\",       \"at executeUserCode (internal\/bootstrap\/node.js:332:15)\"     ]   },   \"nativeStack\": [     {       \"pc\": \"0x000055b57f07a9ef\",       \"symbol\": \"report::GetNodeReport(v8::Isolate*, node::Environment*, char const*, char const*, v8::Local<v8::String>, std::ostream&) [.\/node]\"     },     {       \"pc\": \"0x000055b57f07cf03\",       \"symbol\": \"report::GetReport(v8::FunctionCallbackInfo<v8::Value> const&) [.\/node]\"     },     {       \"pc\": \"0x000055b57f1bccfd\",       \"symbol\": \" [.\/node]\"     },     {       \"pc\": \"0x000055b57f1be048\",       \"symbol\": \"v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) [.\/node]\"     },     {       \"pc\": \"0x000055b57feeda0e\",       \"symbol\": \" [.\/node]\"     }   ],   \"javascriptHeap\": {     \"totalMemory\": 6127616,     \"totalCommittedMemory\": 4357352,     \"usedMemory\": 3221136,     \"availableMemory\": 1521370240,     \"memoryLimit\": 1526909922,     \"heapSpaces\": {       \"read_only_space\": {         \"memorySize\": 524288,         \"committedMemory\": 39208,         \"capacity\": 515584,         \"used\": 30504,         \"available\": 485080       },       \"new_space\": {         \"memorySize\": 2097152,         \"committedMemory\": 2019312,         \"capacity\": 1031168,         \"used\": 985496,         \"available\": 45672       },       \"old_space\": {         \"memorySize\": 2273280,         \"committedMemory\": 1769008,         \"capacity\": 1974640,         \"used\": 1725488,         \"available\": 249152       },       \"code_space\": {         \"memorySize\": 696320,         \"committedMemory\": 184896,         \"capacity\": 152128,         \"used\": 152128,         \"available\": 0       },       \"map_space\": {         \"memorySize\": 536576,         \"committedMemory\": 344928,         \"capacity\": 327520,         \"used\": 327520,         \"available\": 0       },       \"large_object_space\": {         \"memorySize\": 0,         \"committedMemory\": 0,         \"capacity\": 1520590336,         \"used\": 0,         \"available\": 1520590336       },       \"new_large_object_space\": {         \"memorySize\": 0,         \"committedMemory\": 0,         \"capacity\": 0,         \"used\": 0,         \"available\": 0       }     }   },   \"resourceUsage\": {     \"userCpuSeconds\": 0.069595,     \"kernelCpuSeconds\": 0.019163,     \"cpuConsumptionPercent\": 0.000000,     \"maxRss\": 18079744,     \"pageFaults\": {       \"IORequired\": 0,       \"IONotRequired\": 4610     },     \"fsActivity\": {       \"reads\": 0,       \"writes\": 0     }   },   \"uvthreadResourceUsage\": {     \"userCpuSeconds\": 0.068457,     \"kernelCpuSeconds\": 0.019127,     \"cpuConsumptionPercent\": 0.000000,     \"fsActivity\": {       \"reads\": 0,       \"writes\": 0     }   },   \"libuv\": [     {       \"type\": \"async\",       \"is_active\": true,       \"is_referenced\": false,       \"address\": \"0x0000000102910900\",       \"details\": \"\"     },     {       \"type\": \"timer\",       \"is_active\": false,       \"is_referenced\": false,       \"address\": \"0x00007fff5fbfeab0\",       \"repeat\": 0,       \"firesInMsFromNow\": 94403548320796,       \"expired\": true     },     {       \"type\": \"check\",       \"is_active\": true,       \"is_referenced\": false,       \"address\": \"0x00007fff5fbfeb48\"     },     {       \"type\": \"idle\",       \"is_active\": false,       \"is_referenced\": true,       \"address\": \"0x00007fff5fbfebc0\"     },     {       \"type\": \"prepare\",       \"is_active\": false,       \"is_referenced\": false,       \"address\": \"0x00007fff5fbfec38\"     },     {       \"type\": \"check\",       \"is_active\": false,       \"is_referenced\": false,       \"address\": \"0x00007fff5fbfecb0\"     },     {       \"type\": \"async\",       \"is_active\": true,       \"is_referenced\": false,       \"address\": \"0x000000010188f2e0\"     },     {       \"type\": \"tty\",       \"is_active\": false,       \"is_referenced\": true,       \"address\": \"0x000055b581db0e18\",       \"width\": 204,       \"height\": 55,       \"fd\": 17,       \"writeQueueSize\": 0,       \"readable\": true,       \"writable\": true     },     {       \"type\": \"signal\",       \"is_active\": true,       \"is_referenced\": false,       \"address\": \"0x000055b581d80010\",       \"signum\": 28,       \"signal\": \"SIGWINCH\"     },     {       \"type\": \"tty\",       \"is_active\": true,       \"is_referenced\": true,       \"address\": \"0x000055b581df59f8\",       \"width\": 204,       \"height\": 55,       \"fd\": 19,       \"writeQueueSize\": 0,       \"readable\": true,       \"writable\": true     },     {       \"type\": \"loop\",       \"is_active\": true,       \"address\": \"0x000055fc7b2cb180\"     }   ],   \"workers\": [],   \"environmentVariables\": {     \"REMOTEHOST\": \"REMOVED\",     \"MANPATH\": \"\/opt\/rh\/devtoolset-3\/root\/usr\/share\/man:\",     \"XDG_SESSION_ID\": \"66126\",     \"HOSTNAME\": \"test_machine\",     \"HOST\": \"test_machine\",     \"TERM\": \"xterm-256color\",     \"SHELL\": \"\/bin\/csh\",     \"SSH_CLIENT\": \"REMOVED\",     \"PERL5LIB\": \"\/opt\/rh\/devtoolset-3\/root\/\/usr\/lib64\/perl5\/vendor_perl:\/opt\/rh\/devtoolset-3\/root\/usr\/lib\/perl5:\/opt\/rh\/devtoolset-3\/root\/\/usr\/share\/perl5\/vendor_perl\",     \"OLDPWD\": \"\/home\/nodeuser\/project\/node\/src\",     \"JAVACONFDIRS\": \"\/opt\/rh\/devtoolset-3\/root\/etc\/java:\/etc\/java\",     \"SSH_TTY\": \"\/dev\/pts\/0\",     \"PCP_DIR\": \"\/opt\/rh\/devtoolset-3\/root\",     \"GROUP\": \"normaluser\",     \"USER\": \"nodeuser\",     \"LD_LIBRARY_PATH\": \"\/opt\/rh\/devtoolset-3\/root\/usr\/lib64:\/opt\/rh\/devtoolset-3\/root\/usr\/lib\",     \"HOSTTYPE\": \"x86_64-linux\",     \"XDG_CONFIG_DIRS\": \"\/opt\/rh\/devtoolset-3\/root\/etc\/xdg:\/etc\/xdg\",     \"MAIL\": \"\/var\/spool\/mail\/nodeuser\",     \"PATH\": \"\/home\/nodeuser\/project\/node:\/opt\/rh\/devtoolset-3\/root\/usr\/bin:\/usr\/local\/bin:\/usr\/bin:\/usr\/local\/sbin:\/usr\/sbin\",     \"PWD\": \"\/home\/nodeuser\/project\/node\",     \"LANG\": \"en_US.UTF-8\",     \"PS1\": \"\\\\u@\\\\h : \\\\[\\\\e[31m\\\\]\\\\w\\\\[\\\\e[m\\\\] >  \",     \"SHLVL\": \"2\",     \"HOME\": \"\/home\/nodeuser\",     \"OSTYPE\": \"linux\",     \"VENDOR\": \"unknown\",     \"PYTHONPATH\": \"\/opt\/rh\/devtoolset-3\/root\/usr\/lib64\/python2.7\/site-packages:\/opt\/rh\/devtoolset-3\/root\/usr\/lib\/python2.7\/site-packages\",     \"MACHTYPE\": \"x86_64\",     \"LOGNAME\": \"nodeuser\",     \"XDG_DATA_DIRS\": \"\/opt\/rh\/devtoolset-3\/root\/usr\/share:\/usr\/local\/share:\/usr\/share\",     \"LESSOPEN\": \"||\/usr\/bin\/lesspipe.sh %s\",     \"INFOPATH\": \"\/opt\/rh\/devtoolset-3\/root\/usr\/share\/info\",     \"XDG_RUNTIME_DIR\": \"\/run\/user\/50141\",     \"_\": \".\/node\"   },   \"userLimits\": {     \"core_file_size_blocks\": {       \"soft\": \"\",       \"hard\": \"unlimited\"     },     \"data_seg_size_kbytes\": {       \"soft\": \"unlimited\",       \"hard\": \"unlimited\"     },     \"file_size_blocks\": {       \"soft\": \"unlimited\",       \"hard\": \"unlimited\"     },     \"max_locked_memory_bytes\": {       \"soft\": \"unlimited\",       \"hard\": 65536     },     \"max_memory_size_kbytes\": {       \"soft\": \"unlimited\",       \"hard\": \"unlimited\"     },     \"open_files\": {       \"soft\": \"unlimited\",       \"hard\": 4096     },     \"stack_size_bytes\": {       \"soft\": \"unlimited\",       \"hard\": \"unlimited\"     },     \"cpu_time_seconds\": {       \"soft\": \"unlimited\",       \"hard\": \"unlimited\"     },     \"max_user_processes\": {       \"soft\": \"unlimited\",       \"hard\": 4127290     },     \"virtual_memory_kbytes\": {       \"soft\": \"unlimited\",       \"hard\": \"unlimited\"     }   },   \"sharedObjects\": [     \"\/lib64\/libdl.so.2\",     \"\/lib64\/librt.so.1\",     \"\/lib64\/libstdc++.so.6\",     \"\/lib64\/libm.so.6\",     \"\/lib64\/libgcc_s.so.1\",     \"\/lib64\/libpthread.so.0\",     \"\/lib64\/libc.so.6\",     \"\/lib64\/ld-linux-x86-64.so.2\"   ] }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_usage","title":"Usage","description":"node --report-uncaught-exception --report-on-signal \\ --report-on-fatalerror app.js    --report-uncaught-exception Enables report to be generated on un-caught exceptions. Useful when inspecting JavaScript stack in conjunction with native stack and other runtime environment data.   --report-on-signal Enables report to be generated upon receiving the specified (or predefined) signal to the running Node.js process. (See below on how to modify the signal that triggers the report.) Default signal is SIGUSR2. Useful when a report needs to be triggered from another program. Application monitors may leverage this feature to collect report at regular intervals and plot rich set of internal runtime data to their views.   Signal based report generation is not supported in Windows. Under normal circumstances, there is no need to modify the report triggering signal. However, if SIGUSR2 is already used for other purposes, then this flag helps to change the signal for report generation and preserve the original meaning of SIGUSR2 for the said purposes.   --report-on-fatalerror Enables the report to be triggered on fatal errors (internal errors within the Node.js runtime, such as out of memory) that leads to termination of the application. Useful to inspect various diagnostic data elements such as heap, stack, event loop state, resource consumption etc. to reason about the fatal error.   --report-compact Write reports in a compact format, single-line JSON, more easily consumable by log processing systems than the default multi-line format designed for human consumption.   --report-directory Location at which the report will be generated.   --report-filename Name of the file to which the report will be written.   --report-signal Sets or resets the signal for report generation (not supported on Windows). Default signal is SIGUSR2.   A report can also be triggered via an API call from a JavaScript application: process.report.writeReport();  This function takes an optional additional argument filename, which is the name of a file into which the report is written. process.report.writeReport('.\/foo.json');  This function takes an optional additional argument err which is an Error object that will be used as the context for the JavaScript stack printed in the report. When using report to handle errors in a callback or an exception handler, this allows the report to include the location of the original error as well as where it was handled. try {   process.chdir('\/non-existent-path'); } catch (err) {   process.report.writeReport(err); } \/\/ Any other code  If both filename and error object are passed to writeReport() the error object must be the second parameter. try {   process.chdir('\/non-existent-path'); } catch (err) {   process.report.writeReport(filename, err); } \/\/ Any other code  The content of the diagnostic report can be returned as a JavaScript Object via an API call from a JavaScript application: const report = process.report.getReport(); console.log(typeof report === 'object'); \/\/ true  \/\/ Similar to process.report.writeReport() output console.log(JSON.stringify(report, null, 2));  This function takes an optional additional argument err, which is an Error object that will be used as the context for the JavaScript stack printed in the report. const report = process.report.getReport(new Error('custom error')); console.log(typeof report === 'object'); \/\/ true  The API versions are useful when inspecting the runtime state from within the application, in expectation of self-adjusting the resource consumption, load balancing, monitoring etc. The content of the report consists of a header section containing the event type, date, time, PID and Node.js version, sections containing JavaScript and native stack traces, a section containing V8 heap information, a section containing libuv handle information and an OS platform information section showing CPU and memory usage and system limits. An example report can be triggered using the Node.js REPL: $ node > process.report.writeReport(); Writing Node.js report to file: report.20181126.091102.8480.0.001.json Node.js report completed >  When a report is written, start and end messages are issued to stderr and the filename of the report is returned to the caller. The default filename includes the date, time, PID and a sequence number. The sequence number helps in associating the report dump with the runtime state if generated multiple times for the same Node.js process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_configuration","title":"Configuration","description":"Additional runtime configuration of report generation is available via the following properties of process.report: reportOnFatalError triggers diagnostic reporting on fatal errors when true. Defaults to false. reportOnSignal triggers diagnostic reporting on signal when true. This is not supported on Windows. Defaults to false. reportOnUncaughtException triggers diagnostic reporting on uncaught exception when true. Defaults to false. signal specifies the POSIX signal identifier that will be used to intercept external triggers for report generation. Defaults to 'SIGUSR2'. filename specifies the name of the output file in the file system. Special meaning is attached to stdout and stderr. Usage of these will result in report being written to the associated standard streams. In cases where standard streams are used, the value in directory is ignored. URLs are not supported. Defaults to a composite filename that contains timestamp, PID and sequence number. directory specifies the filesystem directory where the report will be written. URLs are not supported. Defaults to the current working directory of the Node.js process. \/\/ Trigger report only on uncaught exceptions. process.report.reportOnFatalError = false; process.report.reportOnSignal = false; process.report.reportOnUncaughtException = true;  \/\/ Trigger report for both internal errors as well as external signal. process.report.reportOnFatalError = true; process.report.reportOnSignal = true; process.report.reportOnUncaughtException = false;  \/\/ Change the default signal to 'SIGQUIT' and enable it. process.report.reportOnFatalError = false; process.report.reportOnUncaughtException = false; process.report.reportOnSignal = true; process.report.signal = 'SIGQUIT';  Configuration on module initialization is also available via environment variables: NODE_OPTIONS=\"--report-uncaught-exception \\   --report-on-fatalerror --report-on-signal \\   --report-signal=SIGUSR2  --report-filename=.\/report.json \\   --report-directory=\/home\/nodeuser\"  Specific API documentation can be found under process API documentation section."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_interaction_with_workers","title":"Interaction with workers","description":"Worker threads can create reports in the same way that the main thread does. Reports will include information on any Workers that are children of the current thread as part of the workers section, with each Worker generating a report in the standard report format. The thread which is generating the report will wait for the reports from Worker threads to finish. However, the latency for this will usually be low, as both running JavaScript and the event loop are interrupted to generate the report."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_usage_and_example","title":"Usage and example","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_usage","title":"Usage","description":"node [options] [V8 options] [script.js | -e \"script\" | - ] [arguments] Please see the Command-line options document for more information. Example An example of a web server written with Node.js which responds with 'Hello, World!': Commands in this document start with $ or > to replicate how they would appear in a user's terminal. Do not include the $ and > characters. They are there to show the start of each command. Lines that don\u2019t start with $ or > character show the output of the previous command. First, make sure to have downloaded and installed Node.js. See Installing Node.js via package manager for further install information. Now, create an empty project folder called projects, then navigate into it. Linux and Mac: $ mkdir ~\/projects $ cd ~\/projects  Windows CMD: > mkdir %USERPROFILE%\\projects > cd %USERPROFILE%\\projects  Windows PowerShell: > mkdir $env:USERPROFILE\\projects > cd $env:USERPROFILE\\projects  Next, create a new source file in the projects folder and call it hello-world.js. Open hello-world.js in any preferred text editor and paste in the following content: const http = require('http');  const hostname = '127.0.0.1'; const port = 3000;  const server = http.createServer((req, res) => {   res.statusCode = 200;   res.setHeader('Content-Type', 'text\/plain');   res.end('Hello, World!\\n'); });  server.listen(port, hostname, () => {   console.log(`Server running at http:\/\/${hostname}:${port}\/`); });  Save the file, go back to the terminal window, and enter the following command: $ node hello-world.js  Output like this should appear in the terminal: Server running at http:\/\/127.0.0.1:3000\/  Now, open any preferred web browser and visit http:\/\/127.0.0.1:3000. If the browser displays the string Hello, World!, that indicates the server is working."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert","title":"Assert","description":"Source Code: lib\/assert.js The assert module provides a set of assertion functions for verifying invariants."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_value_message","title":"`assert(value[, message])`","description":"An alias of assert.ok()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_deepequal_actual_expected_message","title":"`assert.deepEqual(actual, expected[, message])`","description":"Strict assertion mode An alias of assert.deepStrictEqual(). Legacy assertion mode  Stability: 0 - Deprecated: Use assert.deepStrictEqual() instead.  Tests for deep equality between the actual and expected parameters. Consider using assert.deepStrictEqual() instead. assert.deepEqual() can have surprising results. Deep equality means that the enumerable \"own\" properties of child objects are also recursively evaluated by the following rules."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_comparison_details","title":"Comparison details","description":"Primitive values are compared with the Abstract Equality Comparison ( == ) with the exception of NaN. It is treated as being identical in case both sides are NaN. Type tags of objects should be the same. Only enumerable \"own\" properties are considered. Error names and messages are always compared, even if these are not enumerable properties. Object wrappers are compared both as objects and unwrapped values. Object properties are compared unordered. Map keys and Set items are compared unordered. Recursion stops when both sides differ or both sides encounter a circular reference. Implementation does not test the [[Prototype]] of objects. Symbol properties are not compared. WeakMap and WeakSet comparison does not rely on their values.  The following example does not throw an AssertionError because the primitives are considered equal by the Abstract Equality Comparison ( == ). \/\/ WARNING: This does not throw an AssertionError! assert.deepEqual('+00000000', false);  \"Deep\" equality means that the enumerable \"own\" properties of child objects are evaluated also: const assert = require('assert');  const obj1 = {   a: {     b: 1   } }; const obj2 = {   a: {     b: 2   } }; const obj3 = {   a: {     b: 1   } }; const obj4 = Object.create(obj1);  assert.deepEqual(obj1, obj1); \/\/ OK  \/\/ Values of b are different: assert.deepEqual(obj1, obj2); \/\/ AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } }  assert.deepEqual(obj1, obj3); \/\/ OK  \/\/ Prototypes are ignored: assert.deepEqual(obj1, obj4); \/\/ AssertionError: { a: { b: 1 } } deepEqual {}  If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_deepstrictequal_actual_expected_message","title":"`assert.deepStrictEqual(actual, expected[, message])`","description":"Tests for deep equality between the actual and expected parameters. \"Deep\" equality means that the enumerable \"own\" properties of child objects are recursively evaluated also by the following rules."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_comparison_details","title":"Comparison details","description":"Primitive values are compared using the SameValue Comparison, used by Object.is(). Type tags of objects should be the same. [[Prototype]] of objects are compared using the Strict Equality Comparison. Only enumerable \"own\" properties are considered. Error names and messages are always compared, even if these are not enumerable properties. Enumerable own Symbol properties are compared as well. Object wrappers are compared both as objects and unwrapped values. Object properties are compared unordered. Map keys and Set items are compared unordered. Recursion stops when both sides differ or both sides encounter a circular reference. WeakMap and WeakSet comparison does not rely on their values. See below for further details.  const assert = require('assert').strict;  \/\/ This fails because 1 !== '1'. assert.deepStrictEqual({ a: 1 }, { a: '1' }); \/\/ AssertionError: Expected inputs to be strictly deep-equal: \/\/ + actual - expected \/\/ \/\/   { \/\/ +   a: 1 \/\/ -   a: '1' \/\/   }  \/\/ The following objects don't have own properties const date = new Date(); const object = {}; const fakeDate = {}; Object.setPrototypeOf(fakeDate, Date.prototype);  \/\/ Different [[Prototype]]: assert.deepStrictEqual(object, fakeDate); \/\/ AssertionError: Expected inputs to be strictly deep-equal: \/\/ + actual - expected \/\/ \/\/ + {} \/\/ - Date {}  \/\/ Different type tags: assert.deepStrictEqual(date, fakeDate); \/\/ AssertionError: Expected inputs to be strictly deep-equal: \/\/ + actual - expected \/\/ \/\/ + 2018-04-26T00:49:08.604Z \/\/ - Date {}  assert.deepStrictEqual(NaN, NaN); \/\/ OK, because of the SameValue comparison  \/\/ Different unwrapped numbers: assert.deepStrictEqual(new Number(1), new Number(2)); \/\/ AssertionError: Expected inputs to be strictly deep-equal: \/\/ + actual - expected \/\/ \/\/ + [Number: 1] \/\/ - [Number: 2]  assert.deepStrictEqual(new String('foo'), Object('foo')); \/\/ OK because the object and the string are identical when unwrapped.  assert.deepStrictEqual(-0, -0); \/\/ OK  \/\/ Different zeros using the SameValue Comparison: assert.deepStrictEqual(0, -0); \/\/ AssertionError: Expected inputs to be strictly deep-equal: \/\/ + actual - expected \/\/ \/\/ + 0 \/\/ - -0  const symbol1 = Symbol(); const symbol2 = Symbol(); assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol1]: 1 }); \/\/ OK, because it is the same symbol on both objects.  assert.deepStrictEqual({ [symbol1]: 1 }, { [symbol2]: 1 }); \/\/ AssertionError [ERR_ASSERTION]: Inputs identical but not reference equal: \/\/ \/\/ { \/\/   [Symbol()]: 1 \/\/ }  const weakMap1 = new WeakMap(); const weakMap2 = new WeakMap([[{}, {}]]); const weakMap3 = new WeakMap(); weakMap3.unequal = true;  assert.deepStrictEqual(weakMap1, weakMap2); \/\/ OK, because it is impossible to compare the entries  \/\/ Fails because weakMap3 has a property that weakMap1 does not contain: assert.deepStrictEqual(weakMap1, weakMap3); \/\/ AssertionError: Expected inputs to be strictly deep-equal: \/\/ + actual - expected \/\/ \/\/   WeakMap { \/\/ +   [items unknown] \/\/ -   [items unknown], \/\/ -   unequal: true \/\/   }  If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_doesnotmatch_string_regexp_message","title":"`assert.doesNotMatch(string, regexp[, message])`","description":"Expects the string input not to match the regular expression. This feature is currently experimental and the name might change or it might be completely removed again. const assert = require('assert').strict;  assert.doesNotMatch('I will fail', \/fail\/); \/\/ AssertionError [ERR_ASSERTION]: The input was expected to not match the ...  assert.doesNotMatch(123, \/pass\/); \/\/ AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string.  assert.doesNotMatch('I will pass', \/different\/); \/\/ OK  If the values do match, or if the string argument is of another type than string, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_doesnotreject_asyncfn_error_message","title":"`assert.doesNotReject(asyncFn[, error][, message])`","description":"Awaits the asyncFn promise or, if asyncFn is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is not rejected. If asyncFn is a function and it throws an error synchronously, assert.doesNotReject() will return a rejected Promise with that error. If the function does not return a promise, assert.doesNotReject() will return a rejected Promise with an ERR_INVALID_RETURN_VALUE error. In both cases the error handler is skipped. Using assert.doesNotReject() is actually not useful because there is little benefit in catching a rejection and then rejecting it again. Instead, consider adding a comment next to the specific code path that should not reject and keep error messages as expressive as possible. If specified, error can be a Class, RegExp or a validation function. See assert.throws() for more details. Besides the async nature to await the completion behaves identically to assert.doesNotThrow().  (async () => {   await assert.doesNotReject(     async () => {       throw new TypeError('Wrong value');     },     SyntaxError   ); })();   assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))   .then(() => {     \/\/ ...   });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_doesnotthrow_fn_error_message","title":"`assert.doesNotThrow(fn[, error][, message])`","description":"Asserts that the function fn does not throw an error. Using assert.doesNotThrow() is actually not useful because there is no benefit in catching an error and then rethrowing it. Instead, consider adding a comment next to the specific code path that should not throw and keep error messages as expressive as possible. When assert.doesNotThrow() is called, it will immediately call the fn function. If an error is thrown and it is the same type as that specified by the error parameter, then an AssertionError is thrown. If the error is of a different type, or if the error parameter is undefined, the error is propagated back to the caller. If specified, error can be a Class, RegExp or a validation function. See assert.throws() for more details. The following, for instance, will throw the TypeError because there is no matching error type in the assertion:  assert.doesNotThrow(   () => {     throw new TypeError('Wrong value');   },   SyntaxError );  However, the following will result in an AssertionError with the message 'Got unwanted exception...':  assert.doesNotThrow(   () => {     throw new TypeError('Wrong value');   },   TypeError );  If an AssertionError is thrown and a value is provided for the message parameter, the value of message will be appended to the AssertionError message:  assert.doesNotThrow(   () => {     throw new TypeError('Wrong value');   },   \/Wrong value\/,   'Whoops' ); \/\/ Throws: AssertionError: Got unwanted exception: Whoops"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_equal_actual_expected_message","title":"`assert.equal(actual, expected[, message])`","description":"Strict assertion mode An alias of assert.strictEqual(). Legacy assertion mode  Stability: 0 - Deprecated: Use assert.strictEqual() instead.  Tests shallow, coercive equality between the actual and expected parameters using the Abstract Equality Comparison ( == ). NaN is special handled and treated as being identical in case both sides are NaN. const assert = require('assert');  assert.equal(1, 1); \/\/ OK, 1 == 1 assert.equal(1, '1'); \/\/ OK, 1 == '1' assert.equal(NaN, NaN); \/\/ OK  assert.equal(1, 2); \/\/ AssertionError: 1 == 2 assert.equal({ a: { b: 1 } }, { a: { b: 1 } }); \/\/ AssertionError: { a: { b: 1 } } == { a: { b: 1 } }  If the values are not equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_fail_message","title":"`assert.fail([message])`","description":"Throws an AssertionError with the provided error message or a default error message. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError. const assert = require('assert').strict;  assert.fail(); \/\/ AssertionError [ERR_ASSERTION]: Failed  assert.fail('boom'); \/\/ AssertionError [ERR_ASSERTION]: boom  assert.fail(new TypeError('need array')); \/\/ TypeError: need array  Using assert.fail() with more than two arguments is possible but deprecated. See below for further details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_fail_actual_expected_message_operator_stackstartfn","title":"`assert.fail(actual, expected[, message[, operator[, stackStartFn]]])`","description":"If message is falsy, the error message is set as the values of actual and expected separated by the provided operator. If just the two actual and expected arguments are provided, operator will default to '!='. If message is provided as third argument it will be used as the error message and the other arguments will be stored as properties on the thrown object. If stackStartFn is provided, all stack frames above that function will be removed from stacktrace (see Error.captureStackTrace). If no arguments are given, the default message Failed will be used. const assert = require('assert').strict;  assert.fail('a', 'b'); \/\/ AssertionError [ERR_ASSERTION]: 'a' != 'b'  assert.fail(1, 2, undefined, '>'); \/\/ AssertionError [ERR_ASSERTION]: 1 > 2  assert.fail(1, 2, 'fail'); \/\/ AssertionError [ERR_ASSERTION]: fail  assert.fail(1, 2, 'whoops', '>'); \/\/ AssertionError [ERR_ASSERTION]: whoops  assert.fail(1, 2, new TypeError('need array')); \/\/ TypeError: need array  In the last three cases actual, expected, and operator have no influence on the error message. Example use of stackStartFn for truncating the exception's stacktrace: function suppressFrame() {   assert.fail('a', 'b', undefined, '!==', suppressFrame); } suppressFrame(); \/\/ AssertionError [ERR_ASSERTION]: 'a' !== 'b' \/\/     at repl:1:1 \/\/     at ContextifyScript.Script.runInThisContext (vm.js:44:33) \/\/     ..."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_iferror_value","title":"`assert.ifError(value)`","description":"Throws value if value is not undefined or null. This is useful when testing the error argument in callbacks. The stack trace contains all frames from the error passed to ifError() including the potential new frames for ifError() itself. const assert = require('assert').strict;  assert.ifError(null); \/\/ OK assert.ifError(0); \/\/ AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0 assert.ifError('error'); \/\/ AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error' assert.ifError(new Error()); \/\/ AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error  \/\/ Create some random error frames. let err; (function errorFrame() {   err = new Error('test error'); })();  (function ifErrorFrame() {   assert.ifError(err); })(); \/\/ AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error \/\/     at ifErrorFrame \/\/     at errorFrame"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_match_string_regexp_message","title":"`assert.match(string, regexp[, message])`","description":"Expects the string input to match the regular expression. This feature is currently experimental and the name might change or it might be completely removed again. const assert = require('assert').strict;  assert.match('I will fail', \/pass\/); \/\/ AssertionError [ERR_ASSERTION]: The input did not match the regular ...  assert.match(123, \/pass\/); \/\/ AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string.  assert.match('I will pass', \/pass\/); \/\/ OK  If the values do not match, or if the string argument is of another type than string, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_notdeepequal_actual_expected_message","title":"`assert.notDeepEqual(actual, expected[, message])`","description":"Strict assertion mode An alias of assert.notDeepStrictEqual(). Legacy assertion mode  Stability: 0 - Deprecated: Use assert.notDeepStrictEqual() instead.  Tests for any deep inequality. Opposite of assert.deepEqual(). const assert = require('assert');  const obj1 = {   a: {     b: 1   } }; const obj2 = {   a: {     b: 2   } }; const obj3 = {   a: {     b: 1   } }; const obj4 = Object.create(obj1);  assert.notDeepEqual(obj1, obj1); \/\/ AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }  assert.notDeepEqual(obj1, obj2); \/\/ OK  assert.notDeepEqual(obj1, obj3); \/\/ AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }  assert.notDeepEqual(obj1, obj4); \/\/ OK  If the values are deeply equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_notdeepstrictequal_actual_expected_message","title":"`assert.notDeepStrictEqual(actual, expected[, message])`","description":"Tests for deep strict inequality. Opposite of assert.deepStrictEqual(). const assert = require('assert').strict;  assert.notDeepStrictEqual({ a: 1 }, { a: '1' }); \/\/ OK  If the values are deeply and strictly equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_notequal_actual_expected_message","title":"`assert.notEqual(actual, expected[, message])`","description":"Strict assertion mode An alias of assert.notStrictEqual(). Legacy assertion mode  Stability: 0 - Deprecated: Use assert.notStrictEqual() instead.  Tests shallow, coercive inequality with the Abstract Equality Comparison (!= ). NaN is special handled and treated as being identical in case both sides are NaN. const assert = require('assert');  assert.notEqual(1, 2); \/\/ OK  assert.notEqual(1, 1); \/\/ AssertionError: 1 != 1  assert.notEqual(1, '1'); \/\/ AssertionError: 1 != '1'  If the values are equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_notstrictequal_actual_expected_message","title":"`assert.notStrictEqual(actual, expected[, message])`","description":"Tests strict inequality between the actual and expected parameters as determined by the SameValue Comparison. const assert = require('assert').strict;  assert.notStrictEqual(1, 2); \/\/ OK  assert.notStrictEqual(1, 1); \/\/ AssertionError [ERR_ASSERTION]: Expected \"actual\" to be strictly unequal to: \/\/ \/\/ 1  assert.notStrictEqual(1, '1'); \/\/ OK  If the values are strictly equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_ok_value_message","title":"`assert.ok(value[, message])`","description":"Tests if value is truthy. It is equivalent to assert.equal(!!value, true, message). If value is not truthy, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError. If no arguments are passed in at all message will be set to the string: 'No value argument passed to `assert.ok()`'. Be aware that in the repl the error message will be different to the one thrown in a file! See below for further details. const assert = require('assert').strict;  assert.ok(true); \/\/ OK assert.ok(1); \/\/ OK  assert.ok(); \/\/ AssertionError: No value argument passed to `assert.ok()`  assert.ok(false, 'it\\'s false'); \/\/ AssertionError: it's false  \/\/ In the repl: assert.ok(typeof 123 === 'string'); \/\/ AssertionError: false == true  \/\/ In a file (e.g. test.js): assert.ok(typeof 123 === 'string'); \/\/ AssertionError: The expression evaluated to a falsy value: \/\/ \/\/   assert.ok(typeof 123 === 'string')  assert.ok(false); \/\/ AssertionError: The expression evaluated to a falsy value: \/\/ \/\/   assert.ok(false)  assert.ok(0); \/\/ AssertionError: The expression evaluated to a falsy value: \/\/ \/\/   assert.ok(0)  \/\/ Using `assert()` works the same: assert(0); \/\/ AssertionError: The expression evaluated to a falsy value: \/\/ \/\/   assert(0)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_rejects_asyncfn_error_message","title":"`assert.rejects(asyncFn[, error][, message])`","description":"Awaits the asyncFn promise or, if asyncFn is a function, immediately calls the function and awaits the returned promise to complete. It will then check that the promise is rejected. If asyncFn is a function and it throws an error synchronously, assert.rejects() will return a rejected Promise with that error. If the function does not return a promise, assert.rejects() will return a rejected Promise with an ERR_INVALID_RETURN_VALUE error. In both cases the error handler is skipped. Besides the async nature to await the completion behaves identically to assert.throws(). If specified, error can be a Class, RegExp, a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable message and name properties. If specified, message will be the message provided by the AssertionError if the asyncFn fails to reject. (async () => {   await assert.rejects(     async () => {       throw new TypeError('Wrong value');     },     {       name: 'TypeError',       message: 'Wrong value'     }   ); })();  (async () => {   await assert.rejects(     async () => {       throw new TypeError('Wrong value');     },     (err) => {       assert.strictEqual(err.name, 'TypeError');       assert.strictEqual(err.message, 'Wrong value');       return true;     }   ); })();  assert.rejects(   Promise.reject(new Error('Wrong value')),   Error ).then(() => {   \/\/ ... });  error cannot be a string. If a string is provided as the second argument, then error is assumed to be omitted and the string will be used for message instead. This can lead to easy-to-miss mistakes. Please read the example in assert.throws() carefully if using a string as the second argument gets considered."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_strictequal_actual_expected_message","title":"`assert.strictEqual(actual, expected[, message])`","description":"Tests strict equality between the actual and expected parameters as determined by the SameValue Comparison. const assert = require('assert').strict;  assert.strictEqual(1, 2); \/\/ AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal: \/\/ \/\/ 1 !== 2  assert.strictEqual(1, 1); \/\/ OK  assert.strictEqual('Hello foobar', 'Hello World!'); \/\/ AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal: \/\/ + actual - expected \/\/ \/\/ + 'Hello foobar' \/\/ - 'Hello World!' \/\/          ^  const apples = 1; const oranges = 2; assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`); \/\/ AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2  assert.strictEqual(1, '1', new TypeError('Inputs are not identical')); \/\/ TypeError: Inputs are not identical  If the values are not strictly equal, an AssertionError is thrown with a message property set equal to the value of the message parameter. If the message parameter is undefined, a default error message is assigned. If the message parameter is an instance of an Error then it will be thrown instead of the AssertionError."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assert_throws_fn_error_message","title":"`assert.throws(fn[, error][, message])`","description":"Expects the function fn to throw an error. If specified, error can be a Class, RegExp, a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable message and name properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples. If specified, message will be appended to the message provided by the AssertionError if the fn call fails to throw or in case the error validation fails. Custom validation object\/error instance: const err = new TypeError('Wrong value'); err.code = 404; err.foo = 'bar'; err.info = {   nested: true,   baz: 'text' }; err.reg = \/abc\/i;  assert.throws(   () => {     throw err;   },   {     name: 'TypeError',     message: 'Wrong value',     info: {       nested: true,       baz: 'text'     }     \/\/ Only properties on the validation object will be tested for.     \/\/ Using nested objects requires all properties to be present. Otherwise     \/\/ the validation is going to fail.   } );  \/\/ Using regular expressions to validate error properties: assert.throws(   () => {     throw err;   },   {     \/\/ The `name` and `message` properties are strings and using regular     \/\/ expressions on those will match against the string. If they fail, an     \/\/ error is thrown.     name: \/^TypeError$\/,     message: \/Wrong\/,     foo: 'bar',     info: {       nested: true,       \/\/ It is not possible to use regular expressions for nested properties!       baz: 'text'     },     \/\/ The `reg` property contains a regular expression and only if the     \/\/ validation object contains an identical regular expression, it is going     \/\/ to pass.     reg: \/abc\/i   } );  \/\/ Fails due to the different `message` and `name` properties: assert.throws(   () => {     const otherErr = new Error('Not found');     \/\/ Copy all enumerable properties from `err` to `otherErr`.     for (const [key, value] of Object.entries(err)) {       otherErr[key] = value;     }     throw otherErr;   },   \/\/ The error's `message` and `name` properties will also be checked when using   \/\/ an error as validation object.   err );  Validate instanceof using constructor: assert.throws(   () => {     throw new Error('Wrong value');   },   Error );  Validate error message using RegExp: Using a regular expression runs .toString on the error object, and will therefore also include the error name. assert.throws(   () => {     throw new Error('Wrong value');   },   \/^Error: Wrong value$\/ );  Custom error validation: The function must return true to indicate all internal validations passed. It will otherwise fail with an AssertionError. assert.throws(   () => {     throw new Error('Wrong value');   },   (err) => {     assert(err instanceof Error);     assert(\/value\/.test(err));     \/\/ Avoid returning anything from validation functions besides `true`.     \/\/ Otherwise, it's not clear what part of the validation failed. Instead,     \/\/ throw an error about the specific validation that failed (as done in this     \/\/ example) and add as much helpful debugging information to that error as     \/\/ possible.     return true;   },   'unexpected error' );  error cannot be a string. If a string is provided as the second argument, then error is assumed to be omitted and the string will be used for message instead. This can lead to easy-to-miss mistakes. Using the same message as the thrown error message is going to result in an ERR_AMBIGUOUS_ARGUMENT error. Please read the example below carefully if using a string as the second argument gets considered:  function throwingFirst() {   throw new Error('First'); }  function throwingSecond() {   throw new Error('Second'); }  function notThrowing() {}  \/\/ The second argument is a string and the input function threw an Error. \/\/ The first case will not throw as it does not match for the error message \/\/ thrown by the input function! assert.throws(throwingFirst, 'Second'); \/\/ In the next example the message has no benefit over the message from the \/\/ error and since it is not clear if the user intended to actually match \/\/ against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error. assert.throws(throwingSecond, 'Second'); \/\/ TypeError [ERR_AMBIGUOUS_ARGUMENT]  \/\/ The string is only used (as message) in case the function does not throw: assert.throws(notThrowing, 'Second'); \/\/ AssertionError [ERR_ASSERTION]: Missing expected exception: Second  \/\/ If it was intended to match for the error message do this instead: \/\/ It does not throw because the error messages match. assert.throws(throwingSecond, \/Second$\/);  \/\/ If the error message does not match, an AssertionError is thrown. assert.throws(throwingFirst, \/Second$\/); \/\/ AssertionError [ERR_ASSERTION]  Due to the confusing error-prone notation, avoid a string as the second argument."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_strict_assertion_mode","title":"Strict assertion mode","description":"In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example, assert.deepEqual() will behave like assert.deepStrictEqual(). In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error messages for objects display the objects, often truncated. To use strict assertion mode: const assert = require('assert').strict;  const assert = require('assert\/strict');  Example error diff: const assert = require('assert').strict;  assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]); \/\/ AssertionError: Expected inputs to be strictly deep-equal: \/\/ + actual - expected ... Lines skipped \/\/ \/\/   [ \/\/     [ \/\/ ... \/\/       2, \/\/ +     3 \/\/ -     '3' \/\/     ], \/\/ ... \/\/     5 \/\/   ]  To deactivate the colors, use the NO_COLOR or NODE_DISABLE_COLORS environment variables. This will also deactivate the colors in the REPL. For more on color support in terminal environments, read the tty getColorDepth() documentation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_legacy_assertion_mode","title":"Legacy assertion mode","description":"Legacy assertion mode uses the Abstract Equality Comparison in:  assert.deepEqual() assert.equal() assert.notDeepEqual() assert.notEqual()  To use legacy assertion mode: const assert = require('assert');  Whenever possible, use the strict assertion mode instead. Otherwise, the Abstract Equality Comparison may cause surprising results. This is especially true for assert.deepEqual(), where the comparison rules are lax: \/\/ WARNING: This does not throw an AssertionError! assert.deepEqual(\/a\/gi, new Date());"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_async_hooks","title":"Async hooks","description":"Source Code: lib\/async_hooks.js The async_hooks module provides an API to track asynchronous resources. It can be accessed using: const async_hooks = require('async_hooks');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_terminology","title":"Terminology","description":"An asynchronous resource represents an object with an associated callback. This callback may be called multiple times, for example, the 'connection' event in net.createServer(), or just a single time like in fs.open(). A resource can also be closed before the callback is called. AsyncHook does not explicitly distinguish between these different cases but will represent them as the abstract concept that is a resource. If Workers are used, each thread has an independent async_hooks interface, and each thread will use a new set of async IDs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_public_api","title":"Public API","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_overview","title":"Overview","description":"Following is a simple overview of the public API. const async_hooks = require('async_hooks');  \/\/ Return the ID of the current execution context. const eid = async_hooks.executionAsyncId();  \/\/ Return the ID of the handle responsible for triggering the callback of the \/\/ current execution scope to call. const tid = async_hooks.triggerAsyncId();  \/\/ Create a new AsyncHook instance. All of these callbacks are optional. const asyncHook =     async_hooks.createHook({ init, before, after, destroy, promiseResolve });  \/\/ Allow callbacks of this AsyncHook instance to call. This is not an implicit \/\/ action after running the constructor, and must be explicitly run to begin \/\/ executing callbacks. asyncHook.enable();  \/\/ Disable listening for new asynchronous events. asyncHook.disable();  \/\/ \/\/ The following are the callbacks that can be passed to createHook(). \/\/  \/\/ init is called during object construction. The resource may not have \/\/ completed construction when this callback runs, therefore all fields of the \/\/ resource referenced by \"asyncId\" may not have been populated. function init(asyncId, type, triggerAsyncId, resource) { }  \/\/ Before is called just before the resource's callback is called. It can be \/\/ called 0-N times for handles (e.g. TCPWrap), and will be called exactly 1 \/\/ time for requests (e.g. FSReqCallback). function before(asyncId) { }  \/\/ After is called just after the resource's callback has finished. function after(asyncId) { }  \/\/ Destroy is called when the resource is destroyed. function destroy(asyncId) { }  \/\/ promiseResolve is called only for promise resources, when the \/\/ `resolve` function passed to the `Promise` constructor is invoked \/\/ (either directly or through other means of resolving a promise). function promiseResolve(asyncId) { }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_async_hooks_createhook_callbacks","title":"`async_hooks.createHook(callbacks)`","description":"Registers functions to be called for different lifetime events of each async operation. The callbacks init()\/before()\/after()\/destroy() are called for the respective asynchronous event during a resource's lifetime. All callbacks are optional. For example, if only resource cleanup needs to be tracked, then only the destroy callback needs to be passed. The specifics of all functions that can be passed to callbacks is in the Hook Callbacks section. const async_hooks = require('async_hooks');  const asyncHook = async_hooks.createHook({   init(asyncId, type, triggerAsyncId, resource) { },   destroy(asyncId) { } });  The callbacks will be inherited via the prototype chain: class MyAsyncCallbacks {   init(asyncId, type, triggerAsyncId, resource) { }   destroy(asyncId) {} }  class MyAddedCallbacks extends MyAsyncCallbacks {   before(asyncId) { }   after(asyncId) { } }  const asyncHook = async_hooks.createHook(new MyAddedCallbacks());"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_handling","title":"Error handling","description":"If any AsyncHook callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all 'uncaughtException' listeners are removed, thus forcing the process to exit. The 'exit' callbacks will still be called unless the application is run with --abort-on-uncaught-exception, in which case a stack trace will be printed and the application exits, leaving a core file. The reason for this error handling behavior is that these callbacks are running at potentially volatile points in an object's lifetime, for example during class construction and destruction. Because of this, it is deemed necessary to bring down the process quickly in order to prevent an unintentional abort in the future. This is subject to change in the future if a comprehensive analysis is performed to ensure an exception can follow the normal control flow without unintentional side effects."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_printing_in_asynchooks_callbacks","title":"Printing in AsyncHooks callbacks","description":"Because printing to the console is an asynchronous operation, console.log() will cause the AsyncHooks callbacks to be called. Using console.log() or similar asynchronous operations inside an AsyncHooks callback function will thus cause an infinite recursion. An easy solution to this when debugging is to use a synchronous logging operation such as fs.writeFileSync(file, msg, flag). This will print to the file and will not invoke AsyncHooks recursively because it is synchronous. const fs = require('fs'); const util = require('util');  function debug(...args) {   \/\/ Use a function like this one when debugging inside an AsyncHooks callback   fs.writeFileSync('log.out', `${util.format(...args)}\\n`, { flag: 'a' }); }  If an asynchronous operation is needed for logging, it is possible to keep track of what caused the asynchronous operation using the information provided by AsyncHooks itself. The logging should then be skipped when it was the logging itself that caused AsyncHooks callback to call. By doing this the otherwise infinite recursion is broken."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_promise_execution_tracking","title":"Promise execution tracking","description":"By default, promise executions are not assigned asyncIds due to the relatively expensive nature of the promise introspection API provided by V8. This means that programs using promises or async\/await will not get correct execution and trigger ids for promise callback contexts by default. const ah = require('async_hooks'); Promise.resolve(1729).then(() => {   console.log(`eid ${ah.executionAsyncId()} tid ${ah.triggerAsyncId()}`); }); \/\/ produces: \/\/ eid 1 tid 0  Observe that the then() callback claims to have executed in the context of the outer scope even though there was an asynchronous hop involved. Also, the triggerAsyncId value is 0, which means that we are missing context about the resource that caused (triggered) the then() callback to be executed. Installing async hooks via async_hooks.createHook enables promise execution tracking: const ah = require('async_hooks'); ah.createHook({ init() {} }).enable(); \/\/ forces PromiseHooks to be enabled. Promise.resolve(1729).then(() => {   console.log(`eid ${ah.executionAsyncId()} tid ${ah.triggerAsyncId()}`); }); \/\/ produces: \/\/ eid 7 tid 6  In this example, adding any actual hook function enabled the tracking of promises. There are two promises in the example above; the promise created by Promise.resolve() and the promise returned by the call to then(). In the example above, the first promise got the asyncId 6 and the latter got asyncId 7. During the execution of the then() callback, we are executing in the context of promise with asyncId 7. This promise was triggered by async resource 6. Another subtlety with promises is that before and after callbacks are run only on chained promises. That means promises not created by then()\/catch() will not have the before and after callbacks fired on them. For more details see the details of the V8 PromiseHooks API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_javascript_embedder_api","title":"JavaScript embedder API","description":"Library developers that handle their own asynchronous resources performing tasks like I\/O, connection pooling, or managing callback queues may use the AsyncResource JavaScript API so that all the appropriate callbacks are called."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_using_asyncresource_for_a_worker_thread_pool","title":"Using `AsyncResource` for a `Worker` thread pool","description":"The following example shows how to use the AsyncResource class to properly provide async tracking for a Worker pool. Other resource pools, such as database connection pools, can follow a similar model. Assuming that the task is adding two numbers, using a file named task_processor.js with the following content: const { parentPort } = require('worker_threads'); parentPort.on('message', (task) => {   parentPort.postMessage(task.a + task.b); });  a Worker pool around it could use the following structure: const { AsyncResource } = require('async_hooks'); const { EventEmitter } = require('events'); const path = require('path'); const { Worker } = require('worker_threads');  const kTaskInfo = Symbol('kTaskInfo'); const kWorkerFreedEvent = Symbol('kWorkerFreedEvent');  class WorkerPoolTaskInfo extends AsyncResource {   constructor(callback) {     super('WorkerPoolTaskInfo');     this.callback = callback;   }    done(err, result) {     this.runInAsyncScope(this.callback, null, err, result);     this.emitDestroy();  \/\/ `TaskInfo`s are used only once.   } }  class WorkerPool extends EventEmitter {   constructor(numThreads) {     super();     this.numThreads = numThreads;     this.workers = [];     this.freeWorkers = [];      for (let i = 0; i < numThreads; i++)       this.addNewWorker();   }    addNewWorker() {     const worker = new Worker(path.resolve(__dirname, 'task_processor.js'));     worker.on('message', (result) => {       \/\/ In case of success: Call the callback that was passed to `runTask`,       \/\/ remove the `TaskInfo` associated with the Worker, and mark it as free       \/\/ again.       worker[kTaskInfo].done(null, result);       worker[kTaskInfo] = null;       this.freeWorkers.push(worker);       this.emit(kWorkerFreedEvent);     });     worker.on('error', (err) => {       \/\/ In case of an uncaught exception: Call the callback that was passed to       \/\/ `runTask` with the error.       if (worker[kTaskInfo])         worker[kTaskInfo].done(err, null);       else         this.emit('error', err);       \/\/ Remove the worker from the list and start a new Worker to replace the       \/\/ current one.       this.workers.splice(this.workers.indexOf(worker), 1);       this.addNewWorker();     });     this.workers.push(worker);     this.freeWorkers.push(worker);     this.emit(kWorkerFreedEvent);   }    runTask(task, callback) {     if (this.freeWorkers.length === 0) {       \/\/ No free threads, wait until a worker thread becomes free.       this.once(kWorkerFreedEvent, () => this.runTask(task, callback));       return;     }      const worker = this.freeWorkers.pop();     worker[kTaskInfo] = new WorkerPoolTaskInfo(callback);     worker.postMessage(task);   }    close() {     for (const worker of this.workers) worker.terminate();   } }  module.exports = WorkerPool;  Without the explicit tracking added by the WorkerPoolTaskInfo objects, it would appear that the callbacks are associated with the individual Worker objects. However, the creation of the Workers is not associated with the creation of the tasks and does not provide information about when tasks were scheduled. This pool could be used as follows: const WorkerPool = require('.\/worker_pool.js'); const os = require('os');  const pool = new WorkerPool(os.cpus().length);  let finished = 0; for (let i = 0; i < 10; i++) {   pool.runTask({ a: 42, b: 100 }, (err, result) => {     console.log(i, err, result);     if (++finished === 10)       pool.close();   }); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_integrating_asyncresource_with_eventemitter","title":"Integrating `AsyncResource` with `EventEmitter`","description":"Event listeners triggered by an EventEmitter may be run in a different execution context than the one that was active when eventEmitter.on() was called. The following example shows how to use the AsyncResource class to properly associate an event listener with the correct execution context. The same approach can be applied to a Stream or a similar event-driven class. const { createServer } = require('http'); const { AsyncResource, executionAsyncId } = require('async_hooks');  const server = createServer((req, res) => {   req.on('close', AsyncResource.bind(() => {     \/\/ Execution context is bound to the current outer scope.   }));   req.on('close', () => {     \/\/ Execution context is bound to the scope that caused 'close' to emit.   });   res.end(); }).listen(3000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffer","title":"Buffer","description":"Source Code: lib\/buffer.js Buffer objects are used to represent a fixed-length sequence of bytes. Many Node.js APIs support Buffers. The Buffer class is a subclass of JavaScript's Uint8Array class and extends it with methods that cover additional use cases. Node.js APIs accept plain Uint8Arrays wherever Buffers are supported as well. The Buffer class is within the global scope, making it unlikely that one would need to ever use require('buffer').Buffer. \/\/ Creates a zero-filled Buffer of length 10. const buf1 = Buffer.alloc(10);  \/\/ Creates a Buffer of length 10, \/\/ filled with bytes which all have the value `1`. const buf2 = Buffer.alloc(10, 1);  \/\/ Creates an uninitialized buffer of length 10. \/\/ This is faster than calling Buffer.alloc() but the returned \/\/ Buffer instance might contain old data that needs to be \/\/ overwritten using fill(), write(), or other functions that fill the Buffer's \/\/ contents. const buf3 = Buffer.allocUnsafe(10);  \/\/ Creates a Buffer containing the bytes [1, 2, 3]. const buf4 = Buffer.from([1, 2, 3]);  \/\/ Creates a Buffer containing the bytes [1, 1, 1, 1] \u2013 the entries \/\/ are all truncated using `(value & 255)` to fit into the range 0\u2013255. const buf5 = Buffer.from([257, 257.5, -255, '1']);  \/\/ Creates a Buffer containing the UTF-8-encoded bytes for the string 't\u00e9st': \/\/ [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation) \/\/ [116, 195, 169, 115, 116] (in decimal notation) const buf6 = Buffer.from('t\u00e9st');  \/\/ Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74]. const buf7 = Buffer.from('t\u00e9st', 'latin1');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffers_and_character_encodings","title":"Buffers and character encodings","description":"When converting between Buffers and strings, a character encoding may be specified. If no character encoding is specified, UTF-8 will be used as the default. const buf = Buffer.from('hello world', 'utf8');  console.log(buf.toString('hex')); \/\/ Prints: 68656c6c6f20776f726c64 console.log(buf.toString('base64')); \/\/ Prints: aGVsbG8gd29ybGQ=  console.log(Buffer.from('fhqwhgads', 'utf8')); \/\/ Prints: <Buffer 66 68 71 77 68 67 61 64 73> console.log(Buffer.from('fhqwhgads', 'utf16le')); \/\/ Prints: <Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00>  The character encodings currently supported by Node.js are the following:   'utf8': Multi-byte encoded Unicode characters. Many web pages and other document formats use UTF-8. This is the default character encoding. When decoding a Buffer into a string that does not exclusively contain valid UTF-8 data, the Unicode replacement character U+FFFD \ufffd will be used to represent those errors.   'utf16le': Multi-byte encoded Unicode characters. Unlike 'utf8', each character in the string will be encoded using either 2 or 4 bytes. Node.js only supports the little-endian variant of UTF-16.   'latin1': Latin-1 stands for ISO-8859-1. This character encoding only supports the Unicode characters from U+0000 to U+00FF. Each character is encoded using a single byte. Characters that do not fit into that range are truncated and will be mapped to characters in that range.   Converting a Buffer into a string using one of the above is referred to as decoding, and converting a string into a Buffer is referred to as encoding. Node.js also supports the following two binary-to-text encodings. For binary-to-text encodings, the naming convention is reversed: Converting a Buffer into a string is typically referred to as encoding, and converting a string into a Buffer as decoding.   'base64': Base64 encoding. When creating a Buffer from a string, this encoding will also correctly accept \"URL and Filename Safe Alphabet\" as specified in RFC 4648, Section 5. Whitespace characters such as spaces, tabs, and new lines contained within the base64-encoded string are ignored.   'hex': Encode each byte as two hexadecimal characters. Data truncation may occur when decoding strings that do exclusively contain valid hexadecimal characters. See below for an example.   The following legacy character encodings are also supported:   'ascii': For 7-bit ASCII data only. When encoding a string into a Buffer, this is equivalent to using 'latin1'. When decoding a Buffer into a string, using this encoding will additionally unset the highest bit of each byte before decoding as 'latin1'. Generally, there should be no reason to use this encoding, as 'utf8' (or, if the data is known to always be ASCII-only, 'latin1') will be a better choice when encoding or decoding ASCII-only text. It is only provided for legacy compatibility.   'binary': Alias for 'latin1'. See binary strings for more background on this topic. The name of this encoding can be very misleading, as all of the encodings listed here convert between strings and binary data. For converting between strings and Buffers, typically 'utf-8' is the right choice.   'ucs2': Alias of 'utf16le'. UCS-2 used to refer to a variant of UTF-16 that did not support characters that had code points larger than U+FFFF. In Node.js, these code points are always supported.   Buffer.from('1ag', 'hex'); \/\/ Prints <Buffer 1a>, data truncated when first non-hexadecimal value \/\/ ('g') encountered.  Buffer.from('1a7g', 'hex'); \/\/ Prints <Buffer 1a>, data truncated when data ends in single digit ('7').  Buffer.from('1634', 'hex'); \/\/ Prints <Buffer 16 34>, all data represented.  Modern Web browsers follow the WHATWG Encoding Standard which aliases both 'latin1' and 'ISO-8859-1' to 'win-1252'. This means that while doing something like http.get(), if the returned charset is one of those listed in the WHATWG specification it is possible that the server actually returned 'win-1252'-encoded data, and using 'latin1' encoding may incorrectly decode the characters."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffers_and_typedarrays","title":"Buffers and TypedArrays","description":"Buffer instances are also JavaScript Uint8Array and TypedArray instances. All TypedArray methods are available on Buffers. There are, however, subtle incompatibilities between the Buffer API and the TypedArray API. In particular:  While TypedArray#slice() creates a copy of part of the TypedArray, Buffer#slice() creates a view over the existing Buffer without copying. This behavior can be surprising, and only exists for legacy compatibility. TypedArray#subarray() can be used to achieve the behavior of Buffer#slice() on both Buffers and other TypedArrays. buf.toString() is incompatible with its TypedArray equivalent. A number of methods, e.g. buf.indexOf(), support additional arguments.  There are two ways to create new TypedArray instances from a Buffer:  Passing a Buffer to a TypedArray constructor will copy the Buffers contents, interpreted as an array of integers, and not as a byte sequence of the target type.  const buf = Buffer.from([1, 2, 3, 4]); const uint32array = new Uint32Array(buf);  console.log(uint32array);  \/\/ Prints: Uint32Array(4) [ 1, 2, 3, 4 ]   Passing the Buffers underlying ArrayBuffer will create a TypedArray that shares its memory with the Buffer.  const buf = Buffer.from('hello', 'utf16le'); const uint16arr = new Uint16Array(   buf.buffer,   buf.byteOffset,   buf.length \/ Uint16Array.BYTES_PER_ELEMENT);  console.log(uint16array);  \/\/ Prints: Uint16Array(5) [ 104, 101, 108, 108, 111 ]  It is possible to create a new Buffer that shares the same allocated memory as a TypedArray instance by using the TypedArray object\u2019s .buffer property in the same way. Buffer.from() behaves like new Uint8Array() in this context. const arr = new Uint16Array(2);  arr[0] = 5000; arr[1] = 4000;  \/\/ Copies the contents of `arr`. const buf1 = Buffer.from(arr);  \/\/ Shares memory with `arr`. const buf2 = Buffer.from(arr.buffer);  console.log(buf1); \/\/ Prints: <Buffer 88 a0> console.log(buf2); \/\/ Prints: <Buffer 88 13 a0 0f>  arr[1] = 6000;  console.log(buf1); \/\/ Prints: <Buffer 88 a0> console.log(buf2); \/\/ Prints: <Buffer 88 13 70 17>  When creating a Buffer using a TypedArray's .buffer, it is possible to use only a portion of the underlying ArrayBuffer by passing in byteOffset and length parameters. const arr = new Uint16Array(20); const buf = Buffer.from(arr.buffer, 0, 16);  console.log(buf.length); \/\/ Prints: 16  The Buffer.from() and TypedArray.from() have different signatures and implementations. Specifically, the TypedArray variants accept a second argument that is a mapping function that is invoked on every element of the typed array:  TypedArray.from(source[, mapFn[, thisArg]])  The Buffer.from() method, however, does not support the use of a mapping function:  Buffer.from(array) Buffer.from(buffer) Buffer.from(arrayBuffer[, byteOffset[, length]]) Buffer.from(string[, encoding])"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffers_and_iteration","title":"Buffers and iteration","description":"Buffer instances can be iterated over using for..of syntax: const buf = Buffer.from([1, 2, 3]);  for (const b of buf) {   console.log(b); } \/\/ Prints: \/\/   1 \/\/   2 \/\/   3  Additionally, the buf.values(), buf.keys(), and buf.entries() methods can be used to create iterators."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffer_module_apis","title":"`buffer` module APIs","description":"While, the Buffer object is available as a global, there are additional Buffer-related APIs that are available only via the buffer module accessed using require('buffer')."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffer_transcode_source_fromenc_toenc","title":"`buffer.transcode(source, fromEnc, toEnc)`","description":"Re-encodes the given Buffer or Uint8Array instance from one character encoding to another. Returns a new Buffer instance. Throws if the fromEnc or toEnc specify invalid character encodings or if conversion from fromEnc to toEnc is not permitted. Encodings supported by buffer.transcode() are: 'ascii', 'utf8', 'utf16le', 'ucs2', 'latin1', and 'binary'. The transcoding process will use substitution characters if a given byte sequence cannot be adequately represented in the target encoding. For instance: const buffer = require('buffer');  const newBuf = buffer.transcode(Buffer.from('\u20ac'), 'utf8', 'ascii'); console.log(newBuf.toString('ascii')); \/\/ Prints: '?'  Because the Euro (\u20ac) sign is not representable in US-ASCII, it is replaced with ? in the transcoded Buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffer_constants","title":"Buffer constants","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffer_from_buffer_alloc_and_buffer_allocunsafe","title":"`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`","description":"In versions of Node.js prior to 6.0.0, Buffer instances were created using the Buffer constructor function, which allocates the returned Buffer differently based on what arguments are provided:  Passing a number as the first argument to Buffer() (e.g. new Buffer(10)) allocates a new Buffer object of the specified size. Prior to Node.js 8.0.0, the memory allocated for such Buffer instances is not initialized and can contain sensitive data. Such Buffer instances must be subsequently initialized by using either buf.fill(0) or by writing to the entire Buffer before reading data from the Buffer. While this behavior is intentional to improve performance, development experience has demonstrated that a more explicit distinction is required between creating a fast-but-uninitialized Buffer versus creating a slower-but-safer Buffer. Since Node.js 8.0.0, Buffer(num) and new Buffer(num) return a Buffer with initialized memory. Passing a string, array, or Buffer as the first argument copies the passed object's data into the Buffer. Passing an ArrayBuffer or a SharedArrayBuffer returns a Buffer that shares allocated memory with the given array buffer.  Because the behavior of new Buffer() is different depending on the type of the first argument, security and reliability issues can be inadvertently introduced into applications when argument validation or Buffer initialization is not performed. For example, if an attacker can cause an application to receive a number where a string is expected, the application may call new Buffer(100) instead of new Buffer(\"100\"), leading it to allocate a 100 byte buffer instead of allocating a 3 byte buffer with content \"100\". This is commonly possible using JSON API calls. Since JSON distinguishes between numeric and string types, it allows injection of numbers where a naively written application that does not validate its input sufficiently might expect to always receive a string. Before Node.js 8.0.0, the 100 byte buffer might contain arbitrary pre-existing in-memory data, so may be used to expose in-memory secrets to a remote attacker. Since Node.js 8.0.0, exposure of memory cannot occur because the data is zero-filled. However, other attacks are still possible, such as causing very large buffers to be allocated by the server, leading to performance degradation or crashing on memory exhaustion. To make the creation of Buffer instances more reliable and less error-prone, the various forms of the new Buffer() constructor have been deprecated and replaced by separate Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe() methods. Developers should migrate all existing uses of the new Buffer() constructors to one of these new APIs.  Buffer.from(array) returns a new Buffer that contains a copy of the provided octets. Buffer.from(arrayBuffer[, byteOffset[, length]]) returns a new Buffer that shares the same allocated memory as the given ArrayBuffer. Buffer.from(buffer) returns a new Buffer that contains a copy of the contents of the given Buffer. Buffer.from(string[, encoding]) returns a new Buffer that contains a copy of the provided string. Buffer.alloc(size[, fill[, encoding]]) returns a new initialized Buffer of the specified size. This method is slower than Buffer.allocUnsafe(size) but guarantees that newly created Buffer instances never contain old data that is potentially sensitive. A TypeError will be thrown if size is not a number. Buffer.allocUnsafe(size) and Buffer.allocUnsafeSlow(size) each return a new uninitialized Buffer of the specified size. Because the Buffer is uninitialized, the allocated segment of memory might contain old data that is potentially sensitive.  Buffer instances returned by Buffer.allocUnsafe() and Buffer.from(array) may be allocated off a shared internal memory pool if size is less than or equal to half Buffer.poolSize. Instances returned by Buffer.allocUnsafeSlow() never use the shared internal memory pool."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_zero_fill_buffers_command_line_option","title":"The `--zero-fill-buffers` command-line option","description":"Node.js can be started using the --zero-fill-buffers command-line option to cause all newly-allocated Buffer instances to be zero-filled upon creation by default. Without the option, buffers created with Buffer.allocUnsafe(), Buffer.allocUnsafeSlow(), and new SlowBuffer(size) are not zero-filled. Use of this flag can have a measurable negative impact on performance. Use the --zero-fill-buffers option only when necessary to enforce that newly allocated Buffer instances cannot contain old data that is potentially sensitive. $ node --zero-fill-buffers > Buffer.allocUnsafe(5); <Buffer 00 00 00 00 00>"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe","title":"What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?","description":"When calling Buffer.allocUnsafe() and Buffer.allocUnsafeSlow(), the segment of allocated memory is uninitialized (it is not zeroed-out). While this design makes the allocation of memory quite fast, the allocated segment of memory might contain old data that is potentially sensitive. Using a Buffer created by Buffer.allocUnsafe() without completely overwriting the memory can allow this old data to be leaked when the Buffer memory is read. While there are clear performance advantages to using Buffer.allocUnsafe(), extra care must be taken in order to avoid introducing security vulnerabilities into an application."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_c_embedder_api","title":"C++ embedder API","description":"Node.js provides a number of C++ APIs that can be used to execute JavaScript in a Node.js environment from other C++ software. The documentation for these APIs can be found in src\/node.h in the Node.js source tree. In addition to the APIs exposed by Node.js, some required concepts are provided by the V8 embedder API. Because using Node.js as an embedded library is different from writing code that is executed by Node.js, breaking changes do not follow typical Node.js deprecation policy and may occur on each semver-major release without prior warning. Example embedding application The following sections will provide an overview over how to use these APIs to create an application from scratch that will perform the equivalent of node -e <code>, i.e. that will take a piece of JavaScript and run it in a Node.js-specific environment. The full code can be found in the Node.js source tree."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setting_up_per_process_state","title":"Setting up per-process state","description":"Node.js requires some per-process state management in order to run:  Arguments parsing for Node.js CLI options, V8 per-process requirements, such as a v8::Platform instance.  The following example shows how these can be set up. Some class names are from the node and v8 C++ namespaces, respectively. int main(int argc, char** argv) {   argv = uv_setup_args(argc, argv);   std::vector<std::string> args(argv, argv + argc);   std::vector<std::string> exec_args;   std::vector<std::string> errors;   \/\/ Parse Node.js CLI options, and print any errors that have occurred while   \/\/ trying to parse them.   int exit_code = node::InitializeNodeWithArgs(&args, &exec_args, &errors);   for (const std::string& error : errors)     fprintf(stderr, \"%s: %s\\n\", args[0].c_str(), error.c_str());   if (exit_code != 0) {     return exit_code;   }    \/\/ Create a v8::Platform instance. `MultiIsolatePlatform::Create()` is a way   \/\/ to create a v8::Platform instance that Node.js can use when creating   \/\/ Worker threads. When no `MultiIsolatePlatform` instance is present,   \/\/ Worker threads are disabled.   std::unique_ptr<MultiIsolatePlatform> platform =       MultiIsolatePlatform::Create(4);   V8::InitializePlatform(platform.get());   V8::Initialize();    \/\/ See below for the contents of this function.   int ret = RunNodeInstance(platform.get(), args, exec_args);    V8::Dispose();   V8::ShutdownPlatform();   return ret; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_per_instance_state","title":"Per-instance state","description":"Node.js has a concept of a \u201cNode.js instance\u201d, that is commonly being referred to as node::Environment. Each node::Environment is associated with:  Exactly one v8::Isolate, i.e. one JS Engine instance, Exactly one uv_loop_t, i.e. one event loop, and A number of v8::Contexts, but exactly one main v8::Context. One node::IsolateData instance that contains information that could be shared by multiple node::Environments that use the same v8::Isolate. Currently, no testing if performed for this scenario.  In order to set up a v8::Isolate, an v8::ArrayBuffer::Allocator needs to be provided. One possible choice is the default Node.js allocator, which can be created through node::ArrayBufferAllocator::Create(). Using the Node.js allocator allows minor performance optimizations when addons use the Node.js C++ Buffer API, and is required in order to track ArrayBuffer memory in process.memoryUsage(). Additionally, each v8::Isolate that is used for a Node.js instance needs to be registered and unregistered with the MultiIsolatePlatform instance, if one is being used, in order for the platform to know which event loop to use for tasks scheduled by the v8::Isolate. The node::NewIsolate() helper function creates a v8::Isolate, sets it up with some Node.js-specific hooks (e.g. the Node.js error handler), and registers it with the platform automatically. int RunNodeInstance(MultiIsolatePlatform* platform,                     const std::vector<std::string>& args,                     const std::vector<std::string>& exec_args) {   int exit_code = 0;    \/\/ Setup up a libuv event loop, v8::Isolate, and Node.js Environment.   std::vector<std::string> errors;   std::unique_ptr<CommonEnvironmentSetup> setup =       CommonEnvironmentSetup::Create(platform, &errors, args, exec_args);   if (!setup) {     for (const std::string& err : errors)       fprintf(stderr, \"%s: %s\\n\", args[0].c_str(), err.c_str());     return 1;   }    Isolate* isolate = setup->isolate();   Environment* env = setup->env();    {     Locker locker(isolate);     Isolate::Scope isolate_scope(isolate);     \/\/ The v8::Context needs to be entered when node::CreateEnvironment() and     \/\/ node::LoadEnvironment() are being called.     Context::Scope context_scope(setup->context());      \/\/ Set up the Node.js instance for execution, and run code inside of it.     \/\/ There is also a variant that takes a callback and provides it with     \/\/ the `require` and `process` objects, so that it can manually compile     \/\/ and run scripts as needed.     \/\/ The `require` function inside this script does *not* access the file     \/\/ system, and can only load built-in Node.js modules.     \/\/ `module.createRequire()` is being used to create one that is able to     \/\/ load files from the disk, and uses the standard CommonJS file loader     \/\/ instead of the internal-only `require` function.     MaybeLocal<Value> loadenv_ret = node::LoadEnvironment(         env,         \"const publicRequire =\"         \"  require('module').createRequire(process.cwd() + '\/');\"         \"globalThis.require = publicRequire;\"         \"require('vm').runInThisContext(process.argv[1]);\");      if (loadenv_ret.IsEmpty())  \/\/ There has been a JS exception.       return 1;      exit_code = node::SpinEventLoop(env).FromMaybe(1);      \/\/ node::Stop() can be used to explicitly stop the event loop and keep     \/\/ further JavaScript from running. It can be called from any thread,     \/\/ and will act like worker.terminate() if called from another thread.     node::Stop(env);   }    return exit_code; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process","title":"Child process","description":"Source Code: lib\/child_process.js The child_process module provides the ability to spawn subprocesses in a manner that is similar, but not identical, to popen(3). This capability is primarily provided by the child_process.spawn() function: const { spawn } = require('child_process'); const ls = spawn('ls', ['-lh', '\/usr']);  ls.stdout.on('data', (data) => {   console.log(`stdout: ${data}`); });  ls.stderr.on('data', (data) => {   console.error(`stderr: ${data}`); });  ls.on('close', (code) => {   console.log(`child process exited with code ${code}`); });  By default, pipes for stdin, stdout, and stderr are established between the parent Node.js process and the spawned subprocess. These pipes have limited (and platform-specific) capacity. If the subprocess writes to stdout in excess of that limit without the output being captured, the subprocess blocks waiting for the pipe buffer to accept more data. This is identical to the behavior of pipes in the shell. Use the { stdio: 'ignore' } option if the output will not be consumed. The command lookup is performed using the options.env.PATH environment variable if it is in the options object. Otherwise, process.env.PATH is used. On Windows, environment variables are case-insensitive. Node.js lexicographically sorts the env keys and uses the first one that case-insensitively matches. Only first (in lexicographic order) entry will be passed to the subprocess. This might lead to issues on Windows when passing objects to the env option that have multiple variants of the same key, such as PATH and Path. The child_process.spawn() method spawns the child process asynchronously, without blocking the Node.js event loop. The child_process.spawnSync() function provides equivalent functionality in a synchronous manner that blocks the event loop until the spawned process either exits or is terminated. For convenience, the child_process module provides a handful of synchronous and asynchronous alternatives to child_process.spawn() and child_process.spawnSync(). Each of these alternatives are implemented on top of child_process.spawn() or child_process.spawnSync().  child_process.exec(): spawns a shell and runs a command within that shell, passing the stdout and stderr to a callback function when complete. child_process.execFile(): similar to child_process.exec() except that it spawns the command directly without first spawning a shell by default. child_process.fork(): spawns a new Node.js process and invokes a specified module with an IPC communication channel established that allows sending messages between parent and child. child_process.execSync(): a synchronous version of child_process.exec() that will block the Node.js event loop. child_process.execFileSync(): a synchronous version of child_process.execFile() that will block the Node.js event loop.  For certain use cases, such as automating shell scripts, the synchronous counterparts may be more convenient. In many cases, however, the synchronous methods can have significant impact on performance due to stalling the event loop while spawned processes complete."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_asynchronous_process_creation","title":"Asynchronous process creation","description":"The child_process.spawn(), child_process.fork(), child_process.exec(), and child_process.execFile() methods all follow the idiomatic asynchronous programming pattern typical of other Node.js APIs. Each of the methods returns a ChildProcess instance. These objects implement the Node.js EventEmitter API, allowing the parent process to register listener functions that are called when certain events occur during the life cycle of the child process. The child_process.exec() and child_process.execFile() methods additionally allow for an optional callback function to be specified that is invoked when the child process terminates."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_exec_command_options_callback","title":"`child_process.exec(command[, options][, callback])`","description":"Spawns a shell then executes the command within that shell, buffering any generated output. The command string passed to the exec function is processed directly by the shell and special characters (vary based on shell) need to be dealt with accordingly: exec('\"\/path\/to\/test file\/test.sh\" arg1 arg2'); \/\/ Double quotes are used so that the space in the path is not interpreted as \/\/ a delimiter of multiple arguments.  exec('echo \"The \\\\$HOME variable is $HOME\"'); \/\/ The $HOME variable is escaped in the first instance, but not in the second.  Never pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution. If a callback function is provided, it is called with the arguments (error, stdout, stderr). On success, error will be null. On error, error will be an instance of Error. The error.code property will be the exit code of the process. By convention, any exit code other than 0 indicates an error. error.signal will be the signal that terminated the process. The stdout and stderr arguments passed to the callback will contain the stdout and stderr output of the child process. By default, Node.js will decode the output as UTF-8 and pass strings to the callback. The encoding option can be used to specify the character encoding used to decode the stdout and stderr output. If encoding is 'buffer', or an unrecognized character encoding, Buffer objects will be passed to the callback instead. const { exec } = require('child_process'); exec('cat *.js missing_file | wc -l', (error, stdout, stderr) => {   if (error) {     console.error(`exec error: ${error}`);     return;   }   console.log(`stdout: ${stdout}`);   console.error(`stderr: ${stderr}`); });  If timeout is greater than 0, the parent will send the signal identified by the killSignal property (the default is 'SIGTERM') if the child runs longer than timeout milliseconds. Unlike the exec(3) POSIX system call, child_process.exec() does not replace the existing process and uses a shell to execute the command. If this method is invoked as its util.promisify()ed version, it returns a Promise for an Object with stdout and stderr properties. The returned ChildProcess instance is attached to the Promise as a child property. In case of an error (including any error resulting in an exit code other than 0), a rejected promise is returned, with the same error object given in the callback, but with two additional properties stdout and stderr. const util = require('util'); const exec = util.promisify(require('child_process').exec);  async function lsExample() {   const { stdout, stderr } = await exec('ls');   console.log('stdout:', stdout);   console.error('stderr:', stderr); } lsExample();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_execfile_file_args_options_callback","title":"`child_process.execFile(file[, args][, options][, callback])`","description":"The child_process.execFile() function is similar to child_process.exec() except that it does not spawn a shell by default. Rather, the specified executable file is spawned directly as a new process making it slightly more efficient than child_process.exec(). The same options as child_process.exec() are supported. Since a shell is not spawned, behaviors such as I\/O redirection and file globbing are not supported. const { execFile } = require('child_process'); const child = execFile('node', ['--version'], (error, stdout, stderr) => {   if (error) {     throw error;   }   console.log(stdout); });  The stdout and stderr arguments passed to the callback will contain the stdout and stderr output of the child process. By default, Node.js will decode the output as UTF-8 and pass strings to the callback. The encoding option can be used to specify the character encoding used to decode the stdout and stderr output. If encoding is 'buffer', or an unrecognized character encoding, Buffer objects will be passed to the callback instead. If this method is invoked as its util.promisify()ed version, it returns a Promise for an Object with stdout and stderr properties. The returned ChildProcess instance is attached to the Promise as a child property. In case of an error (including any error resulting in an exit code other than 0), a rejected promise is returned, with the same error object given in the callback, but with two additional properties stdout and stderr. const util = require('util'); const execFile = util.promisify(require('child_process').execFile); async function getVersion() {   const { stdout } = await execFile('node', ['--version']);   console.log(stdout); } getVersion();  If the shell option is enabled, do not pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_fork_modulepath_args_options","title":"`child_process.fork(modulePath[, args][, options])`","description":"The child_process.fork() method is a special case of child_process.spawn() used specifically to spawn new Node.js processes. Like child_process.spawn(), a ChildProcess object is returned. The returned ChildProcess will have an additional communication channel built-in that allows messages to be passed back and forth between the parent and child. See subprocess.send() for details. Keep in mind that spawned Node.js child processes are independent of the parent with exception of the IPC communication channel that is established between the two. Each process has its own memory, with their own V8 instances. Because of the additional resource allocations required, spawning a large number of child Node.js processes is not recommended. By default, child_process.fork() will spawn new Node.js instances using the process.execPath of the parent process. The execPath property in the options object allows for an alternative execution path to be used. Node.js processes launched with a custom execPath will communicate with the parent process using the file descriptor (fd) identified using the environment variable NODE_CHANNEL_FD on the child process. Unlike the fork(2) POSIX system call, child_process.fork() does not clone the current process. The shell option available in child_process.spawn() is not supported by child_process.fork() and will be ignored if set."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_spawn_command_args_options","title":"`child_process.spawn(command[, args][, options])`","description":"The child_process.spawn() method spawns a new process using the given command, with command-line arguments in args. If omitted, args defaults to an empty array. If the shell option is enabled, do not pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution. A third argument may be used to specify additional options, with these defaults: const defaults = {   cwd: undefined,   env: process.env };  Use cwd to specify the working directory from which the process is spawned. If not given, the default is to inherit the current working directory. Use env to specify environment variables that will be visible to the new process, the default is process.env. undefined values in env will be ignored. Example of running ls -lh \/usr, capturing stdout, stderr, and the exit code: const { spawn } = require('child_process'); const ls = spawn('ls', ['-lh', '\/usr']);  ls.stdout.on('data', (data) => {   console.log(`stdout: ${data}`); });  ls.stderr.on('data', (data) => {   console.error(`stderr: ${data}`); });  ls.on('close', (code) => {   console.log(`child process exited with code ${code}`); });  Example: A very elaborate way to run ps ax | grep ssh const { spawn } = require('child_process'); const ps = spawn('ps', ['ax']); const grep = spawn('grep', ['ssh']);  ps.stdout.on('data', (data) => {   grep.stdin.write(data); });  ps.stderr.on('data', (data) => {   console.error(`ps stderr: ${data}`); });  ps.on('close', (code) => {   if (code !== 0) {     console.log(`ps process exited with code ${code}`);   }   grep.stdin.end(); });  grep.stdout.on('data', (data) => {   console.log(data.toString()); });  grep.stderr.on('data', (data) => {   console.error(`grep stderr: ${data}`); });  grep.on('close', (code) => {   if (code !== 0) {     console.log(`grep process exited with code ${code}`);   } });  Example of checking for failed spawn: const { spawn } = require('child_process'); const subprocess = spawn('bad_command');  subprocess.on('error', (err) => {   console.error('Failed to start subprocess.'); });  Certain platforms (macOS, Linux) will use the value of argv[0] for the process title while others (Windows, SunOS) will use command. Node.js currently overwrites argv[0] with process.execPath on startup, so process.argv[0] in a Node.js child process will not match the argv0 parameter passed to spawn from the parent, retrieve it with the process.argv0 property instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_spawning_bat_and_cmd_files_on_windows","title":"Spawning `.bat` and `.cmd` files on Windows","description":"The importance of the distinction between child_process.exec() and child_process.execFile() can vary based on platform. On Unix-type operating systems (Unix, Linux, macOS) child_process.execFile() can be more efficient because it does not spawn a shell by default. On Windows, however, .bat and .cmd files are not executable on their own without a terminal, and therefore cannot be launched using child_process.execFile(). When running on Windows, .bat and .cmd files can be invoked using child_process.spawn() with the shell option set, with child_process.exec(), or by spawning cmd.exe and passing the .bat or .cmd file as an argument (which is what the shell option and child_process.exec() do). In any case, if the script filename contains spaces it needs to be quoted. \/\/ On Windows Only... const { spawn } = require('child_process'); const bat = spawn('cmd.exe', ['\/c', 'my.bat']);  bat.stdout.on('data', (data) => {   console.log(data.toString()); });  bat.stderr.on('data', (data) => {   console.error(data.toString()); });  bat.on('exit', (code) => {   console.log(`Child exited with code ${code}`); });  \/\/ OR... const { exec, spawn } = require('child_process'); exec('my.bat', (err, stdout, stderr) => {   if (err) {     console.error(err);     return;   }   console.log(stdout); });  \/\/ Script with spaces in the filename: const bat = spawn('\"my script.cmd\"', ['a', 'b'], { shell: true }); \/\/ or: exec('\"my script.cmd\" a b', (err, stdout, stderr) => {   \/\/ ... });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_synchronous_process_creation","title":"Synchronous process creation","description":"The child_process.spawnSync(), child_process.execSync(), and child_process.execFileSync() methods are synchronous and will block the Node.js event loop, pausing execution of any additional code until the spawned process exits. Blocking calls like these are mostly useful for simplifying general-purpose scripting tasks and for simplifying the loading\/processing of application configuration at startup."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_execfilesync_file_args_options","title":"`child_process.execFileSync(file[, args][, options])`","description":"The child_process.execFileSync() method is generally identical to child_process.execFile() with the exception that the method will not return until the child process has fully closed. When a timeout has been encountered and killSignal is sent, the method won't return until the process has completely exited. If the child process intercepts and handles the SIGTERM signal and does not exit, the parent process will still wait until the child process has exited. If the process times out or has a non-zero exit code, this method will throw an Error that will include the full result of the underlying child_process.spawnSync(). If the shell option is enabled, do not pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_execsync_command_options","title":"`child_process.execSync(command[, options])`","description":"The child_process.execSync() method is generally identical to child_process.exec() with the exception that the method will not return until the child process has fully closed. When a timeout has been encountered and killSignal is sent, the method won't return until the process has completely exited. If the child process intercepts and handles the SIGTERM signal and doesn't exit, the parent process will wait until the child process has exited. If the process times out or has a non-zero exit code, this method will throw. The Error object will contain the entire result from child_process.spawnSync(). Never pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_child_process_spawnsync_command_args_options","title":"`child_process.spawnSync(command[, args][, options])`","description":"The child_process.spawnSync() method is generally identical to child_process.spawn() with the exception that the function will not return until the child process has fully closed. When a timeout has been encountered and killSignal is sent, the method won't return until the process has completely exited. If the process intercepts and handles the SIGTERM signal and doesn't exit, the parent process will wait until the child process has exited. If the shell option is enabled, do not pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_maxbuffer_and_unicode","title":"`maxBuffer` and Unicode","description":"The maxBuffer option specifies the largest number of bytes allowed on stdout or stderr. If this value is exceeded, then the child process is terminated. This impacts output that includes multibyte character encodings such as UTF-8 or UTF-16. For instance, console.log('\u4e2d\u6587\u6d4b\u8bd5') will send 13 UTF-8 encoded bytes to stdout although there are only 4 characters."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_shell_requirements","title":"Shell requirements","description":"The shell should understand the -c switch. If the shell is 'cmd.exe', it should understand the \/d \/s \/c switches and command-line parsing should be compatible."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_default_windows_shell","title":"Default Windows shell","description":"Although Microsoft specifies %COMSPEC% must contain the path to 'cmd.exe' in the root environment, child processes are not always subject to the same requirement. Thus, in child_process functions where a shell can be spawned, 'cmd.exe' is used as a fallback if process.env.ComSpec is unavailable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_advanced_serialization","title":"Advanced serialization","description":"Child processes support a serialization mechanism for IPC that is based on the serialization API of the v8 module, based on the HTML structured clone algorithm. This is generally more powerful and supports more built-in JavaScript object types, such as BigInt, Map and Set, ArrayBuffer and TypedArray, Buffer, Error, RegExp etc. However, this format is not a full superset of JSON, and e.g. properties set on objects of such built-in types will not be passed on through the serialization step. Additionally, performance may not be equivalent to that of JSON, depending on the structure of the passed data. Therefore, this feature requires opting in by setting the serialization option to 'advanced' when calling child_process.spawn() or child_process.fork()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster","title":"Cluster","description":"Source Code: lib\/cluster.js A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes to handle the load. The cluster module allows easy creation of child processes that all share server ports. const cluster = require('cluster'); const http = require('http'); const numCPUs = require('os').cpus().length;  if (cluster.isMaster) {   console.log(`Master ${process.pid} is running`);    \/\/ Fork workers.   for (let i = 0; i < numCPUs; i++) {     cluster.fork();   }    cluster.on('exit', (worker, code, signal) => {     console.log(`worker ${worker.process.pid} died`);   }); } else {   \/\/ Workers can share any TCP connection   \/\/ In this case it is an HTTP server   http.createServer((req, res) => {     res.writeHead(200);     res.end('hello world\\n');   }).listen(8000);    console.log(`Worker ${process.pid} started`); }  Running Node.js will now share port 8000 between the workers: $ node server.js Master 3596 is running Worker 4324 started Worker 4520 started Worker 6056 started Worker 5644 started  On Windows, it is not yet possible to set up a named pipe server in a worker."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster_disconnect_callback","title":"`cluster.disconnect([callback])`","description":"Calls .disconnect() on each worker in cluster.workers. When they are disconnected all internal handles will be closed, allowing the master process to die gracefully if no other event is waiting. The method takes an optional callback argument which will be called when finished. This can only be called from the master process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster_fork_env","title":"`cluster.fork([env])`","description":"Spawn a new worker process. This can only be called from the master process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cluster_setupmaster_settings","title":"`cluster.setupMaster([settings])`","description":"setupMaster is used to change the default 'fork' behavior. Once called, the settings will be present in cluster.settings. Any settings changes only affect future calls to .fork() and have no effect on workers that are already running. The only attribute of a worker that cannot be set via .setupMaster() is the env passed to .fork(). The defaults above apply to the first call only; the defaults for later calls are the current values at the time of cluster.setupMaster() is called. const cluster = require('cluster'); cluster.setupMaster({   exec: 'worker.js',   args: ['--use', 'https'],   silent: true }); cluster.fork(); \/\/ https worker cluster.setupMaster({   exec: 'worker.js',   args: ['--use', 'http'] }); cluster.fork(); \/\/ http worker  This can only be called from the master process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_how_it_works","title":"How it works","description":"The worker processes are spawned using the child_process.fork() method, so that they can communicate with the parent via IPC and pass server handles back and forth. The cluster module supports two methods of distributing incoming connections. The first one (and the default one on all platforms except Windows), is the round-robin approach, where the master process listens on a port, accepts new connections and distributes them across the workers in a round-robin fashion, with some built-in smarts to avoid overloading a worker process. The second approach is where the master process creates the listen socket and sends it to interested workers. The workers then accept incoming connections directly. The second approach should, in theory, give the best performance. In practice however, distribution tends to be very unbalanced due to operating system scheduler vagaries. Loads have been observed where over 70% of all connections ended up in just two processes, out of a total of eight. Because server.listen() hands off most of the work to the master process, there are three cases where the behavior between a normal Node.js process and a cluster worker differs:  server.listen({fd: 7}) Because the message is passed to the master, file descriptor 7 in the parent will be listened on, and the handle passed to the worker, rather than listening to the worker's idea of what the number 7 file descriptor references. server.listen(handle) Listening on handles explicitly will cause the worker to use the supplied handle, rather than talk to the master process. server.listen(0) Normally, this will cause servers to listen on a random port. However, in a cluster, each worker will receive the same \"random\" port each time they do listen(0). In essence, the port is random the first time, but predictable thereafter. To listen on a unique port, generate a port number based on the cluster worker ID.  Node.js does not provide routing logic. It is, therefore important to design an application such that it does not rely too heavily on in-memory data objects for things like sessions and login. Because workers are all separate processes, they can be killed or re-spawned depending on a program's needs, without affecting other workers. As long as there are some workers still alive, the server will continue to accept connections. If no workers are alive, existing connections will be dropped and new connections will be refused. Node.js does not automatically manage the number of workers, however. It is the application's responsibility to manage the worker pool based on its own needs. Although a primary use case for the cluster module is networking, it can also be used for other use cases requiring worker processes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console","title":"Console","description":"Source Code: lib\/console.js The console module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers. The module exports two specific components:  A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream. A global console instance configured to write to process.stdout and process.stderr. The global console can be used without calling require('console').  Warning: The global console object's methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the note on process I\/O for more information. Example using the global console: console.log('hello world'); \/\/ Prints: hello world, to stdout console.log('hello %s', 'world'); \/\/ Prints: hello world, to stdout console.error(new Error('Whoops, something bad happened')); \/\/ Prints error message and stack trace to stderr: \/\/   Error: Whoops, something bad happened \/\/     at [eval]:5:15 \/\/     at Script.runInThisContext (node:vm:132:18) \/\/     at Object.runInThisContext (node:vm:309:38) \/\/     at node:internal\/process\/execution:77:19 \/\/     at [eval]-wrapper:6:22 \/\/     at evalScript (node:internal\/process\/execution:76:60) \/\/     at node:internal\/main\/eval_string:23:3  const name = 'Will Robinson'; console.warn(`Danger ${name}! Danger!`); \/\/ Prints: Danger Will Robinson! Danger!, to stderr  Example using the Console class: const out = getStreamSomehow(); const err = getStreamSomehow(); const myConsole = new console.Console(out, err);  myConsole.log('hello world'); \/\/ Prints: hello world, to out myConsole.log('hello %s', 'world'); \/\/ Prints: hello world, to out myConsole.error(new Error('Whoops, something bad happened')); \/\/ Prints: [Error: Whoops, something bad happened], to err  const name = 'Will Robinson'; myConsole.warn(`Danger ${name}! Danger!`); \/\/ Prints: Danger Will Robinson! Danger!, to err"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspector_only_methods","title":"Inspector only methods","description":"The following methods are exposed by the V8 engine in the general API but do not display anything unless used in conjunction with the inspector (--inspect flag)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_profile_label","title":"`console.profile([label])`","description":"This method does not display anything unless used in the inspector. The console.profile() method starts a JavaScript CPU profile with an optional label until console.profileEnd() is called. The profile is then added to the Profile panel of the inspector. console.profile('MyLabel'); \/\/ Some code console.profileEnd('MyLabel'); \/\/ Adds the profile 'MyLabel' to the Profiles panel of the inspector."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_profileend_label","title":"`console.profileEnd([label])`","description":"This method does not display anything unless used in the inspector. Stops the current JavaScript CPU profiling session if one has been started and prints the report to the Profiles panel of the inspector. See console.profile() for an example. If this method is called without a label, the most recently started profile is stopped."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_console_timestamp_label","title":"`console.timeStamp([label])`","description":"This method does not display anything unless used in the inspector. The console.timeStamp() method adds an event with the label 'label' to the Timeline panel of the inspector."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto","title":"Crypto","description":"Source Code: lib\/crypto.js The crypto module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions. Use require('crypto') to access this module. const crypto = require('crypto');  const secret = 'abcdefg'; const hash = crypto.createHmac('sha256', secret)                    .update('I love cupcakes')                    .digest('hex'); console.log(hash); \/\/ Prints: \/\/   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_determining_if_crypto_support_is_unavailable","title":"Determining if crypto support is unavailable","description":"It is possible for Node.js to be built without including support for the crypto module. In such cases, calling require('crypto') will result in an error being thrown. let crypto; try {   crypto = require('crypto'); } catch (err) {   console.log('crypto support is disabled!'); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_module_methods_and_properties","title":"`crypto` module methods and properties","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createcipher_algorithm_password_options","title":"`crypto.createCipher(algorithm, password[, options])`","description":"Creates and returns a Cipher object that uses the given algorithm and password. The options argument controls stream behavior and is optional except when a cipher in CCM or OCB mode is used (e.g. 'aes-128-ccm'). In that case, the authTagLength option is required and specifies the length of the authentication tag in bytes, see CCM mode. In GCM mode, the authTagLength option is not required but can be used to set the length of the authentication tag that will be returned by getAuthTag() and defaults to 16 bytes. The algorithm is dependent on OpenSSL, examples are 'aes192', etc. On recent OpenSSL releases, openssl list -cipher-algorithms (openssl list-cipher-algorithms for older versions of OpenSSL) will display the available cipher algorithms. The password is used to derive the cipher key and initialization vector (IV). The value must be either a 'latin1' encoded string, a Buffer, a TypedArray, or a DataView. The implementation of crypto.createCipher() derives keys using the OpenSSL function EVP_BytesToKey with the digest algorithm set to MD5, one iteration, and no salt. The lack of salt allows dictionary attacks as the same password always creates the same key. The low iteration count and non-cryptographically secure hash algorithm allow passwords to be tested very rapidly. In line with OpenSSL's recommendation to use a more modern algorithm instead of EVP_BytesToKey it is recommended that developers derive a key and IV on their own using crypto.scrypt() and to use crypto.createCipheriv() to create the Cipher object. Users should not use ciphers with counter mode (e.g. CTR, GCM, or CCM) in crypto.createCipher(). A warning is emitted when they are used in order to avoid the risk of IV reuse that causes vulnerabilities. For the case when IV is reused in GCM, see Nonce-Disrespecting Adversaries for details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createcipheriv_algorithm_key_iv_options","title":"`crypto.createCipheriv(algorithm, key, iv[, options])`","description":"Creates and returns a Cipher object, with the given algorithm, key and initialization vector (iv). The options argument controls stream behavior and is optional except when a cipher in CCM or OCB mode is used (e.g. 'aes-128-ccm'). In that case, the authTagLength option is required and specifies the length of the authentication tag in bytes, see CCM mode. In GCM mode, the authTagLength option is not required but can be used to set the length of the authentication tag that will be returned by getAuthTag() and defaults to 16 bytes. The algorithm is dependent on OpenSSL, examples are 'aes192', etc. On recent OpenSSL releases, openssl list -cipher-algorithms (openssl list-cipher-algorithms for older versions of OpenSSL) will display the available cipher algorithms. The key is the raw key used by the algorithm and iv is an initialization vector. Both arguments must be 'utf8' encoded strings, Buffers, TypedArray, or DataViews. The key may optionally be a KeyObject of type secret. If the cipher does not need an initialization vector, iv may be null. Initialization vectors should be unpredictable and unique; ideally, they will be cryptographically random. They do not have to be secret: IVs are typically just added to ciphertext messages unencrypted. It may sound contradictory that something has to be unpredictable and unique, but does not have to be secret; remember that an attacker must not be able to predict ahead of time what a given IV will be."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createdecipher_algorithm_password_options","title":"`crypto.createDecipher(algorithm, password[, options])`","description":"Creates and returns a Decipher object that uses the given algorithm and password (key). The options argument controls stream behavior and is optional except when a cipher in CCM or OCB mode is used (e.g. 'aes-128-ccm'). In that case, the authTagLength option is required and specifies the length of the authentication tag in bytes, see CCM mode. The implementation of crypto.createDecipher() derives keys using the OpenSSL function EVP_BytesToKey with the digest algorithm set to MD5, one iteration, and no salt. The lack of salt allows dictionary attacks as the same password always creates the same key. The low iteration count and non-cryptographically secure hash algorithm allow passwords to be tested very rapidly. In line with OpenSSL's recommendation to use a more modern algorithm instead of EVP_BytesToKey it is recommended that developers derive a key and IV on their own using crypto.scrypt() and to use crypto.createDecipheriv() to create the Decipher object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createdecipheriv_algorithm_key_iv_options","title":"`crypto.createDecipheriv(algorithm, key, iv[, options])`","description":"Creates and returns a Decipher object that uses the given algorithm, key and initialization vector (iv). The options argument controls stream behavior and is optional except when a cipher in CCM or OCB mode is used (e.g. 'aes-128-ccm'). In that case, the authTagLength option is required and specifies the length of the authentication tag in bytes, see CCM mode. In GCM mode, the authTagLength option is not required but can be used to restrict accepted authentication tags to those with the specified length. The algorithm is dependent on OpenSSL, examples are 'aes192', etc. On recent OpenSSL releases, openssl list -cipher-algorithms (openssl list-cipher-algorithms for older versions of OpenSSL) will display the available cipher algorithms. The key is the raw key used by the algorithm and iv is an initialization vector. Both arguments must be 'utf8' encoded strings, Buffers, TypedArray, or DataViews. The key may optionally be a KeyObject of type secret. If the cipher does not need an initialization vector, iv may be null. Initialization vectors should be unpredictable and unique; ideally, they will be cryptographically random. They do not have to be secret: IVs are typically just added to ciphertext messages unencrypted. It may sound contradictory that something has to be unpredictable and unique, but does not have to be secret; remember that an attacker must not be able to predict ahead of time what a given IV will be."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding","title":"`crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])`","description":"Creates a DiffieHellman key exchange object using the supplied prime and an optional specific generator. The generator argument can be a number, string, or Buffer. If generator is not specified, the value 2 is used. If primeEncoding is specified, prime is expected to be a string; otherwise a Buffer, TypedArray, or DataView is expected. If generatorEncoding is specified, generator is expected to be a string; otherwise a number, Buffer, TypedArray, or DataView is expected."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_creatediffiehellman_primelength_generator","title":"`crypto.createDiffieHellman(primeLength[, generator])`","description":"Creates a DiffieHellman key exchange object and generates a prime of primeLength bits using an optional specific numeric generator. If generator is not specified, the value 2 is used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_creatediffiehellmangroup_name","title":"`crypto.createDiffieHellmanGroup(name)`","description":"An alias for crypto.getDiffieHellman()"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createecdh_curvename","title":"`crypto.createECDH(curveName)`","description":"Creates an Elliptic Curve Diffie-Hellman (ECDH) key exchange object using a predefined curve specified by the curveName string. Use crypto.getCurves() to obtain a list of available curve names. On recent OpenSSL releases, openssl ecparam -list_curves will also display the name and description of each available elliptic curve."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createhash_algorithm_options","title":"`crypto.createHash(algorithm[, options])`","description":"Creates and returns a Hash object that can be used to generate hash digests using the given algorithm. Optional options argument controls stream behavior. For XOF hash functions such as 'shake256', the outputLength option can be used to specify the desired output length in bytes. The algorithm is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc. On recent releases of OpenSSL, openssl list -digest-algorithms (openssl list-message-digest-algorithms for older versions of OpenSSL) will display the available digest algorithms. Example: generating the sha256 sum of a file const filename = process.argv[2]; const crypto = require('crypto'); const fs = require('fs');  const hash = crypto.createHash('sha256');  const input = fs.createReadStream(filename); input.on('readable', () => {   \/\/ Only one element is going to be produced by the   \/\/ hash stream.   const data = input.read();   if (data)     hash.update(data);   else {     console.log(`${hash.digest('hex')} ${filename}`);   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createhmac_algorithm_key_options","title":"`crypto.createHmac(algorithm, key[, options])`","description":"Creates and returns an Hmac object that uses the given algorithm and key. Optional options argument controls stream behavior. The algorithm is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc. On recent releases of OpenSSL, openssl list -digest-algorithms (openssl list-message-digest-algorithms for older versions of OpenSSL) will display the available digest algorithms. The key is the HMAC key used to generate the cryptographic HMAC hash. If it is a KeyObject, its type must be secret. Example: generating the sha256 HMAC of a file const filename = process.argv[2]; const crypto = require('crypto'); const fs = require('fs');  const hmac = crypto.createHmac('sha256', 'a secret');  const input = fs.createReadStream(filename); input.on('readable', () => {   \/\/ Only one element is going to be produced by the   \/\/ hash stream.   const data = input.read();   if (data)     hmac.update(data);   else {     console.log(`${hmac.digest('hex')} ${filename}`);   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createprivatekey_key","title":"`crypto.createPrivateKey(key)`","description":"key <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView>  key: <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> The key material, either in PEM or DER format. format: <string> Must be 'pem' or 'der'. Default: 'pem'. type: <string> Must be 'pkcs1', 'pkcs8' or 'sec1'. This option is required only if the format is 'der' and ignored if it is 'pem'. passphrase: <string> | <Buffer> The passphrase to use for decryption. encoding: <string> The string encoding to use when key is a string.   Returns: <KeyObject>    Creates and returns a new key object containing a private key. If key is a string or Buffer, format is assumed to be 'pem'; otherwise, key must be an object with the properties described above. If the private key is encrypted, a passphrase must be specified. The length of the passphrase is limited to 1024 bytes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createpublickey_key","title":"`crypto.createPublicKey(key)`","description":"key <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView>  key: <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> format: <string> Must be 'pem' or 'der'. Default: 'pem'. type: <string> Must be 'pkcs1' or 'spki'. This option is required only if the format is 'der'. encoding <string> The string encoding to use when key is a string.   Returns: <KeyObject>    Creates and returns a new key object containing a public key. If key is a string or Buffer, format is assumed to be 'pem'; if key is a KeyObject with type 'private', the public key is derived from the given private key; otherwise, key must be an object with the properties described above. If the format is 'pem', the 'key' may also be an X.509 certificate. Because public keys can be derived from private keys, a private key may be passed instead of a public key. In that case, this function behaves as if crypto.createPrivateKey() had been called, except that the type of the returned KeyObject will be 'public' and that the private key cannot be extracted from the returned KeyObject. Similarly, if a KeyObject with type 'private' is given, a new KeyObject with type 'public' will be returned and it will be impossible to extract the private key from the returned object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createsecretkey_key_encoding","title":"`crypto.createSecretKey(key[, encoding])`","description":"Creates and returns a new key object containing a secret key for symmetric encryption or Hmac."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createsign_algorithm_options","title":"`crypto.createSign(algorithm[, options])`","description":"Creates and returns a Sign object that uses the given algorithm. Use crypto.getHashes() to obtain the names of the available digest algorithms. Optional options argument controls the stream.Writable behavior. In some cases, a Sign instance can be created using the name of a signature algorithm, such as 'RSA-SHA256', instead of a digest algorithm. This will use the corresponding digest algorithm. This does not work for all signature algorithms, such as 'ecdsa-with-SHA256', so it is best to always use digest algorithm names."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_createverify_algorithm_options","title":"`crypto.createVerify(algorithm[, options])`","description":"Creates and returns a Verify object that uses the given algorithm. Use crypto.getHashes() to obtain an array of names of the available signing algorithms. Optional options argument controls the stream.Writable behavior. In some cases, a Verify instance can be created using the name of a signature algorithm, such as 'RSA-SHA256', instead of a digest algorithm. This will use the corresponding digest algorithm. This does not work for all signature algorithms, such as 'ecdsa-with-SHA256', so it is best to always use digest algorithm names."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_diffiehellman_options","title":"`crypto.diffieHellman(options)`","description":"Computes the Diffie-Hellman secret based on a privateKey and a publicKey. Both keys must have the same asymmetricKeyType, which must be one of 'dh' (for Diffie-Hellman), 'ec' (for ECDH), 'x448', or 'x25519' (for ECDH-ES)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_generatekey_type_options_callback","title":"`crypto.generateKey(type, options, callback)`","description":"Asynchronously generates a new random secret key of the given length. The type will determine which validations will be performed on the length. const { generateKey } = require('crypto');  generateKey('hmac', { length: 64 }, (err, key) => {   if (err) throw err;   console.log(key.export().toString('hex'));  \/\/ 46e..........620 });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_generatekeysync_type_options","title":"`crypto.generateKeySync(type, options)`","description":"Synchronously generates a new random secret key of the given length. The type will determine which validations will be performed on the length. const { generateKeySync } = require('crypto');  const key = generateKeySync('hmac', 64); console.log(key.export().toString('hex'));  \/\/ e89..........41e"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_generatekeypair_type_options_callback","title":"`crypto.generateKeyPair(type, options, callback)`","description":"Generates a new asymmetric key pair of the given type. RSA, DSA, EC, Ed25519, Ed448, X25519, X448, and DH are currently supported. If a publicKeyEncoding or privateKeyEncoding was specified, this function behaves as if keyObject.export() had been called on its result. Otherwise, the respective part of the key is returned as a KeyObject. It is recommended to encode public keys as 'spki' and private keys as 'pkcs8' with encryption for long-term storage: const { generateKeyPair } = require('crypto'); generateKeyPair('rsa', {   modulusLength: 4096,   publicKeyEncoding: {     type: 'spki',     format: 'pem'   },   privateKeyEncoding: {     type: 'pkcs8',     format: 'pem',     cipher: 'aes-256-cbc',     passphrase: 'top secret'   } }, (err, publicKey, privateKey) => {   \/\/ Handle errors and use the generated key pair. });  On completion, callback will be called with err set to undefined and publicKey \/ privateKey representing the generated key pair. If this method is invoked as its util.promisify()ed version, it returns a Promise for an Object with publicKey and privateKey properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_generatekeypairsync_type_options","title":"`crypto.generateKeyPairSync(type, options)`","description":"Generates a new asymmetric key pair of the given type. RSA, DSA, EC, Ed25519, Ed448, X25519, X448, and DH are currently supported. If a publicKeyEncoding or privateKeyEncoding was specified, this function behaves as if keyObject.export() had been called on its result. Otherwise, the respective part of the key is returned as a KeyObject. When encoding public keys, it is recommended to use 'spki'. When encoding private keys, it is recommended to use 'pkcs8' with a strong passphrase, and to keep the passphrase confidential. const { generateKeyPairSync } = require('crypto'); const { publicKey, privateKey } = generateKeyPairSync('rsa', {   modulusLength: 4096,   publicKeyEncoding: {     type: 'spki',     format: 'pem'   },   privateKeyEncoding: {     type: 'pkcs8',     format: 'pem',     cipher: 'aes-256-cbc',     passphrase: 'top secret'   } });  The return value { publicKey, privateKey } represents the generated key pair. When PEM encoding was selected, the respective key will be a string, otherwise it will be a buffer containing the data encoded as DER."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_getciphers","title":"`crypto.getCiphers()`","description":"const ciphers = crypto.getCiphers(); console.log(ciphers); \/\/ ['aes-128-cbc', 'aes-128-ccm', ...]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_getcipherinfo_nameornid_options","title":"`crypto.getCipherInfo(nameOrNid[, options])`","description":"Returns information about a given cipher. Some ciphers accept variable length keys and initialization vectors. By default, the crypto.getCipherInfo() method will return the default values for these ciphers. To test if a given key length or iv length is acceptable for given cipher, use the keyLenth and ivLenth options. If the given values are unacceptable, undefined will be returned."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_getcurves","title":"`crypto.getCurves()`","description":"const curves = crypto.getCurves(); console.log(curves); \/\/ ['Oakley-EC2N-3', 'Oakley-EC2N-4', ...]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_getdiffiehellman_groupname","title":"`crypto.getDiffieHellman(groupName)`","description":"Creates a predefined DiffieHellmanGroup key exchange object. The supported groups are: 'modp1', 'modp2', 'modp5' (defined in RFC 2412, but see Caveats) and 'modp14', 'modp15', 'modp16', 'modp17', 'modp18' (defined in RFC 3526). The returned object mimics the interface of objects created by crypto.createDiffieHellman(), but will not allow changing the keys (with diffieHellman.setPublicKey(), for example). The advantage of using this method is that the parties do not have to generate nor exchange a group modulus beforehand, saving both processor and communication time. Example (obtaining a shared secret): const crypto = require('crypto'); const alice = crypto.getDiffieHellman('modp14'); const bob = crypto.getDiffieHellman('modp14');  alice.generateKeys(); bob.generateKeys();  const aliceSecret = alice.computeSecret(bob.getPublicKey(), null, 'hex'); const bobSecret = bob.computeSecret(alice.getPublicKey(), null, 'hex');  \/* aliceSecret and bobSecret should be the same *\/ console.log(aliceSecret === bobSecret);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_getfips","title":"`crypto.getFips()`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_gethashes","title":"`crypto.getHashes()`","description":"const hashes = crypto.getHashes(); console.log(hashes); \/\/ ['DSA', 'DSA-SHA', 'DSA-SHA1', ...]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_hkdf_digest_key_salt_info_keylen_callback","title":"`crypto.hkdf(digest, key, salt, info, keylen, callback)`","description":"HKDF is a simple key derivation function defined in RFC 5869. The given key, salt and info are used with the digest to derive a key of keylen bytes. The supplied callback function is called with two arguments: err and derivedKey. If an errors occurs while deriving the key, err will be set; otherwise err will be null. The successfully generated derivedKey will be passed to the callback as an <ArrayBuffer>. An error will be thrown if any of the input aguments specify invalid values or types. const crypto = require('crypto'); crypto.hkdf('sha512', 'key', 'salt', 'info', 64, (err, derivedKey) => {   if (err) throw err;   console.log(Buffer.from(derivedKey).toString('hex'));  \/\/ '24156e2...5391653' });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_hkdfsync_digest_key_salt_info_keylen","title":"`crypto.hkdfSync(digest, key, salt, info, keylen)`","description":"Provides a synchronous HKDF key derivation function as defined in RFC 5869. The given key, salt and info are used with the digest to derive a key of keylen bytes. The successfully generated derivedKey will be returned as an <ArrayBuffer>. An error will be thrown if any of the input aguments specify invalid values or types, or if the derived key cannot be generated. const crypto = require('crypto'); const derivedKey = crypto.hkdfSync('sha512', 'key', 'salt', 'info', 64); console.log(Buffer.from(derivedKey).toString('hex'));  \/\/ '24156e2...5391653'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback","title":"`crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)`","description":"Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2) implementation. A selected HMAC digest algorithm specified by digest is applied to derive a key of the requested byte length (keylen) from the password, salt and iterations. The supplied callback function is called with two arguments: err and derivedKey. If an error occurs while deriving the key, err will be set; otherwise err will be null. By default, the successfully generated derivedKey will be passed to the callback as a Buffer. An error will be thrown if any of the input arguments specify invalid values or types. If digest is null, 'sha1' will be used. This behavior is deprecated, please specify a digest explicitly. The iterations argument must be a number set as high as possible. The higher the number of iterations, the more secure the derived key will be, but will take a longer amount of time to complete. The salt should be as unique as possible. It is recommended that a salt is random and at least 16 bytes long. See NIST SP 800-132 for details. const crypto = require('crypto'); crypto.pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, derivedKey) => {   if (err) throw err;   console.log(derivedKey.toString('hex'));  \/\/ '3745e48...08d59ae' });  The crypto.DEFAULT_ENCODING property can be used to change the way the derivedKey is passed to the callback. This property, however, has been deprecated and use should be avoided. const crypto = require('crypto'); crypto.DEFAULT_ENCODING = 'hex'; crypto.pbkdf2('secret', 'salt', 100000, 512, 'sha512', (err, derivedKey) => {   if (err) throw err;   console.log(derivedKey);  \/\/ '3745e48...aa39b34' });  An array of supported digest functions can be retrieved using crypto.getHashes(). This API uses libuv's threadpool, which can have surprising and negative performance implications for some applications; see the UV_THREADPOOL_SIZE documentation for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_pbkdf2sync_password_salt_iterations_keylen_digest","title":"`crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)`","description":"Provides a synchronous Password-Based Key Derivation Function 2 (PBKDF2) implementation. A selected HMAC digest algorithm specified by digest is applied to derive a key of the requested byte length (keylen) from the password, salt and iterations. If an error occurs an Error will be thrown, otherwise the derived key will be returned as a Buffer. If digest is null, 'sha1' will be used. This behavior is deprecated, please specify a digest explicitly. The iterations argument must be a number set as high as possible. The higher the number of iterations, the more secure the derived key will be, but will take a longer amount of time to complete. The salt should be as unique as possible. It is recommended that a salt is random and at least 16 bytes long. See NIST SP 800-132 for details. const crypto = require('crypto'); const key = crypto.pbkdf2Sync('secret', 'salt', 100000, 64, 'sha512'); console.log(key.toString('hex'));  \/\/ '3745e48...08d59ae'  The crypto.DEFAULT_ENCODING property may be used to change the way the derivedKey is returned. This property, however, is deprecated and use should be avoided. const crypto = require('crypto'); crypto.DEFAULT_ENCODING = 'hex'; const key = crypto.pbkdf2Sync('secret', 'salt', 100000, 512, 'sha512'); console.log(key);  \/\/ '3745e48...aa39b34'  An array of supported digest functions can be retrieved using crypto.getHashes()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_privatedecrypt_privatekey_buffer","title":"`crypto.privateDecrypt(privateKey, buffer)`","description":"privateKey <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey>  oaepHash <string> The hash function to use for OAEP padding and MGF1. Default: 'sha1' oaepLabel <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> The label to  use for OAEP padding. If not specified, no label is used. padding <crypto.constants> An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING, crypto.constants.RSA_PKCS1_PADDING, or crypto.constants.RSA_PKCS1_OAEP_PADDING.   buffer <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> Returns: <Buffer> A new Buffer with the decrypted content.    Decrypts buffer with privateKey. buffer was previously encrypted using the corresponding public key, for example using crypto.publicEncrypt(). If privateKey is not a KeyObject, this function behaves as if privateKey had been passed to crypto.createPrivateKey(). If it is an object, the padding property can be passed. Otherwise, this function uses RSA_PKCS1_OAEP_PADDING."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_privateencrypt_privatekey_buffer","title":"`crypto.privateEncrypt(privateKey, buffer)`","description":"privateKey <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey>  key <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey> A PEM encoded private key. passphrase <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> An optional passphrase for the private key. padding <crypto.constants> An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING or crypto.constants.RSA_PKCS1_PADDING. encoding <string> The string encoding to use when buffer, key, or 'passphrase` are strings.   buffer <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> Returns: <Buffer> A new Buffer with the encrypted content.    Encrypts buffer with privateKey. The returned data can be decrypted using the corresponding public key, for example using crypto.publicDecrypt(). If privateKey is not a KeyObject, this function behaves as if privateKey had been passed to crypto.createPrivateKey(). If it is an object, the padding property can be passed. Otherwise, this function uses RSA_PKCS1_PADDING."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_publicdecrypt_key_buffer","title":"`crypto.publicDecrypt(key, buffer)`","description":"key <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey>  passphrase <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> An optional passphrase for the private key. padding <crypto.constants> An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING or crypto.constants.RSA_PKCS1_PADDING. encoding <string> The string encoding to use when buffer, key, or 'passphrase` are strings.   buffer <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> Returns: <Buffer> A new Buffer with the decrypted content.    Decrypts buffer with key.buffer was previously encrypted using the corresponding private key, for example using crypto.privateEncrypt(). If key is not a KeyObject, this function behaves as if key had been passed to crypto.createPublicKey(). If it is an object, the padding property can be passed. Otherwise, this function uses RSA_PKCS1_PADDING. Because RSA public keys can be derived from private keys, a private key may be passed instead of a public key."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_publicencrypt_key_buffer","title":"`crypto.publicEncrypt(key, buffer)`","description":"key <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey>  key <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey> A PEM encoded public or private key, <KeyObject>, or <CryptoKey>. oaepHash <string> The hash function to use for OAEP padding and MGF1. Default: 'sha1' oaepLabel <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> The label to use for OAEP padding. If not specified, no label is used. passphrase <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> An optional passphrase for the private key. padding <crypto.constants> An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING, crypto.constants.RSA_PKCS1_PADDING, or crypto.constants.RSA_PKCS1_OAEP_PADDING. encoding <string> The string encoding to use when buffer, key, oaepLabel, or 'passphrase` are strings.   buffer <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> Returns: <Buffer> A new Buffer with the encrypted content.    Encrypts the content of buffer with key and returns a new Buffer with encrypted content. The returned data can be decrypted using the corresponding private key, for example using crypto.privateDecrypt(). If key is not a KeyObject, this function behaves as if key had been passed to crypto.createPublicKey(). If it is an object, the padding property can be passed. Otherwise, this function uses RSA_PKCS1_OAEP_PADDING. Because RSA public keys can be derived from private keys, a private key may be passed instead of a public key."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_randombytes_size_callback","title":"`crypto.randomBytes(size[, callback])`","description":"Generates cryptographically strong pseudo-random data. The size argument is a number indicating the number of bytes to generate. If a callback function is provided, the bytes are generated asynchronously and the callback function is invoked with two arguments: err and buf. If an error occurs, err will be an Error object; otherwise it is null. The buf argument is a Buffer containing the generated bytes. \/\/ Asynchronous const crypto = require('crypto'); crypto.randomBytes(256, (err, buf) => {   if (err) throw err;   console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`); });  If the callback function is not provided, the random bytes are generated synchronously and returned as a Buffer. An error will be thrown if there is a problem generating the bytes. \/\/ Synchronous const buf = crypto.randomBytes(256); console.log(   `${buf.length} bytes of random data: ${buf.toString('hex')}`);  The crypto.randomBytes() method will not complete until there is sufficient entropy available. This should normally never take longer than a few milliseconds. The only time when generating the random bytes may conceivably block for a longer period of time is right after boot, when the whole system is still low on entropy. This API uses libuv's threadpool, which can have surprising and negative performance implications for some applications; see the UV_THREADPOOL_SIZE documentation for more information. The asynchronous version of crypto.randomBytes() is carried out in a single threadpool request. To minimize threadpool task length variation, partition large randomBytes requests when doing so as part of fulfilling a client request."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_randomfillsync_buffer_offset_size","title":"`crypto.randomFillSync(buffer[, offset][, size])`","description":"Synchronous version of crypto.randomFill(). const buf = Buffer.alloc(10); console.log(crypto.randomFillSync(buf).toString('hex'));  crypto.randomFillSync(buf, 5); console.log(buf.toString('hex'));  \/\/ The above is equivalent to the following: crypto.randomFillSync(buf, 5, 5); console.log(buf.toString('hex'));  Any ArrayBuffer, TypedArray or DataView instance may be passed as buffer. const a = new Uint32Array(10); console.log(Buffer.from(crypto.randomFillSync(a).buffer,                         a.byteOffset, a.byteLength).toString('hex'));  const b = new Float64Array(10); console.log(Buffer.from(crypto.randomFillSync(b).buffer,                         b.byteOffset, b.byteLength).toString('hex'));  const c = new DataView(new ArrayBuffer(10)); console.log(Buffer.from(crypto.randomFillSync(c).buffer,                         c.byteOffset, c.byteLength).toString('hex'));  const d = new ArrayBuffer(10); console.log(Buffer.from(crypto.randomFillSync(d)).toString('hex'));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_randomfill_buffer_offset_size_callback","title":"`crypto.randomFill(buffer[, offset][, size], callback)`","description":"This function is similar to crypto.randomBytes() but requires the first argument to be a Buffer that will be filled. It also requires that a callback is passed in. If the callback function is not provided, an error will be thrown. const buf = Buffer.alloc(10); crypto.randomFill(buf, (err, buf) => {   if (err) throw err;   console.log(buf.toString('hex')); });  crypto.randomFill(buf, 5, (err, buf) => {   if (err) throw err;   console.log(buf.toString('hex')); });  \/\/ The above is equivalent to the following: crypto.randomFill(buf, 5, 5, (err, buf) => {   if (err) throw err;   console.log(buf.toString('hex')); });  Any ArrayBuffer TypedArray or DataView instance may be passed as buffer. const a = new Uint32Array(10); crypto.randomFill(a, (err, buf) => {   if (err) throw err;   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)     .toString('hex')); });  const b = new Float64Array(10); crypto.randomFill(b, (err, buf) => {   if (err) throw err;   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)     .toString('hex')); });  const c = new DataView(new ArrayBuffer(10)); crypto.randomFill(c, (err, buf) => {   if (err) throw err;   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)     .toString('hex')); });  const d = new ArrayBuffer(10); crypto.randomFill(d, (err, buf) => {   if (err) throw err;   console.log(Buffer.from(buf).toString('hex')); });  This API uses libuv's threadpool, which can have surprising and negative performance implications for some applications; see the UV_THREADPOOL_SIZE documentation for more information. The asynchronous version of crypto.randomFill() is carried out in a single threadpool request. To minimize threadpool task length variation, partition large randomFill requests when doing so as part of fulfilling a client request."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_randomint_min_max_callback","title":"`crypto.randomInt([min, ]max[, callback])`","description":"Return a random integer n such that min <= n < max.  This implementation avoids modulo bias. The range (max - min) must be less than 248. min and max must be safe integers. If the callback function is not provided, the random integer is generated synchronously. \/\/ Asynchronous crypto.randomInt(3, (err, n) => {   if (err) throw err;   console.log(`Random number chosen from (0, 1, 2): ${n}`); });  \/\/ Synchronous const n = crypto.randomInt(3); console.log(`Random number chosen from (0, 1, 2): ${n}`);  \/\/ With `min` argument const n = crypto.randomInt(1, 7); console.log(`The dice rolled: ${n}`);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_scrypt_password_salt_keylen_options_callback","title":"`crypto.scrypt(password, salt, keylen[, options], callback)`","description":"Provides an asynchronous scrypt implementation. Scrypt is a password-based key derivation function that is designed to be expensive computationally and memory-wise in order to make brute-force attacks unrewarding. The salt should be as unique as possible. It is recommended that a salt is random and at least 16 bytes long. See NIST SP 800-132 for details. The callback function is called with two arguments: err and derivedKey. err is an exception object when key derivation fails, otherwise err is null. derivedKey is passed to the callback as a Buffer. An exception is thrown when any of the input arguments specify invalid values or types. const crypto = require('crypto'); \/\/ Using the factory defaults. crypto.scrypt('password', 'salt', 64, (err, derivedKey) => {   if (err) throw err;   console.log(derivedKey.toString('hex'));  \/\/ '3745e48...08d59ae' }); \/\/ Using a custom N parameter. Must be a power of two. crypto.scrypt('password', 'salt', 64, { N: 1024 }, (err, derivedKey) => {   if (err) throw err;   console.log(derivedKey.toString('hex'));  \/\/ '3745e48...aa39b34' });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_scryptsync_password_salt_keylen_options","title":"`crypto.scryptSync(password, salt, keylen[, options])`","description":"Provides a synchronous scrypt implementation. Scrypt is a password-based key derivation function that is designed to be expensive computationally and memory-wise in order to make brute-force attacks unrewarding. The salt should be as unique as possible. It is recommended that a salt is random and at least 16 bytes long. See NIST SP 800-132 for details. An exception is thrown when key derivation fails, otherwise the derived key is returned as a Buffer. An exception is thrown when any of the input arguments specify invalid values or types. const crypto = require('crypto'); \/\/ Using the factory defaults. const key1 = crypto.scryptSync('password', 'salt', 64); console.log(key1.toString('hex'));  \/\/ '3745e48...08d59ae' \/\/ Using a custom N parameter. Must be a power of two. const key2 = crypto.scryptSync('password', 'salt', 64, { N: 1024 }); console.log(key2.toString('hex'));  \/\/ '3745e48...aa39b34'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_setengine_engine_flags","title":"`crypto.setEngine(engine[, flags])`","description":"Load and set the engine for some or all OpenSSL functions (selected by flags). engine could be either an id or a path to the engine's shared library. The optional flags argument uses ENGINE_METHOD_ALL by default. The flags is a bit field taking one of or a mix of the following flags (defined in crypto.constants):  crypto.constants.ENGINE_METHOD_RSA crypto.constants.ENGINE_METHOD_DSA crypto.constants.ENGINE_METHOD_DH crypto.constants.ENGINE_METHOD_RAND crypto.constants.ENGINE_METHOD_EC crypto.constants.ENGINE_METHOD_CIPHERS crypto.constants.ENGINE_METHOD_DIGESTS crypto.constants.ENGINE_METHOD_PKEY_METHS crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS crypto.constants.ENGINE_METHOD_ALL crypto.constants.ENGINE_METHOD_NONE  The flags below are deprecated in OpenSSL-1.1.0.  crypto.constants.ENGINE_METHOD_ECDH crypto.constants.ENGINE_METHOD_ECDSA crypto.constants.ENGINE_METHOD_STORE"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_setfips_bool","title":"`crypto.setFips(bool)`","description":"Enables the FIPS compliant crypto provider in a FIPS-enabled Node.js build. Throws an error if FIPS mode is not available."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_sign_algorithm_data_key","title":"`crypto.sign(algorithm, data, key)`","description":"algorithm <string> | <null> | <undefined> data <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> key <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey> Returns: <Buffer>    Calculates and returns the signature for data using the given private key and algorithm. If algorithm is null or undefined, then the algorithm is dependent upon the key type (especially Ed25519 and Ed448). If key is not a KeyObject, this function behaves as if key had been passed to crypto.createPrivateKey(). If it is an object, the following additional properties can be passed:   dsaEncoding <string> For DSA and ECDSA, this option specifies the format of the generated signature. It can be one of the following:  'der' (default): DER-encoded ASN.1 signature structure encoding (r, s). 'ieee-p1363': Signature format r || s as proposed in IEEE-P1363.    padding <integer> Optional padding value for RSA, one of the following:  crypto.constants.RSA_PKCS1_PADDING (default) crypto.constants.RSA_PKCS1_PSS_PADDING  RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function used to sign the message as specified in section 3.1 of RFC 4055.   saltLength <integer> Salt length for when padding is RSA_PKCS1_PSS_PADDING. The special value crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest size, crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN (default) sets it to the maximum permissible value."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_timingsafeequal_a_b","title":"`crypto.timingSafeEqual(a, b)`","description":"This function is based on a constant-time algorithm. Returns true if a is equal to b, without leaking timing information that would allow an attacker to guess one of the values. This is suitable for comparing HMAC digests or secret values like authentication cookies or capability urls. a and b must both be Buffers, TypedArrays, or DataViews, and they must have the same length. Use of crypto.timingSafeEqual does not guarantee that the surrounding code is timing-safe. Care should be taken to ensure that the surrounding code does not introduce timing vulnerabilities."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_verify_algorithm_data_key_signature","title":"`crypto.verify(algorithm, data, key, signature)`","description":"algorithm <string> | <null> | <undefined> data <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> key <Object> | <string> | <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> | <KeyObject> | <CryptoKey> signature <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> Returns: <boolean>    Verifies the given signature for data using the given key and algorithm. If algorithm is null or undefined, then the algorithm is dependent upon the key type (especially Ed25519 and Ed448). If key is not a KeyObject, this function behaves as if key had been passed to crypto.createPublicKey(). If it is an object, the following additional properties can be passed:   dsaEncoding <string> For DSA and ECDSA, this option specifies the format of the generated signature. It can be one of the following:  'der' (default): DER-encoded ASN.1 signature structure encoding (r, s). 'ieee-p1363': Signature format r || s as proposed in IEEE-P1363.    padding <integer> Optional padding value for RSA, one of the following:  crypto.constants.RSA_PKCS1_PADDING (default) crypto.constants.RSA_PKCS1_PSS_PADDING  RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function used to sign the message as specified in section 3.1 of RFC 4055.   saltLength <integer> Salt length for when padding is RSA_PKCS1_PSS_PADDING. The special value crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest size, crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN (default) sets it to the maximum permissible value.   The signature argument is the previously calculated signature for the data. Because public keys can be derived from private keys, a private key or a public key may be passed for key."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_notes","title":"Notes","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_legacy_streams_api_prior_to_node_js_0_10","title":"Legacy streams API (prior to Node.js 0.10)","description":"The Crypto module was added to Node.js before there was the concept of a unified Stream API, and before there were Buffer objects for handling binary data. As such, the many of the crypto defined classes have methods not typically found on other Node.js classes that implement the streams API (e.g. update(), final(), or digest()). Also, many methods accepted and returned 'latin1' encoded strings by default rather than Buffers. This default was changed after Node.js v0.8 to use Buffer objects by default instead."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_recent_ecdh_changes","title":"Recent ECDH changes","description":"Usage of ECDH with non-dynamically generated key pairs has been simplified. Now, ecdh.setPrivateKey() can be called with a preselected private key and the associated public point (key) will be computed and stored in the object. This allows code to only store and provide the private part of the EC key pair. ecdh.setPrivateKey() now also validates that the private key is valid for the selected curve. The ecdh.setPublicKey() method is now deprecated as its inclusion in the API is not useful. Either a previously stored private key should be set, which automatically generates the associated public key, or ecdh.generateKeys() should be called. The main drawback of using ecdh.setPublicKey() is that it can be used to put the ECDH key pair into an inconsistent state."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_support_for_weak_or_compromised_algorithms","title":"Support for weak or compromised algorithms","description":"The crypto module still supports some algorithms which are already compromised and are not currently recommended for use. The API also allows the use of ciphers and hashes with a small key size that are too weak for safe use. Users should take full responsibility for selecting the crypto algorithm and key size according to their security requirements. Based on the recommendations of NIST SP 800-131A:  MD5 and SHA-1 are no longer acceptable where collision resistance is required such as digital signatures. The key used with RSA, DSA, and DH algorithms is recommended to have at least 2048 bits and that of the curve of ECDSA and ECDH at least 224 bits, to be safe to use for several years. The DH groups of modp1, modp2 and modp5 have a key size smaller than 2048 bits and are not recommended.  See the reference for other recommendations and details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_ccm_mode","title":"CCM mode","description":"CCM is one of the supported AEAD algorithms. Applications which use this mode must adhere to certain restrictions when using the cipher API:  The authentication tag length must be specified during cipher creation by setting the authTagLength option and must be one of 4, 6, 8, 10, 12, 14 or 16 bytes. The length of the initialization vector (nonce) N must be between 7 and 13 bytes (7 \u2264 N \u2264 13). The length of the plaintext is limited to 2 ** (8 * (15 - N)) bytes. When decrypting, the authentication tag must be set via setAuthTag() before calling update(). Otherwise, decryption will fail and final() will throw an error in compliance with section 2.6 of RFC 3610. Using stream methods such as write(data), end(data) or pipe() in CCM mode might fail as CCM cannot handle more than one chunk of data per instance. When passing additional authenticated data (AAD), the length of the actual message in bytes must be passed to setAAD() via the plaintextLength option. Many crypto libraries include the authentication tag in the ciphertext, which means that they produce ciphertexts of the length plaintextLength + authTagLength. Node.js does not include the authentication tag, so the ciphertext length is always plaintextLength. This is not necessary if no AAD is used. As CCM processes the whole message at once, update() can only be called once. Even though calling update() is sufficient to encrypt\/decrypt the message, applications must call final() to compute or verify the authentication tag.  const crypto = require('crypto');  const key = 'keykeykeykeykeykeykeykey'; const nonce = crypto.randomBytes(12);  const aad = Buffer.from('0123456789', 'hex');  const cipher = crypto.createCipheriv('aes-192-ccm', key, nonce, {   authTagLength: 16 }); const plaintext = 'Hello world'; cipher.setAAD(aad, {   plaintextLength: Buffer.byteLength(plaintext) }); const ciphertext = cipher.update(plaintext, 'utf8'); cipher.final(); const tag = cipher.getAuthTag();  \/\/ Now transmit { ciphertext, nonce, tag }.  const decipher = crypto.createDecipheriv('aes-192-ccm', key, nonce, {   authTagLength: 16 }); decipher.setAuthTag(tag); decipher.setAAD(aad, {   plaintextLength: ciphertext.length }); const receivedPlaintext = decipher.update(ciphertext, null, 'utf8');  try {   decipher.final(); } catch (err) {   console.error('Authentication failed!');   return; }  console.log(receivedPlaintext);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_crypto_constants","title":"Crypto constants","description":"The following constants exported by crypto.constants apply to various uses of the crypto, tls, and https modules and are generally specific to OpenSSL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_openssl_options","title":"OpenSSL options","description":"Constant     Description           SSL_OP_ALL     Applies multiple bug workarounds within OpenSSL. See     https:\/\/www.openssl.org\/docs\/man1.0.2\/ssl\/SSL_CTX_set_options.html     for detail.           SSL_OP_ALLOW_NO_DHE_KEX     Instructs OpenSSL to allow a non-[EC]DHE-based key exchange mode     for TLS v1.3           SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION     Allows legacy insecure renegotiation between OpenSSL and unpatched     clients or servers. See     https:\/\/www.openssl.org\/docs\/man1.0.2\/ssl\/SSL_CTX_set_options.html.           SSL_OP_CIPHER_SERVER_PREFERENCE     Attempts to use the server's preferences instead of the client's when     selecting a cipher. Behavior depends on protocol version. See     https:\/\/www.openssl.org\/docs\/man1.0.2\/ssl\/SSL_CTX_set_options.html.           SSL_OP_CISCO_ANYCONNECT     Instructs OpenSSL to use Cisco's \"speshul\" version of DTLS_BAD_VER.           SSL_OP_COOKIE_EXCHANGE     Instructs OpenSSL to turn on cookie exchange.           SSL_OP_CRYPTOPRO_TLSEXT_BUG     Instructs OpenSSL to add server-hello extension from an early version     of the cryptopro draft.           SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS     Instructs OpenSSL to disable a SSL 3.0\/TLS 1.0 vulnerability     workaround added in OpenSSL 0.9.6d.           SSL_OP_EPHEMERAL_RSA     Instructs OpenSSL to always use the tmp_rsa key when performing RSA     operations.           SSL_OP_LEGACY_SERVER_CONNECT     Allows initial connection to servers that do not support RI.           SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER                SSL_OP_MICROSOFT_SESS_ID_BUG                SSL_OP_MSIE_SSLV2_RSA_PADDING     Instructs OpenSSL to disable the workaround for a man-in-the-middle     protocol-version vulnerability in the SSL 2.0 server implementation.           SSL_OP_NETSCAPE_CA_DN_BUG                SSL_OP_NETSCAPE_CHALLENGE_BUG                SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG                SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG                SSL_OP_NO_COMPRESSION     Instructs OpenSSL to disable support for SSL\/TLS compression.           SSL_OP_NO_ENCRYPT_THEN_MAC     Instructs OpenSSL to disable encrypt-then-MAC.           SSL_OP_NO_QUERY_MTU                SSL_OP_NO_RENEGOTIATION     Instructs OpenSSL to disable renegotiation.           SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION     Instructs OpenSSL to always start a new session when performing     renegotiation.           SSL_OP_NO_SSLv2     Instructs OpenSSL to turn off SSL v2           SSL_OP_NO_SSLv3     Instructs OpenSSL to turn off SSL v3           SSL_OP_NO_TICKET     Instructs OpenSSL to disable use of RFC4507bis tickets.           SSL_OP_NO_TLSv1     Instructs OpenSSL to turn off TLS v1           SSL_OP_NO_TLSv1_1     Instructs OpenSSL to turn off TLS v1.1           SSL_OP_NO_TLSv1_2     Instructs OpenSSL to turn off TLS v1.2           SSL_OP_NO_TLSv1_3     Instructs OpenSSL to turn off TLS v1.3        SSL_OP_PKCS1_CHECK_1                SSL_OP_PKCS1_CHECK_2                SSL_OP_PRIORITIZE_CHACHA     Instructs OpenSSL server to prioritize ChaCha20Poly1305     when client does.     This option has no effect if     SSL_OP_CIPHER_SERVER_PREFERENCE     is not enabled.           SSL_OP_SINGLE_DH_USE     Instructs OpenSSL to always create a new key when using     temporary\/ephemeral DH parameters.           SSL_OP_SINGLE_ECDH_USE     Instructs OpenSSL to always create a new key when using     temporary\/ephemeral ECDH parameters.        SSL_OP_SSLEAY_080_CLIENT_DH_BUG                SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG                SSL_OP_TLS_BLOCK_PADDING_BUG                SSL_OP_TLS_D5_BUG                SSL_OP_TLS_ROLLBACK_BUG     Instructs OpenSSL to disable version rollback attack detection."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_openssl_engine_constants","title":"OpenSSL engine constants","description":"Constant     Description           ENGINE_METHOD_RSA     Limit engine usage to RSA           ENGINE_METHOD_DSA     Limit engine usage to DSA           ENGINE_METHOD_DH     Limit engine usage to DH           ENGINE_METHOD_RAND     Limit engine usage to RAND           ENGINE_METHOD_EC     Limit engine usage to EC           ENGINE_METHOD_CIPHERS     Limit engine usage to CIPHERS           ENGINE_METHOD_DIGESTS     Limit engine usage to DIGESTS           ENGINE_METHOD_PKEY_METHS     Limit engine usage to PKEY_METHDS           ENGINE_METHOD_PKEY_ASN1_METHS     Limit engine usage to PKEY_ASN1_METHS           ENGINE_METHOD_ALL                ENGINE_METHOD_NONE"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_other_openssl_constants","title":"Other OpenSSL constants","description":"See the list of SSL OP Flags for details.         Constant     Description           DH_CHECK_P_NOT_SAFE_PRIME                DH_CHECK_P_NOT_PRIME                DH_UNABLE_TO_CHECK_GENERATOR                DH_NOT_SUITABLE_GENERATOR                ALPN_ENABLED                RSA_PKCS1_PADDING                RSA_SSLV23_PADDING                RSA_NO_PADDING                RSA_PKCS1_OAEP_PADDING                RSA_X931_PADDING                RSA_PKCS1_PSS_PADDING                RSA_PSS_SALTLEN_DIGEST     Sets the salt length for RSA_PKCS1_PSS_PADDING to the         digest size when signing or verifying.           RSA_PSS_SALTLEN_MAX_SIGN     Sets the salt length for RSA_PKCS1_PSS_PADDING to the         maximum permissible value when signing data.           RSA_PSS_SALTLEN_AUTO     Causes the salt length for RSA_PKCS1_PSS_PADDING to be         determined automatically when verifying a signature.           POINT_CONVERSION_COMPRESSED                POINT_CONVERSION_UNCOMPRESSED                POINT_CONVERSION_HYBRID"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_js_crypto_constants","title":"Node.js crypto constants","description":"Constant     Description           defaultCoreCipherList     Specifies the built-in default cipher list used by Node.js.           defaultCipherList     Specifies the active default cipher list used by the current Node.js     process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_diagnostics_channel","title":"Diagnostics Channel","description":"Source Code: lib\/diagnostics_channel.js The diagnostics_channel module provides an API to create named channels to report arbitrary message data for diagnostics purposes. It can be accessed using: const diagnostics_channel = require('diagnostics_channel');  It is intended that a module writer wanting to report diagnostics messages will create one or many top-level channels to report messages through. Channels may also be acquired at runtime but it is not encouraged due to the additional overhead of doing so. Channels may be exported for convenience, but as long as the name is known it can be acquired anywhere. If you intend for your module to produce diagnostics data for others to consume it is recommended that you include documentation of what named channels are used along with the shape of the message data. Channel names should generally include the module name to avoid collisions with data from other modules."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_public_api","title":"Public API","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_overview","title":"Overview","description":"Following is a simple overview of the public API. const diagnostics_channel = require('diagnostics_channel');  \/\/ Get a reusable channel object const channel = diagnostics_channel.channel('my-channel');  \/\/ Subscribe to the channel channel.subscribe((message, name) => {   \/\/ Received data });  \/\/ Check if the channel has an active subscriber if (channel.hasSubscribers) {   \/\/ Publish data to the channel   channel.publish({     some: 'data'   }); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_diagnostics_channel_hassubscribers_name","title":"`diagnostics_channel.hasSubscribers(name)`","description":"Check if there are active subscribers to the named channel. This is helpful if the message you want to send might be expensive to prepare. This API is optional but helpful when trying to publish messages from very performance-senstive code. const diagnostics_channel = require('diagnostics_channel');  if (diagnostics_channel.hasSubscribers('my-channel')) {   \/\/ There are subscribers, prepare and publish message }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_diagnostics_channel_channel_name","title":"`diagnostics_channel.channel(name)`","description":"This is the primary entry-point for anyone wanting to interact with a named channel. It produces a channel object which is optimized to reduce overhead at publish time as much as possible. const diagnostics_channel = require('diagnostics_channel');  const channel = diagnostics_channel.channel('my-channel');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns","title":"DNS","description":"Source Code: lib\/dns.js The dns module enables name resolution. For example, use it to look up IP addresses of host names. Although named for the Domain Name System (DNS), it does not always use the DNS protocol for lookups. dns.lookup() uses the operating system facilities to perform name resolution. It may not need to perform any network communication. To perform name resolution the way other applications on the same system do, use dns.lookup(). const dns = require('dns');  dns.lookup('example.org', (err, address, family) => {   console.log('address: %j family: IPv%s', address, family); }); \/\/ address: \"93.184.216.34\" family: IPv4  All other functions in the dns module connect to an actual DNS server to perform name resolution. They will always use the network to perform DNS queries. These functions do not use the same set of configuration files used by dns.lookup() (e.g. \/etc\/hosts). Use these functions to always perform DNS queries, bypassing other name-resolution facilities. const dns = require('dns');  dns.resolve4('archive.org', (err, addresses) => {   if (err) throw err;    console.log(`addresses: ${JSON.stringify(addresses)}`);    addresses.forEach((a) => {     dns.reverse(a, (err, hostnames) => {       if (err) {         throw err;       }       console.log(`reverse for ${a}: ${JSON.stringify(hostnames)}`);     });   }); });  See the Implementation considerations section for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_getservers","title":"`dns.getServers()`","description":"Returns an array of IP address strings, formatted according to RFC 5952, that are currently configured for DNS resolution. A string will include a port section if a custom port is used.  [   '4.4.4.4',   '2001:4860:4860::8888',   '4.4.4.4:1053',   '[2001:4860:4860::8888]:1053' ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_lookup_hostname_options_callback","title":"`dns.lookup(hostname[, options], callback)`","description":"Resolves a host name (e.g. 'nodejs.org') into the first found A (IPv4) or AAAA (IPv6) record. All option properties are optional. If options is an integer, then it must be 4 or 6 \u2013 if options is not provided, then IPv4 and IPv6 addresses are both returned if found. With the all option set to true, the arguments for callback change to (err, addresses), with addresses being an array of objects with the properties address and family. On error, err is an Error object, where err.code is the error code. Keep in mind that err.code will be set to 'ENOTFOUND' not only when the host name does not exist but also when the lookup fails in other ways such as no available file descriptors. dns.lookup() does not necessarily have anything to do with the DNS protocol. The implementation uses an operating system facility that can associate names with addresses, and vice versa. This implementation can have subtle but important consequences on the behavior of any Node.js program. Please take some time to consult the Implementation considerations section before using dns.lookup(). Example usage: const dns = require('dns'); const options = {   family: 6,   hints: dns.ADDRCONFIG | dns.V4MAPPED, }; dns.lookup('example.com', options, (err, address, family) =>   console.log('address: %j family: IPv%s', address, family)); \/\/ address: \"2606:2800:220:1:248:1893:25c8:1946\" family: IPv6  \/\/ When options.all is true, the result will be an Array. options.all = true; dns.lookup('example.com', options, (err, addresses) =>   console.log('addresses: %j', addresses)); \/\/ addresses: [{\"address\":\"2606:2800:220:1:248:1893:25c8:1946\",\"family\":6}]  If this method is invoked as its util.promisify()ed version, and all is not set to true, it returns a Promise for an Object with address and family properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_supported_getaddrinfo_flags","title":"Supported getaddrinfo flags","description":"The following flags can be passed as hints to dns.lookup().  dns.ADDRCONFIG: Limits returned address types to the types of non-loopback addresses configured on the system. For example, IPv4 addresses are only returned if the current system has at least one IPv4 address configured. dns.V4MAPPED: If the IPv6 family was specified, but no IPv6 addresses were found, then return IPv4 mapped IPv6 addresses. It is not supported on some operating systems (e.g FreeBSD 10.1). dns.ALL: If dns.V4MAPPED is specified, return resolved IPv6 addresses as well as IPv4 mapped IPv6 addresses."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_lookupservice_address_port_callback","title":"`dns.lookupService(address, port, callback)`","description":"Resolves the given address and port into a host name and service using the operating system's underlying getnameinfo implementation. If address is not a valid IP address, a TypeError will be thrown. The port will be coerced to a number. If it is not a legal port, a TypeError will be thrown. On an error, err is an Error object, where err.code is the error code. const dns = require('dns'); dns.lookupService('127.0.0.1', 22, (err, hostname, service) => {   console.log(hostname, service);   \/\/ Prints: localhost ssh });  If this method is invoked as its util.promisify()ed version, it returns a Promise for an Object with hostname and service properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolve_hostname_rrtype_callback","title":"`dns.resolve(hostname[, rrtype], callback)`","description":"Uses the DNS protocol to resolve a host name (e.g. 'nodejs.org') into an array of the resource records. The callback function has arguments (err, records). When successful, records will be an array of resource records. The type and structure of individual results varies based on rrtype:    rrtype records contains Result type Shorthand method     'A' IPv4 addresses (default) <string> dns.resolve4()   'AAAA' IPv6 addresses <string> dns.resolve6()   'ANY' any records <Object> dns.resolveAny()   'CAA' CA authorization records <Object> dns.resolveCaa()   'CNAME' canonical name records <string> dns.resolveCname()   'MX' mail exchange records <Object> dns.resolveMx()   'NAPTR' name authority pointer records <Object> dns.resolveNaptr()   'NS' name server records <string> dns.resolveNs()   'PTR' pointer records <string> dns.resolvePtr()   'SOA' start of authority records <Object> dns.resolveSoa()   'SRV' service records <Object> dns.resolveSrv()   'TXT' text records <string[]> dns.resolveTxt()    On error, err is an Error object, where err.code is one of the DNS error codes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolve4_hostname_options_callback","title":"`dns.resolve4(hostname[, options], callback)`","description":"Uses the DNS protocol to resolve a IPv4 addresses (A records) for the hostname. The addresses argument passed to the callback function will contain an array of IPv4 addresses (e.g. ['74.125.79.104', '74.125.79.105', '74.125.79.106'])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolve6_hostname_options_callback","title":"`dns.resolve6(hostname[, options], callback)`","description":"Uses the DNS protocol to resolve a IPv6 addresses (AAAA records) for the hostname. The addresses argument passed to the callback function will contain an array of IPv6 addresses."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolveany_hostname_callback","title":"`dns.resolveAny(hostname, callback)`","description":"Uses the DNS protocol to resolve all records (also known as ANY or * query). The ret argument passed to the callback function will be an array containing various types of records. Each object has a property type that indicates the type of the current record. And depending on the type, additional properties will be present on the object:    Type Properties     'A' address\/ttl   'AAAA' address\/ttl   'CNAME' value   'MX' Refer to dns.resolveMx()   'NAPTR' Refer to dns.resolveNaptr()   'NS' value   'PTR' value   'SOA' Refer to dns.resolveSoa()   'SRV' Refer to dns.resolveSrv()   'TXT' This type of record contains an array property called entries which refers to dns.resolveTxt(), e.g. { entries: ['...'], type: 'TXT' }    Here is an example of the ret object passed to the callback:  [ { type: 'A', address: '127.0.0.1', ttl: 299 },   { type: 'CNAME', value: 'example.com' },   { type: 'MX', exchange: 'alt4.aspmx.l.example.com', priority: 50 },   { type: 'NS', value: 'ns1.example.com' },   { type: 'TXT', entries: [ 'v=spf1 include:_spf.example.com ~all' ] },   { type: 'SOA',     nsname: 'ns1.example.com',     hostmaster: 'admin.example.com',     serial: 156696742,     refresh: 900,     retry: 900,     expire: 1800,     minttl: 60 } ]  DNS server operators may choose not to respond to ANY queries. It may be better to call individual methods like dns.resolve4(), dns.resolveMx(), and so on. For more details, see RFC 8482."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvecname_hostname_callback","title":"`dns.resolveCname(hostname, callback)`","description":"Uses the DNS protocol to resolve CNAME records for the hostname. The addresses argument passed to the callback function will contain an array of canonical name records available for the hostname (e.g. ['bar.example.com'])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvecaa_hostname_callback","title":"`dns.resolveCaa(hostname, callback)`","description":"Uses the DNS protocol to resolve CAA records for the hostname. The addresses argument passed to the callback function will contain an array of certification authority authorization records available for the hostname (e.g. [{critial: 0, iodef: 'mailto:pki@example.com'}, {critical: 128, issue: 'pki.example.com'}])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvemx_hostname_callback","title":"`dns.resolveMx(hostname, callback)`","description":"Uses the DNS protocol to resolve mail exchange records (MX records) for the hostname. The addresses argument passed to the callback function will contain an array of objects containing both a priority and exchange property (e.g. [{priority: 10, exchange: 'mx.example.com'}, ...])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvenaptr_hostname_callback","title":"`dns.resolveNaptr(hostname, callback)`","description":"Uses the DNS protocol to resolve regular expression based records (NAPTR records) for the hostname. The addresses argument passed to the callback function will contain an array of objects with the following properties:  flags service regexp replacement order preference   {   flags: 's',   service: 'SIP+D2U',   regexp: '',   replacement: '_sip._udp.example.com',   order: 30,   preference: 100 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvens_hostname_callback","title":"`dns.resolveNs(hostname, callback)`","description":"Uses the DNS protocol to resolve name server records (NS records) for the hostname. The addresses argument passed to the callback function will contain an array of name server records available for hostname (e.g. ['ns1.example.com', 'ns2.example.com'])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolveptr_hostname_callback","title":"`dns.resolvePtr(hostname, callback)`","description":"Uses the DNS protocol to resolve pointer records (PTR records) for the hostname. The addresses argument passed to the callback function will be an array of strings containing the reply records."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvesoa_hostname_callback","title":"`dns.resolveSoa(hostname, callback)`","description":"Uses the DNS protocol to resolve a start of authority record (SOA record) for the hostname. The address argument passed to the callback function will be an object with the following properties:  nsname hostmaster serial refresh retry expire minttl   {   nsname: 'ns.example.com',   hostmaster: 'root.example.com',   serial: 2013101809,   refresh: 10000,   retry: 2400,   expire: 604800,   minttl: 3600 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvesrv_hostname_callback","title":"`dns.resolveSrv(hostname, callback)`","description":"Uses the DNS protocol to resolve service records (SRV records) for the hostname. The addresses argument passed to the callback function will be an array of objects with the following properties:  priority weight port name   {   priority: 10,   weight: 5,   port: 21223,   name: 'service.example.com' }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolvetxt_hostname_callback","title":"`dns.resolveTxt(hostname, callback)`","description":"hostname <string> callback <Function>  err <Error> records <string[][]>      Uses the DNS protocol to resolve text queries (TXT records) for the hostname. The records argument passed to the callback function is a two-dimensional array of the text records available for hostname (e.g. [ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]). Each sub-array contains TXT chunks of one record. Depending on the use case, these could be either joined together or treated separately."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_reverse_ip_callback","title":"`dns.reverse(ip, callback)`","description":"Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an array of host names. On error, err is an Error object, where err.code is one of the DNS error codes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_setservers_servers","title":"`dns.setServers(servers)`","description":"Sets the IP address and port of servers to be used when performing DNS resolution. The servers argument is an array of RFC 5952 formatted addresses. If the port is the IANA default DNS port (53) it can be omitted. dns.setServers([   '4.4.4.4',   '[2001:4860:4860::8888]',   '4.4.4.4:1053',   '[2001:4860:4860::8888]:1053' ]);  An error will be thrown if an invalid address is provided. The dns.setServers() method must not be called while a DNS query is in progress. The dns.setServers() method affects only dns.resolve(), dns.resolve*() and dns.reverse() (and specifically not dns.lookup()). This method works much like resolve.conf. That is, if attempting to resolve with the first server provided results in a NOTFOUND error, the resolve() method will not attempt to resolve with subsequent servers provided. Fallback DNS servers will only be used if the earlier ones time out or result in some other error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_promises_api","title":"DNS promises API","description":"The dns.promises API provides an alternative set of asynchronous DNS methods that return Promise objects rather than using callbacks. The API is accessible via require('dns').promises or require('dns\/promises')."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_getservers","title":"`dnsPromises.getServers()`","description":"Returns an array of IP address strings, formatted according to RFC 5952, that are currently configured for DNS resolution. A string will include a port section if a custom port is used.  [   '4.4.4.4',   '2001:4860:4860::8888',   '4.4.4.4:1053',   '[2001:4860:4860::8888]:1053' ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_lookup_hostname_options","title":"`dnsPromises.lookup(hostname[, options])`","description":"Resolves a host name (e.g. 'nodejs.org') into the first found A (IPv4) or AAAA (IPv6) record. All option properties are optional. If options is an integer, then it must be 4 or 6 \u2013 if options is not provided, then IPv4 and IPv6 addresses are both returned if found. With the all option set to true, the Promise is resolved with addresses being an array of objects with the properties address and family. On error, the Promise is rejected with an Error object, where err.code is the error code. Keep in mind that err.code will be set to 'ENOTFOUND' not only when the host name does not exist but also when the lookup fails in other ways such as no available file descriptors. dnsPromises.lookup() does not necessarily have anything to do with the DNS protocol. The implementation uses an operating system facility that can associate names with addresses, and vice versa. This implementation can have subtle but important consequences on the behavior of any Node.js program. Please take some time to consult the Implementation considerations section before using dnsPromises.lookup(). Example usage: const dns = require('dns'); const dnsPromises = dns.promises; const options = {   family: 6,   hints: dns.ADDRCONFIG | dns.V4MAPPED, };  dnsPromises.lookup('example.com', options).then((result) => {   console.log('address: %j family: IPv%s', result.address, result.family);   \/\/ address: \"2606:2800:220:1:248:1893:25c8:1946\" family: IPv6 });  \/\/ When options.all is true, the result will be an Array. options.all = true; dnsPromises.lookup('example.com', options).then((result) => {   console.log('addresses: %j', result);   \/\/ addresses: [{\"address\":\"2606:2800:220:1:248:1893:25c8:1946\",\"family\":6}] });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_lookupservice_address_port","title":"`dnsPromises.lookupService(address, port)`","description":"Resolves the given address and port into a host name and service using the operating system's underlying getnameinfo implementation. If address is not a valid IP address, a TypeError will be thrown. The port will be coerced to a number. If it is not a legal port, a TypeError will be thrown. On error, the Promise is rejected with an Error object, where err.code is the error code. const dnsPromises = require('dns').promises; dnsPromises.lookupService('127.0.0.1', 22).then((result) => {   console.log(result.hostname, result.service);   \/\/ Prints: localhost ssh });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolve_hostname_rrtype","title":"`dnsPromises.resolve(hostname[, rrtype])`","description":"Uses the DNS protocol to resolve a host name (e.g. 'nodejs.org') into an array of the resource records. When successful, the Promise is resolved with an array of resource records. The type and structure of individual results vary based on rrtype:    rrtype records contains Result type Shorthand method     'A' IPv4 addresses (default) <string> dnsPromises.resolve4()   'AAAA' IPv6 addresses <string> dnsPromises.resolve6()   'ANY' any records <Object> dnsPromises.resolveAny()   'CAA' CA authorization records <Object> dnsPromises.resolveCaa()   'CNAME' canonical name records <string> dnsPromises.resolveCname()   'MX' mail exchange records <Object> dnsPromises.resolveMx()   'NAPTR' name authority pointer records <Object> dnsPromises.resolveNaptr()   'NS' name server records <string> dnsPromises.resolveNs()   'PTR' pointer records <string> dnsPromises.resolvePtr()   'SOA' start of authority records <Object> dnsPromises.resolveSoa()   'SRV' service records <Object> dnsPromises.resolveSrv()   'TXT' text records <string[]> dnsPromises.resolveTxt()    On error, the Promise is rejected with an Error object, where err.code is one of the DNS error codes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolve4_hostname_options","title":"`dnsPromises.resolve4(hostname[, options])`","description":"Uses the DNS protocol to resolve IPv4 addresses (A records) for the hostname. On success, the Promise is resolved with an array of IPv4 addresses (e.g. ['74.125.79.104', '74.125.79.105', '74.125.79.106'])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolve6_hostname_options","title":"`dnsPromises.resolve6(hostname[, options])`","description":"Uses the DNS protocol to resolve IPv6 addresses (AAAA records) for the hostname. On success, the Promise is resolved with an array of IPv6 addresses."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolveany_hostname","title":"`dnsPromises.resolveAny(hostname)`","description":"Uses the DNS protocol to resolve all records (also known as ANY or * query). On success, the Promise is resolved with an array containing various types of records. Each object has a property type that indicates the type of the current record. And depending on the type, additional properties will be present on the object:    Type Properties     'A' address\/ttl   'AAAA' address\/ttl   'CNAME' value   'MX' Refer to dnsPromises.resolveMx()   'NAPTR' Refer to dnsPromises.resolveNaptr()   'NS' value   'PTR' value   'SOA' Refer to dnsPromises.resolveSoa()   'SRV' Refer to dnsPromises.resolveSrv()   'TXT' This type of record contains an array property called entries which refers to dnsPromises.resolveTxt(), e.g. { entries: ['...'], type: 'TXT' }    Here is an example of the result object:  [ { type: 'A', address: '127.0.0.1', ttl: 299 },   { type: 'CNAME', value: 'example.com' },   { type: 'MX', exchange: 'alt4.aspmx.l.example.com', priority: 50 },   { type: 'NS', value: 'ns1.example.com' },   { type: 'TXT', entries: [ 'v=spf1 include:_spf.example.com ~all' ] },   { type: 'SOA',     nsname: 'ns1.example.com',     hostmaster: 'admin.example.com',     serial: 156696742,     refresh: 900,     retry: 900,     expire: 1800,     minttl: 60 } ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvecaa_hostname","title":"`dnsPromises.resolveCaa(hostname)`","description":"Uses the DNS protocol to resolve CAA records for the hostname. On success, the Promise is resolved with an array of objects containing available certification authority authorization records available for the hostname (e.g. [{critial: 0, iodef: 'mailto:pki@example.com'},{critical: 128, issue: 'pki.example.com'}])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvecname_hostname","title":"`dnsPromises.resolveCname(hostname)`","description":"Uses the DNS protocol to resolve CNAME records for the hostname. On success, the Promise is resolved with an array of canonical name records available for the hostname (e.g. ['bar.example.com'])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvemx_hostname","title":"`dnsPromises.resolveMx(hostname)`","description":"Uses the DNS protocol to resolve mail exchange records (MX records) for the hostname. On success, the Promise is resolved with an array of objects containing both a priority and exchange property (e.g. [{priority: 10, exchange: 'mx.example.com'}, ...])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvenaptr_hostname","title":"`dnsPromises.resolveNaptr(hostname)`","description":"Uses the DNS protocol to resolve regular expression based records (NAPTR records) for the hostname. On success, the Promise is resolved with an array of objects with the following properties:  flags service regexp replacement order preference   {   flags: 's',   service: 'SIP+D2U',   regexp: '',   replacement: '_sip._udp.example.com',   order: 30,   preference: 100 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvens_hostname","title":"`dnsPromises.resolveNs(hostname)`","description":"Uses the DNS protocol to resolve name server records (NS records) for the hostname. On success, the Promise is resolved with an array of name server records available for hostname (e.g. ['ns1.example.com', 'ns2.example.com'])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolveptr_hostname","title":"`dnsPromises.resolvePtr(hostname)`","description":"Uses the DNS protocol to resolve pointer records (PTR records) for the hostname. On success, the Promise is resolved with an array of strings containing the reply records."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvesoa_hostname","title":"`dnsPromises.resolveSoa(hostname)`","description":"Uses the DNS protocol to resolve a start of authority record (SOA record) for the hostname. On success, the Promise is resolved with an object with the following properties:  nsname hostmaster serial refresh retry expire minttl   {   nsname: 'ns.example.com',   hostmaster: 'root.example.com',   serial: 2013101809,   refresh: 10000,   retry: 2400,   expire: 604800,   minttl: 3600 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvesrv_hostname","title":"`dnsPromises.resolveSrv(hostname)`","description":"Uses the DNS protocol to resolve service records (SRV records) for the hostname. On success, the Promise is resolved with an array of objects with the following properties:  priority weight port name   {   priority: 10,   weight: 5,   port: 21223,   name: 'service.example.com' }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_resolvetxt_hostname","title":"`dnsPromises.resolveTxt(hostname)`","description":"Uses the DNS protocol to resolve text queries (TXT records) for the hostname. On success, the Promise is resolved with a two-dimensional array of the text records available for hostname (e.g. [ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]). Each sub-array contains TXT chunks of one record. Depending on the use case, these could be either joined together or treated separately."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_reverse_ip","title":"`dnsPromises.reverse(ip)`","description":"Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an array of host names. On error, the Promise is rejected with an Error object, where err.code is one of the DNS error codes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dnspromises_setservers_servers","title":"`dnsPromises.setServers(servers)`","description":"Sets the IP address and port of servers to be used when performing DNS resolution. The servers argument is an array of RFC 5952 formatted addresses. If the port is the IANA default DNS port (53) it can be omitted. dnsPromises.setServers([   '4.4.4.4',   '[2001:4860:4860::8888]',   '4.4.4.4:1053',   '[2001:4860:4860::8888]:1053' ]);  An error will be thrown if an invalid address is provided. The dnsPromises.setServers() method must not be called while a DNS query is in progress. This method works much like resolve.conf. That is, if attempting to resolve with the first server provided results in a NOTFOUND error, the resolve() method will not attempt to resolve with subsequent servers provided. Fallback DNS servers will only be used if the earlier ones time out or result in some other error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_codes","title":"Error codes","description":"Each DNS query can return one of the following error codes:  dns.NODATA: DNS server returned answer with no data. dns.FORMERR: DNS server claims query was misformatted. dns.SERVFAIL: DNS server returned general failure. dns.NOTFOUND: Domain name not found. dns.NOTIMP: DNS server does not implement requested operation. dns.REFUSED: DNS server refused query. dns.BADQUERY: Misformatted DNS query. dns.BADNAME: Misformatted host name. dns.BADFAMILY: Unsupported address family. dns.BADRESP: Misformatted DNS reply. dns.CONNREFUSED: Could not contact DNS servers. dns.TIMEOUT: Timeout while contacting DNS servers. dns.EOF: End of file. dns.FILE: Error reading file. dns.NOMEM: Out of memory. dns.DESTRUCTION: Channel is being destroyed. dns.BADSTR: Misformatted string. dns.BADFLAGS: Illegal flags specified. dns.NONAME: Given host name is not numeric. dns.BADHINTS: Illegal hints flags specified. dns.NOTINITIALIZED: c-ares library initialization not yet performed. dns.LOADIPHLPAPI: Error loading iphlpapi.dll. dns.ADDRGETNETWORKPARAMS: Could not find GetNetworkParams function. dns.CANCELLED: DNS query cancelled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implementation_considerations","title":"Implementation considerations","description":"Although dns.lookup() and the various dns.resolve*()\/dns.reverse() functions have the same goal of associating a network name with a network address (or vice versa), their behavior is quite different. These differences can have subtle but significant consequences on the behavior of Node.js programs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_lookup","title":"`dns.lookup()`","description":"Under the hood, dns.lookup() uses the same operating system facilities as most other programs. For instance, dns.lookup() will almost always resolve a given name the same way as the ping command. On most POSIX-like operating systems, the behavior of the dns.lookup() function can be modified by changing settings in nsswitch.conf(5) and\/or resolv.conf(5), but changing these files will change the behavior of all other programs running on the same operating system. Though the call to dns.lookup() will be asynchronous from JavaScript's perspective, it is implemented as a synchronous call to getaddrinfo(3) that runs on libuv's threadpool. This can have surprising negative performance implications for some applications, see the UV_THREADPOOL_SIZE documentation for more information. Various networking APIs will call dns.lookup() internally to resolve host names. If that is an issue, consider resolving the host name to an address using dns.resolve() and using the address instead of a host name. Also, some networking APIs (such as socket.connect() and dgram.createSocket()) allow the default resolver, dns.lookup(), to be replaced."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dns_resolve_dns_resolve_and_dns_reverse","title":"`dns.resolve()`, `dns.resolve*()` and `dns.reverse()`","description":"These functions are implemented quite differently than dns.lookup(). They do not use getaddrinfo(3) and they always perform a DNS query on the network. This network communication is always done asynchronously, and does not use libuv's threadpool. As a result, these functions cannot have the same negative impact on other processing that happens on libuv's threadpool that dns.lookup() can have. They do not use the same set of configuration files than what dns.lookup() uses. For instance, they do not use the configuration from \/etc\/hosts."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_domain","title":"Domain","description":"Source Code: lib\/domain.js This module is pending deprecation. Once a replacement API has been finalized, this module will be fully deprecated. Most developers should not have cause to use this module. Users who absolutely must have the functionality that domains provide may rely on it for the time being but should expect to have to migrate to a different solution in the future. Domains provide a way to handle multiple different IO operations as a single group. If any of the event emitters or callbacks registered to a domain emit an 'error' event, or throw an error, then the domain object will be notified, rather than losing the context of the error in the process.on('uncaughtException') handler, or causing the program to exit immediately with an error code."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_domain_create","title":"`domain.create()`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_warning_don_t_ignore_errors","title":"Warning: Don't ignore errors!","description":"Domain error handlers are not a substitute for closing down a process when an error occurs. By the very nature of how throw works in JavaScript, there is almost never any way to safely \"pick up where it left off\", without leaking references, or creating some other sort of undefined brittle state. The safest way to respond to a thrown error is to shut down the process. Of course, in a normal web server, there may be many open connections, and it is not reasonable to abruptly shut those down because an error was triggered by someone else. The better approach is to send an error response to the request that triggered the error, while letting the others finish in their normal time, and stop listening for new requests in that worker. In this way, domain usage goes hand-in-hand with the cluster module, since the master process can fork a new worker when a worker encounters an error. For Node.js programs that scale to multiple machines, the terminating proxy or service registry can take note of the failure, and react accordingly. For example, this is not a good idea: \/\/ XXX WARNING! BAD IDEA!  const d = require('domain').create(); d.on('error', (er) => {   \/\/ The error won't crash the process, but what it does is worse!   \/\/ Though we've prevented abrupt process restarting, we are leaking   \/\/ resources like crazy if this ever happens.   \/\/ This is no better than process.on('uncaughtException')!   console.log(`error, but oh well ${er.message}`); }); d.run(() => {   require('http').createServer((req, res) => {     handleRequest(req, res);   }).listen(PORT); });  By using the context of a domain, and the resilience of separating our program into multiple worker processes, we can react more appropriately, and handle errors with much greater safety. \/\/ Much better!  const cluster = require('cluster'); const PORT = +process.env.PORT || 1337;  if (cluster.isMaster) {   \/\/ A more realistic scenario would have more than 2 workers,   \/\/ and perhaps not put the master and worker in the same file.   \/\/   \/\/ It is also possible to get a bit fancier about logging, and   \/\/ implement whatever custom logic is needed to prevent DoS   \/\/ attacks and other bad behavior.   \/\/   \/\/ See the options in the cluster documentation.   \/\/   \/\/ The important thing is that the master does very little,   \/\/ increasing our resilience to unexpected errors.    cluster.fork();   cluster.fork();    cluster.on('disconnect', (worker) => {     console.error('disconnect!');     cluster.fork();   });  } else {   \/\/ the worker   \/\/   \/\/ This is where we put our bugs!    const domain = require('domain');    \/\/ See the cluster documentation for more details about using   \/\/ worker processes to serve requests. How it works, caveats, etc.    const server = require('http').createServer((req, res) => {     const d = domain.create();     d.on('error', (er) => {       console.error(`error ${er.stack}`);        \/\/ We're in dangerous territory!       \/\/ By definition, something unexpected occurred,       \/\/ which we probably didn't want.       \/\/ Anything can happen now! Be very careful!        try {         \/\/ Make sure we close down within 30 seconds         const killtimer = setTimeout(() => {           process.exit(1);         }, 30000);         \/\/ But don't keep the process open just for that!         killtimer.unref();          \/\/ Stop taking new requests.         server.close();          \/\/ Let the master know we're dead. This will trigger a         \/\/ 'disconnect' in the cluster master, and then it will fork         \/\/ a new worker.         cluster.worker.disconnect();          \/\/ Try to send an error to the request that triggered the problem         res.statusCode = 500;         res.setHeader('content-type', 'text\/plain');         res.end('Oops, there was a problem!\\n');       } catch (er2) {         \/\/ Oh well, not much we can do at this point.         console.error(`Error sending 500! ${er2.stack}`);       }     });      \/\/ Because req and res were created before this domain existed,     \/\/ we need to explicitly add them.     \/\/ See the explanation of implicit vs explicit binding below.     d.add(req);     d.add(res);      \/\/ Now run the handler function in the domain.     d.run(() => {       handleRequest(req, res);     });   });   server.listen(PORT); }  \/\/ This part is not important. Just an example routing thing. \/\/ Put fancy application logic here. function handleRequest(req, res) {   switch (req.url) {     case '\/error':       \/\/ We do some async stuff, and then...       setTimeout(() => {         \/\/ Whoops!         flerb.bark();       }, timeout);       break;     default:       res.end('ok');   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_additions_to_error_objects","title":"Additions to `Error` objects","description":"Any time an Error object is routed through a domain, a few extra fields are added to it.  error.domain The domain that first handled the error. error.domainEmitter The event emitter that emitted an 'error' event with the error object. error.domainBound The callback function which was bound to the domain, and passed an error as its first argument. error.domainThrown A boolean indicating whether the error was thrown, emitted, or passed to a bound callback function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implicit_binding","title":"Implicit binding","description":"If domains are in use, then all new EventEmitter objects (including Stream objects, requests, responses, etc.) will be implicitly bound to the active domain at the time of their creation. Additionally, callbacks passed to lowlevel event loop requests (such as to fs.open(), or other callback-taking methods) will automatically be bound to the active domain. If they throw, then the domain will catch the error. In order to prevent excessive memory usage, Domain objects themselves are not implicitly added as children of the active domain. If they were, then it would be too easy to prevent request and response objects from being properly garbage collected. To nest Domain objects as children of a parent Domain they must be explicitly added. Implicit binding routes thrown errors and 'error' events to the Domain's 'error' event, but does not register the EventEmitter on the Domain. Implicit binding only takes care of thrown errors and 'error' events."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_explicit_binding","title":"Explicit binding","description":"Sometimes, the domain in use is not the one that ought to be used for a specific event emitter. Or, the event emitter could have been created in the context of one domain, but ought to instead be bound to some other domain. For example, there could be one domain in use for an HTTP server, but perhaps we would like to have a separate domain to use for each request. That is possible via explicit binding. \/\/ Create a top-level domain for the server const domain = require('domain'); const http = require('http'); const serverDomain = domain.create();  serverDomain.run(() => {   \/\/ Server is created in the scope of serverDomain   http.createServer((req, res) => {     \/\/ Req and res are also created in the scope of serverDomain     \/\/ however, we'd prefer to have a separate domain for each request.     \/\/ create it first thing, and add req and res to it.     const reqd = domain.create();     reqd.add(req);     reqd.add(res);     reqd.on('error', (er) => {       console.error('Error', er, req.url);       try {         res.writeHead(500);         res.end('Error occurred, sorry.');       } catch (er2) {         console.error('Error sending 500', er2, req.url);       }     });   }).listen(1337); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_domains_and_promises","title":"Domains and promises","description":"As of Node.js 8.0.0, the handlers of promises are run inside the domain in which the call to .then() or .catch() itself was made: const d1 = domain.create(); const d2 = domain.create();  let p; d1.run(() => {   p = Promise.resolve(42); });  d2.run(() => {   p.then((v) => {     \/\/ running in d2   }); });  A callback may be bound to a specific domain using domain.bind(callback): const d1 = domain.create(); const d2 = domain.create();  let p; d1.run(() => {   p = Promise.resolve(42); });  d2.run(() => {   p.then(p.domain.bind((v) => {     \/\/ running in d1   })); });  Domains will not interfere with the error handling mechanisms for promises. In other words, no 'error' event will be emitted for unhandled Promise rejections."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_events","title":"Events","description":"Source Code: lib\/events.js Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called \"emitters\") emit named events that cause Function objects (\"listeners\") to be called. For instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read. All objects that emit events are instances of the EventEmitter class. These objects expose an eventEmitter.on() function that allows one or more functions to be attached to named events emitted by the object. Typically, event names are camel-cased strings but any valid JavaScript property key can be used. When the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. Any values returned by the called listeners are ignored and discarded. The following example shows a simple EventEmitter instance with a single listener. The eventEmitter.on() method is used to register listeners, while the eventEmitter.emit() method is used to trigger the event. const EventEmitter = require('events');  class MyEmitter extends EventEmitter {}  const myEmitter = new MyEmitter(); myEmitter.on('event', () => {   console.log('an event occurred!'); }); myEmitter.emit('event');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_events_geteventlisteners_emitterortarget_eventname","title":"`events.getEventListeners(emitterOrTarget, eventName)`","description":"Returns a copy of the array of listeners for the event named eventName. For EventEmitters this behaves exactly the same as calling .listeners on the emitter. For EventTargets this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes. const { getEventListeners, EventEmitter } = require('events');  {   const ee = new EventEmitter();   const listener = () => console.log('Events are fun');   ee.on('foo', listener);   getEventListeners(ee, 'foo'); \/\/ [listener] } {   const et = new EventTarget();   const listener = () => console.log('Events are fun');   et.addEventListener('foo', listener);   getEventListeners(et, 'foo'); \/\/ [listener] }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_events_once_emitter_name_options","title":"`events.once(emitter, name[, options])`","description":"Creates a Promise that is fulfilled when the EventEmitter emits the given event or that is rejected if the EventEmitter emits 'error' while waiting. The Promise will resolve with an array of all the arguments emitted to the given event. This method is intentionally generic and works with the web platform EventTarget interface, which has no special 'error' event semantics and does not listen to the 'error' event. const { once, EventEmitter } = require('events');  async function run() {   const ee = new EventEmitter();    process.nextTick(() => {     ee.emit('myevent', 42);   });    const [value] = await once(ee, 'myevent');   console.log(value);    const err = new Error('kaboom');   process.nextTick(() => {     ee.emit('error', err);   });    try {     await once(ee, 'myevent');   } catch (err) {     console.log('error happened', err);   } }  run();  The special handling of the 'error' event is only used when events.once() is used to wait for another event. If events.once() is used to wait for the 'error' event itself, then it is treated as any other kind of event without special handling: const { EventEmitter, once } = require('events');  const ee = new EventEmitter();  once(ee, 'error')   .then(([err]) => console.log('ok', err.message))   .catch((err) => console.log('error', err.message));  ee.emit('error', new Error('boom'));  \/\/ Prints: ok boom  An <AbortSignal> can be used to cancel waiting for the event: const { EventEmitter, once } = require('events');  const ee = new EventEmitter(); const ac = new AbortController();  async function foo(emitter, event, signal) {   try {     await once(emitter, event, { signal });     console.log('event emitted!');   } catch (error) {     if (error.name === 'AbortError') {       console.error('Waiting for the event was canceled!');     } else {       console.error('There was an error', error.message);     }   } }  foo(ee, 'foo', ac.signal); ac.abort(); \/\/ Abort waiting for the event ee.emit('foo'); \/\/ Prints: Waiting for the event was canceled!"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_awaiting_multiple_events_emitted_on_process_nexttick","title":"Awaiting multiple events emitted on `process.nextTick()`","description":"There is an edge case worth noting when using the events.once() function to await multiple events emitted on in the same batch of process.nextTick() operations, or whenever multiple events are emitted synchronously. Specifically, because the process.nextTick() queue is drained before the Promise microtask queue, and because EventEmitter emits all events synchronously, it is possible for events.once() to miss an event. const { EventEmitter, once } = require('events');  const myEE = new EventEmitter();  async function foo() {   await once(myEE, 'bar');   console.log('bar');    \/\/ This Promise will never resolve because the 'foo' event will   \/\/ have already been emitted before the Promise is created.   await once(myEE, 'foo');   console.log('foo'); }  process.nextTick(() => {   myEE.emit('bar');   myEE.emit('foo'); });  foo().then(() => console.log('done'));  To catch both events, create each of the Promises before awaiting either of them, then it becomes possible to use Promise.all(), Promise.race(), or Promise.allSettled(): const { EventEmitter, once } = require('events');  const myEE = new EventEmitter();  async function foo() {   await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);   console.log('foo', 'bar'); }  process.nextTick(() => {   myEE.emit('bar');   myEE.emit('foo'); });  foo().then(() => console.log('done'));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_events_on_emitter_eventname_options","title":"`events.on(emitter, eventName[, options])`","description":"const { on, EventEmitter } = require('events');  (async () => {   const ee = new EventEmitter();    \/\/ Emit later on   process.nextTick(() => {     ee.emit('foo', 'bar');     ee.emit('foo', 42);   });    for await (const event of on(ee, 'foo')) {     \/\/ The execution of this inner block is synchronous and it     \/\/ processes one event at a time (even with await). Do not use     \/\/ if concurrent execution is required.     console.log(event); \/\/ prints ['bar'] [42]   }   \/\/ Unreachable here })();  Returns an AsyncIterator that iterates eventName events. It will throw if the EventEmitter emits 'error'. It removes all listeners when exiting the loop. The value returned by each iteration is an array composed of the emitted event arguments. An <AbortSignal> can be used to cancel waiting on events: const { on, EventEmitter } = require('events'); const ac = new AbortController();  (async () => {   const ee = new EventEmitter();    \/\/ Emit later on   process.nextTick(() => {     ee.emit('foo', 'bar');     ee.emit('foo', 42);   });    for await (const event of on(ee, 'foo', { signal: ac.signal })) {     \/\/ The execution of this inner block is synchronous and it     \/\/ processes one event at a time (even with await). Do not use     \/\/ if concurrent execution is required.     console.log(event); \/\/ prints ['bar'] [42]   }   \/\/ Unreachable here })();  process.nextTick(() => ac.abort());"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_passing_arguments_and_this_to_listeners","title":"Passing arguments and `this` to listeners","description":"The eventEmitter.emit() method allows an arbitrary set of arguments to be passed to the listener functions. Keep in mind that when an ordinary listener function is called, the standard this keyword is intentionally set to reference the EventEmitter instance to which the listener is attached. const myEmitter = new MyEmitter(); myEmitter.on('event', function(a, b) {   console.log(a, b, this, this === myEmitter);   \/\/ Prints:   \/\/   a b MyEmitter {   \/\/     domain: null,   \/\/     _events: { event: [Function] },   \/\/     _eventsCount: 1,   \/\/     _maxListeners: undefined } true }); myEmitter.emit('event', 'a', 'b');  It is possible to use ES6 Arrow Functions as listeners, however, when doing so, the this keyword will no longer reference the EventEmitter instance: const myEmitter = new MyEmitter(); myEmitter.on('event', (a, b) => {   console.log(a, b, this);   \/\/ Prints: a b {} }); myEmitter.emit('event', 'a', 'b');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_asynchronous_vs_synchronous","title":"Asynchronous vs. synchronous","description":"The EventEmitter calls all listeners synchronously in the order in which they were registered. This ensures the proper sequencing of events and helps avoid race conditions and logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods: const myEmitter = new MyEmitter(); myEmitter.on('event', (a, b) => {   setImmediate(() => {     console.log('this happens asynchronously');   }); }); myEmitter.emit('event', 'a', 'b');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_handling_events_only_once","title":"Handling events only once","description":"When a listener is registered using the eventEmitter.on() method, that listener is invoked every time the named event is emitted. const myEmitter = new MyEmitter(); let m = 0; myEmitter.on('event', () => {   console.log(++m); }); myEmitter.emit('event'); \/\/ Prints: 1 myEmitter.emit('event'); \/\/ Prints: 2  Using the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called. const myEmitter = new MyEmitter(); let m = 0; myEmitter.once('event', () => {   console.log(++m); }); myEmitter.emit('event'); \/\/ Prints: 1 myEmitter.emit('event'); \/\/ Ignored"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_events","title":"Error events","description":"When an error occurs within an EventEmitter instance, the typical action is for an 'error' event to be emitted. These are treated as special cases within Node.js. If an EventEmitter does not have at least one listener registered for the 'error' event, and an 'error' event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits. const myEmitter = new MyEmitter(); myEmitter.emit('error', new Error('whoops!')); \/\/ Throws and crashes Node.js  To guard against crashing the Node.js process the domain module can be used. (Note, however, that the domain module is deprecated.) As a best practice, listeners should always be added for the 'error' events. const myEmitter = new MyEmitter(); myEmitter.on('error', (err) => {   console.error('whoops! there was an error'); }); myEmitter.emit('error', new Error('whoops!')); \/\/ Prints: whoops! there was an error  It is possible to monitor 'error' events without consuming the emitted error by installing a listener using the symbol errorMonitor. const myEmitter = new MyEmitter(); myEmitter.on(EventEmitter.errorMonitor, (err) => {   MyMonitoringTool.log(err); }); myEmitter.emit('error', new Error('whoops!')); \/\/ Still throws and crashes Node.js"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_capture_rejections_of_promises","title":"Capture rejections of promises","description":"Using async functions with event handlers is problematic, because it can lead to an unhandled rejection in case of a thrown exception: const ee = new EventEmitter(); ee.on('something', async (value) => {   throw new Error('kaboom'); });  The captureRejections option in the EventEmitter constructor or the global setting change this behavior, installing a .then(undefined, handler) handler on the Promise. This handler routes the exception asynchronously to the Symbol.for('nodejs.rejection') method if there is one, or to 'error' event handler if there is none. const ee1 = new EventEmitter({ captureRejections: true }); ee1.on('something', async (value) => {   throw new Error('kaboom'); });  ee1.on('error', console.log);  const ee2 = new EventEmitter({ captureRejections: true }); ee2.on('something', async (value) => {   throw new Error('kaboom'); });  ee2[Symbol.for('nodejs.rejection')] = console.log;  Setting EventEmitter.captureRejections = true will change the default for all new instances of EventEmitter. EventEmitter.captureRejections = true; const ee1 = new EventEmitter(); ee1.on('something', async (value) => {   throw new Error('kaboom'); });  ee1.on('error', console.log);  The 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_eventtarget_and_event_api","title":"`EventTarget` and `Event` API","description":"The EventTarget and Event objects are a Node.js-specific implementation of the EventTarget Web API that are exposed by some Node.js core APIs. Neither the EventTarget nor Event classes are available for end user code to create. const target = new EventTarget();  target.addEventListener('foo', (event) => {   console.log('foo event happened!'); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_js_eventtarget_vs_dom_eventtarget","title":"Node.js `EventTarget` vs. DOM `EventTarget`","description":"There are two key differences between the Node.js EventTarget and the EventTarget Web API:  Whereas DOM EventTarget instances may be hierarchical, there is no concept of hierarchy and event propagation in Node.js. That is, an event dispatched to an EventTarget does not propagate through a hierarchy of nested target objects that may each have their own set of handlers for the event. In the Node.js EventTarget, if an event listener is an async function or returns a Promise, and the returned Promise rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see EventTarget error handling for details)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_nodeeventtarget_vs_eventemitter","title":"`NodeEventTarget` vs. `EventEmitter`","description":"The NodeEventTarget object implements a modified subset of the EventEmitter API that allows it to closely emulate an EventEmitter in certain situations. A NodeEventTarget is not an instance of EventEmitter and cannot be used in place of an EventEmitter in most cases.  Unlike EventEmitter, any given listener can be registered at most once per event type. Attempts to register a listener multiple times are ignored. The NodeEventTarget does not emulate the full EventEmitter API. Specifically the prependListener(), prependOnceListener(), rawListeners(), setMaxListeners(), getMaxListeners(), and errorMonitor APIs are not emulated. The 'newListener' and 'removeListener' events will also not be emitted. The NodeEventTarget does not implement any special default behavior for events with type 'error'. The NodeEventTarget supports EventListener objects as well as functions as handlers for all event types."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_event_listener","title":"Event listener","description":"Event listeners registered for an event type may either be JavaScript functions or objects with a handleEvent property whose value is a function. In either case, the handler function is invoked with the event argument passed to the eventTarget.dispatchEvent() function. Async functions may be used as event listeners. If an async handler function rejects, the rejection is captured and handled as described in EventTarget error handling. An error thrown by one handler function does not prevent the other handlers from being invoked. The return value of a handler function is ignored. Handlers are always invoked in the order they were added. Handler functions may mutate the event object. function handler1(event) {   console.log(event.type);  \/\/ Prints 'foo'   event.a = 1; }  async function handler2(event) {   console.log(event.type);  \/\/ Prints 'foo'   console.log(event.a);  \/\/ Prints 1 }  const handler3 = {   handleEvent(event) {     console.log(event.type);  \/\/ Prints 'foo'   } };  const handler4 = {   async handleEvent(event) {     console.log(event.type);  \/\/ Prints 'foo'   } };  const target = new EventTarget();  target.addEventListener('foo', handler1); target.addEventListener('foo', handler2); target.addEventListener('foo', handler3); target.addEventListener('foo', handler4, { once: true });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_eventtarget_error_handling","title":"`EventTarget` error handling","description":"When a registered event listener throws (or returns a Promise that rejects), by default the error is forwarded to the process.on('error') event on process.nextTick(). Throwing within an event listener will not stop the other registered handlers from being invoked. The EventTarget does not implement any special default handling for 'error' type events."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_system","title":"File system","description":"Source Code: lib\/fs.js The fs module enables interacting with the file system in a way modeled on standard POSIX functions. To use this module: const fs = require('fs');  All file system operations have synchronous, callback, and promise-based forms."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_access_path_mode_callback","title":"`fs.access(path[, mode], callback)`","description":"Tests a user's permissions for the file or directory specified by path. The mode argument is an optional integer that specifies the accessibility checks to be performed. Check File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK). The final argument, callback, is a callback function that is invoked with a possible error argument. If any of the accessibility checks fail, the error argument will be an Error object. The following examples check if package.json exists, and if it is readable or writable. const file = 'package.json';  \/\/ Check if the file exists in the current directory. fs.access(file, fs.constants.F_OK, (err) => {   console.log(`${file} ${err ? 'does not exist' : 'exists'}`); });  \/\/ Check if the file is readable. fs.access(file, fs.constants.R_OK, (err) => {   console.log(`${file} ${err ? 'is not readable' : 'is readable'}`); });  \/\/ Check if the file is writable. fs.access(file, fs.constants.W_OK, (err) => {   console.log(`${file} ${err ? 'is not writable' : 'is writable'}`); });  \/\/ Check if the file exists in the current directory, and if it is writable. fs.access(file, fs.constants.F_OK | fs.constants.W_OK, (err) => {   if (err) {     console.error(       `${file} ${err.code === 'ENOENT' ? 'does not exist' : 'is read-only'}`);   } else {     console.log(`${file} exists, and it is writable`);   } });  Do not use fs.access() to check for the accessibility of a file before calling fs.open(), fs.readFile() or fs.writeFile(). Doing so introduces a race condition, since other processes may change the file's state between the two calls. Instead, user code should open\/read\/write the file directly and handle the error raised if the file is not accessible. write (NOT RECOMMENDED) fs.access('myfile', (err) => {   if (!err) {     console.error('myfile already exists');     return;   }    fs.open('myfile', 'wx', (err, fd) => {     if (err) throw err;     writeMyData(fd);   }); });  write (RECOMMENDED) fs.open('myfile', 'wx', (err, fd) => {   if (err) {     if (err.code === 'EEXIST') {       console.error('myfile already exists');       return;     }      throw err;   }    writeMyData(fd); });  read (NOT RECOMMENDED) fs.access('myfile', (err) => {   if (err) {     if (err.code === 'ENOENT') {       console.error('myfile does not exist');       return;     }      throw err;   }    fs.open('myfile', 'r', (err, fd) => {     if (err) throw err;     readMyData(fd);   }); });  read (RECOMMENDED) fs.open('myfile', 'r', (err, fd) => {   if (err) {     if (err.code === 'ENOENT') {       console.error('myfile does not exist');       return;     }      throw err;   }    readMyData(fd); });  The \"not recommended\" examples above check for accessibility and then use the file; the \"recommended\" examples are better because they use the file directly and handle the error, if any. In general, check for the accessibility of a file only if the file will not be used directly, for example when its accessibility is a signal from another process. On Windows, access-control policies (ACLs) on a directory may limit access to a file or directory. The fs.access() function, however, does not check the ACL and therefore may report that a path is accessible even if the ACL restricts the user from reading or writing to it."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_accesssync_path_mode","title":"`fs.accessSync(path[, mode])`","description":"Synchronously tests a user's permissions for the file or directory specified by path. The mode argument is an optional integer that specifies the accessibility checks to be performed. Check File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK). If any of the accessibility checks fail, an Error will be thrown. Otherwise, the method will return undefined. try {   fs.accessSync('etc\/passwd', fs.constants.R_OK | fs.constants.W_OK);   console.log('can read\/write'); } catch (err) {   console.error('no access!'); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_appendfile_path_data_options_callback","title":"`fs.appendFile(path, data[, options], callback)`","description":"Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer. fs.appendFile('message.txt', 'data to append', (err) => {   if (err) throw err;   console.log('The \"data to append\" was appended to file!'); });  If options is a string, then it specifies the encoding: fs.appendFile('message.txt', 'data to append', 'utf8', callback);  The path may be specified as a numeric file descriptor that has been opened for appending (using fs.open() or fs.openSync()). The file descriptor will not be closed automatically. fs.open('message.txt', 'a', (err, fd) => {   if (err) throw err;   fs.appendFile(fd, 'data to append', 'utf8', (err) => {     fs.close(fd, (err) => {       if (err) throw err;     });     if (err) throw err;   }); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_appendfilesync_path_data_options","title":"`fs.appendFileSync(path, data[, options])`","description":"Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer. try {   fs.appendFileSync('message.txt', 'data to append');   console.log('The \"data to append\" was appended to file!'); } catch (err) {   \/* Handle the error *\/ }  If options is a string, then it specifies the encoding: fs.appendFileSync('message.txt', 'data to append', 'utf8');  The path may be specified as a numeric file descriptor that has been opened for appending (using fs.open() or fs.openSync()). The file descriptor will not be closed automatically. let fd;  try {   fd = fs.openSync('message.txt', 'a');   fs.appendFileSync(fd, 'data to append', 'utf8'); } catch (err) {   \/* Handle the error *\/ } finally {   if (fd !== undefined)     fs.closeSync(fd); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chmod_path_mode_callback","title":"`fs.chmod(path, mode, callback)`","description":"Asynchronously changes the permissions of a file. No arguments other than a possible exception are given to the completion callback. See also: chmod(2). fs.chmod('my_file.txt', 0o775, (err) => {   if (err) throw err;   console.log('The permissions for file \"my_file.txt\" have been changed!'); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_modes","title":"File modes","description":"The mode argument used in both the fs.chmod() and fs.chmodSync() methods is a numeric bitmask created using a logical OR of the following constants:    Constant Octal Description     fs.constants.S_IRUSR 0o400 read by owner   fs.constants.S_IWUSR 0o200 write by owner   fs.constants.S_IXUSR 0o100 execute\/search by owner   fs.constants.S_IRGRP 0o40 read by group   fs.constants.S_IWGRP 0o20 write by group   fs.constants.S_IXGRP 0o10 execute\/search by group   fs.constants.S_IROTH 0o4 read by others   fs.constants.S_IWOTH 0o2 write by others   fs.constants.S_IXOTH 0o1 execute\/search by others    An easier method of constructing the mode is to use a sequence of three octal digits (e.g. 765). The left-most digit (7 in the example), specifies the permissions for the file owner. The middle digit (6 in the example), specifies permissions for the group. The right-most digit (5 in the example), specifies the permissions for others.    Number Description     7 read, write, and execute   6 read and write   5 read and execute   4 read only   3 write and execute   2 write only   1 execute only   0 no permission    For example, the octal value 0o765 means:  The owner may read, write and execute the file. The group may read and write the file. Others may read and execute the file.  When using raw numbers where file modes are expected, any value larger than 0o777 may result in platform-specific behaviors that are not supported to work consistently. Therefore constants like S_ISVTX, S_ISGID or S_ISUID are not exposed in fs.constants. Caveats: on Windows only the write permission can be changed, and the distinction among the permissions of group, owner or others is not implemented."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chmodsync_path_mode","title":"`fs.chmodSync(path, mode)`","description":"For detailed information, see the documentation of the asynchronous version of this API: fs.chmod(). See also: chmod(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chown_path_uid_gid_callback","title":"`fs.chown(path, uid, gid, callback)`","description":"Asynchronously changes owner and group of a file. No arguments other than a possible exception are given to the completion callback. See also: chown(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_chownsync_path_uid_gid","title":"`fs.chownSync(path, uid, gid)`","description":"Synchronously changes owner and group of a file. Returns undefined. This is the synchronous version of fs.chown(). See also: chown(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_close_fd_callback","title":"`fs.close(fd, callback)`","description":"Asynchronous close(2). No arguments other than a possible exception are given to the completion callback. Calling fs.close() on any file descriptor (fd) that is currently in use through any other fs operation may lead to undefined behavior."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_closesync_fd","title":"`fs.closeSync(fd)`","description":"Synchronous close(2). Returns undefined. Calling fs.closeSync() on any file descriptor (fd) that is currently in use through any other fs operation may lead to undefined behavior."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_copyfile_src_dest_mode_callback","title":"`fs.copyFile(src, dest[, mode], callback)`","description":"Asynchronously copies src to dest. By default, dest is overwritten if it already exists. No arguments other than a possible exception are given to the callback function. Node.js makes no guarantees about the atomicity of the copy operation. If an error occurs after the destination file has been opened for writing, Node.js will attempt to remove the destination. mode is an optional integer that specifies the behavior of the copy operation. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE).  fs.constants.COPYFILE_EXCL: The copy operation will fail if dest already exists. fs.constants.COPYFILE_FICLONE: The copy operation will attempt to create a copy-on-write reflink. If the platform does not support copy-on-write, then a fallback copy mechanism is used. fs.constants.COPYFILE_FICLONE_FORCE: The copy operation will attempt to create a copy-on-write reflink. If the platform does not support copy-on-write, then the operation will fail.  const fs = require('fs'); const { COPYFILE_EXCL } = fs.constants;  function callback(err) {   if (err) throw err;   console.log('source.txt was copied to destination.txt'); }  \/\/ destination.txt will be created or overwritten by default. fs.copyFile('source.txt', 'destination.txt', callback);  \/\/ By using COPYFILE_EXCL, the operation will fail if destination.txt exists. fs.copyFile('source.txt', 'destination.txt', COPYFILE_EXCL, callback);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_copyfilesync_src_dest_mode","title":"`fs.copyFileSync(src, dest[, mode])`","description":"Synchronously copies src to dest. By default, dest is overwritten if it already exists. Returns undefined. Node.js makes no guarantees about the atomicity of the copy operation. If an error occurs after the destination file has been opened for writing, Node.js will attempt to remove the destination. mode is an optional integer that specifies the behavior of the copy operation. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE).  fs.constants.COPYFILE_EXCL: The copy operation will fail if dest already exists. fs.constants.COPYFILE_FICLONE: The copy operation will attempt to create a copy-on-write reflink. If the platform does not support copy-on-write, then a fallback copy mechanism is used. fs.constants.COPYFILE_FICLONE_FORCE: The copy operation will attempt to create a copy-on-write reflink. If the platform does not support copy-on-write, then the operation will fail.  const fs = require('fs'); const { COPYFILE_EXCL } = fs.constants;  \/\/ destination.txt will be created or overwritten by default. fs.copyFileSync('source.txt', 'destination.txt'); console.log('source.txt was copied to destination.txt');  \/\/ By using COPYFILE_EXCL, the operation will fail if destination.txt exists. fs.copyFileSync('source.txt', 'destination.txt', COPYFILE_EXCL);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_createreadstream_path_options","title":"`fs.createReadStream(path[, options])`","description":"Unlike the 16 kb default highWaterMark for a readable stream, the stream returned by this method has a default highWaterMark of 64 kb. options can include start and end values to read a range of bytes from the file instead of the entire file. Both start and end are inclusive and start counting at 0, allowed values are in the [0, Number.MAX_SAFE_INTEGER] range. If fd is specified and start is omitted or undefined, fs.createReadStream() reads sequentially from the current file position. The encoding can be any one of those accepted by Buffer. If fd is specified, ReadStream will ignore the path argument and will use the specified file descriptor. This means that no 'open' event will be emitted. fd should be blocking; non-blocking fds should be passed to net.Socket. If fd points to a character device that only supports blocking reads (such as keyboard or sound card), read operations do not finish until data is available. This can prevent the process from exiting and the stream from closing naturally. By default, the stream will not emit a 'close' event after it has been destroyed. This is the opposite of the default for other Readable streams. Set the emitClose option to true to change this behavior. By providing the fs option, it is possible to override the corresponding fs implementations for open, read, and close. When providing the fs option, overrides for open, read, and close are required. const fs = require('fs'); \/\/ Create a stream from some character device. const stream = fs.createReadStream('\/dev\/input\/event0'); setTimeout(() => {   stream.close(); \/\/ This may not close the stream.   \/\/ Artificially marking end-of-stream, as if the underlying resource had   \/\/ indicated end-of-file by itself, allows the stream to close.   \/\/ This does not cancel pending read operations, and if there is such an   \/\/ operation, the process may still not be able to exit successfully   \/\/ until it finishes.   stream.push(null);   stream.read(0); }, 100);  If autoClose is false, then the file descriptor won't be closed, even if there's an error. It is the application's responsibility to close it and make sure there's no file descriptor leak. If autoClose is set to true (default behavior), on 'error' or 'end' the file descriptor will be closed automatically. mode sets the file mode (permission and sticky bits), but only if the file was created. An example to read the last 10 bytes of a file which is 100 bytes long: fs.createReadStream('sample.txt', { start: 90, end: 99 });  If options is a string, then it specifies the encoding."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_createwritestream_path_options","title":"`fs.createWriteStream(path[, options])`","description":"options may also include a start option to allow writing data at some position past the beginning of the file, allowed values are in the [0, Number.MAX_SAFE_INTEGER] range. Modifying a file rather than replacing it may require the flags option to be set to r+ rather than the default w. The encoding can be any one of those accepted by Buffer. If autoClose is set to true (default behavior) on 'error' or 'finish' the file descriptor will be closed automatically. If autoClose is false, then the file descriptor won't be closed, even if there's an error. It is the application's responsibility to close it and make sure there's no file descriptor leak. By default, the stream will not emit a 'close' event after it has been destroyed. This is the opposite of the default for other Writable streams. Set the emitClose option to true to change this behavior. By providing the fs option it is possible to override the corresponding fs implementations for open, write, writev and close. Overriding write() without writev() can reduce performance as some optimizations (_writev()) will be disabled. When providing the fs option,  overrides for open, close, and at least one of write and writev are required. Like ReadStream, if fd is specified, WriteStream will ignore the path argument and will use the specified file descriptor. This means that no 'open' event will be emitted. fd should be blocking; non-blocking fds should be passed to net.Socket. If options is a string, then it specifies the encoding."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_exists_path_callback","title":"`fs.exists(path, callback)`","description":"Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false: fs.exists('\/etc\/passwd', (exists) => {   console.log(exists ? 'it\\'s there' : 'no passwd!'); });  The parameters for this callback are not consistent with other Node.js callbacks. Normally, the first parameter to a Node.js callback is an err parameter, optionally followed by other parameters. The fs.exists() callback has only one boolean parameter. This is one reason fs.access() is recommended instead of fs.exists(). Using fs.exists() to check for the existence of a file before calling fs.open(), fs.readFile() or fs.writeFile() is not recommended. Doing so introduces a race condition, since other processes may change the file's state between the two calls. Instead, user code should open\/read\/write the file directly and handle the error raised if the file does not exist. write (NOT RECOMMENDED) fs.exists('myfile', (exists) => {   if (exists) {     console.error('myfile already exists');   } else {     fs.open('myfile', 'wx', (err, fd) => {       if (err) throw err;       writeMyData(fd);     });   } });  write (RECOMMENDED) fs.open('myfile', 'wx', (err, fd) => {   if (err) {     if (err.code === 'EEXIST') {       console.error('myfile already exists');       return;     }      throw err;   }    writeMyData(fd); });  read (NOT RECOMMENDED) fs.exists('myfile', (exists) => {   if (exists) {     fs.open('myfile', 'r', (err, fd) => {       if (err) throw err;       readMyData(fd);     });   } else {     console.error('myfile does not exist');   } });  read (RECOMMENDED) fs.open('myfile', 'r', (err, fd) => {   if (err) {     if (err.code === 'ENOENT') {       console.error('myfile does not exist');       return;     }      throw err;   }    readMyData(fd); });  The \"not recommended\" examples above check for existence and then use the file; the \"recommended\" examples are better because they use the file directly and handle the error, if any. In general, check for the existence of a file only if the file won\u2019t be used directly, for example when its existence is a signal from another process."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_existssync_path","title":"`fs.existsSync(path)`","description":"Returns true if the path exists, false otherwise. For detailed information, see the documentation of the asynchronous version of this API: fs.exists(). fs.exists() is deprecated, but fs.existsSync() is not. The callback parameter to fs.exists() accepts parameters that are inconsistent with other Node.js callbacks. fs.existsSync() does not use a callback. if (fs.existsSync('\/etc\/passwd')) {   console.log('The path exists.'); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchmod_fd_mode_callback","title":"`fs.fchmod(fd, mode, callback)`","description":"Asynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchmodsync_fd_mode","title":"`fs.fchmodSync(fd, mode)`","description":"Synchronous fchmod(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchown_fd_uid_gid_callback","title":"`fs.fchown(fd, uid, gid, callback)`","description":"Asynchronous fchown(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fchownsync_fd_uid_gid","title":"`fs.fchownSync(fd, uid, gid)`","description":"Synchronous fchown(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fdatasync_fd_callback","title":"`fs.fdatasync(fd, callback)`","description":"Asynchronous fdatasync(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fdatasyncsync_fd","title":"`fs.fdatasyncSync(fd)`","description":"Synchronous fdatasync(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fstat_fd_options_callback","title":"`fs.fstat(fd[, options], callback)`","description":"Asynchronous fstat(2). The callback gets two arguments (err, stats) where stats is an fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fstatsync_fd_options","title":"`fs.fstatSync(fd[, options])`","description":"Synchronous fstat(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fsync_fd_callback","title":"`fs.fsync(fd, callback)`","description":"Asynchronous fsync(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_fsyncsync_fd","title":"`fs.fsyncSync(fd)`","description":"Synchronous fsync(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_ftruncate_fd_len_callback","title":"`fs.ftruncate(fd[, len], callback)`","description":"Asynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback. If the file referred to by the file descriptor was larger than len bytes, only the first len bytes will be retained in the file. For example, the following program retains only the first four bytes of the file: console.log(fs.readFileSync('temp.txt', 'utf8')); \/\/ Prints: Node.js  \/\/ get the file descriptor of the file to be truncated const fd = fs.openSync('temp.txt', 'r+');  \/\/ Truncate the file to first four bytes fs.ftruncate(fd, 4, (err) => {   assert.ifError(err);   console.log(fs.readFileSync('temp.txt', 'utf8')); }); \/\/ Prints: Node  If the file previously was shorter than len bytes, it is extended, and the extended part is filled with null bytes ('\\0'): console.log(fs.readFileSync('temp.txt', 'utf8')); \/\/ Prints: Node.js  \/\/ get the file descriptor of the file to be truncated const fd = fs.openSync('temp.txt', 'r+');  \/\/ Truncate the file to 10 bytes, whereas the actual size is 7 bytes fs.ftruncate(fd, 10, (err) => {   assert.ifError(err);   console.log(fs.readFileSync('temp.txt')); }); \/\/ Prints: <Buffer 4e 6f 64 65 2e 6a 73 00 00 00> \/\/ ('Node.js\\0\\0\\0' in UTF8)  The last three bytes are null bytes ('\\0'), to compensate the over-truncation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_ftruncatesync_fd_len","title":"`fs.ftruncateSync(fd[, len])`","description":"Returns undefined. For detailed information, see the documentation of the asynchronous version of this API: fs.ftruncate()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_futimes_fd_atime_mtime_callback","title":"`fs.futimes(fd, atime, mtime, callback)`","description":"Change the file system timestamps of the object referenced by the supplied file descriptor. See fs.utimes(). This function does not work on AIX versions before 7.1, it will return the error UV_ENOSYS."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_futimessync_fd_atime_mtime","title":"`fs.futimesSync(fd, atime, mtime)`","description":"Synchronous version of fs.futimes(). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchmod_path_mode_callback","title":"`fs.lchmod(path, mode, callback)`","description":"Asynchronous lchmod(2). No arguments other than a possible exception are given to the completion callback. Only available on macOS."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchmodsync_path_mode","title":"`fs.lchmodSync(path, mode)`","description":"Synchronous lchmod(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchown_path_uid_gid_callback","title":"`fs.lchown(path, uid, gid, callback)`","description":"Asynchronous lchown(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lchownsync_path_uid_gid","title":"`fs.lchownSync(path, uid, gid)`","description":"Synchronous lchown(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lutimes_path_atime_mtime_callback","title":"`fs.lutimes(path, atime, mtime, callback)`","description":"Changes the access and modification times of a file in the same way as fs.utimes(), with the difference that if the path refers to a symbolic link, then the link is not dereferenced: instead, the timestamps of the symbolic link itself are changed. No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lutimessync_path_atime_mtime","title":"`fs.lutimesSync(path, atime, mtime)`","description":"Change the file system timestamps of the symbolic link referenced by path. Returns undefined, or throws an exception when parameters are incorrect or the operation fails. This is the synchronous version of fs.lutimes()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_link_existingpath_newpath_callback","title":"`fs.link(existingPath, newPath, callback)`","description":"Asynchronous link(2). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_linksync_existingpath_newpath","title":"`fs.linkSync(existingPath, newPath)`","description":"Synchronous link(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lstat_path_options_callback","title":"`fs.lstat(path[, options], callback)`","description":"Asynchronous lstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_lstatsync_path_options","title":"`fs.lstatSync(path[, options])`","description":"Synchronous lstat(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_mkdir_path_options_callback","title":"`fs.mkdir(path[, options], callback)`","description":"Asynchronously creates a directory. The callback is given a possible exception and, if recursive is true, the first directory path created, (err, [path]). The optional options argument can be an integer specifying mode (permission and sticky bits), or an object with a mode property and a recursive property indicating whether parent directories should be created. Calling fs.mkdir() when path is a directory that exists results in an error only when recursive is false. \/\/ Creates \/tmp\/a\/apple, regardless of whether `\/tmp` and \/tmp\/a exist. fs.mkdir('\/tmp\/a\/apple', { recursive: true }, (err) => {   if (err) throw err; });  On Windows, using fs.mkdir() on the root directory even with recursion will result in an error: fs.mkdir('\/', { recursive: true }, (err) => {   \/\/ => [Error: EPERM: operation not permitted, mkdir 'C:\\'] });  See also: mkdir(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_mkdirsync_path_options","title":"`fs.mkdirSync(path[, options])`","description":"Synchronously creates a directory. Returns undefined, or if recursive is true, the first directory path created. This is the synchronous version of fs.mkdir(). See also: mkdir(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_mkdtemp_prefix_options_callback","title":"`fs.mkdtemp(prefix[, options], callback)`","description":"Creates a unique temporary directory. Generates six random characters to be appended behind a required prefix to create a unique temporary directory. Due to platform inconsistencies, avoid trailing X characters in prefix. Some platforms, notably the BSDs, can return more than six random characters, and replace trailing X characters in prefix with random characters. The created directory path is passed as a string to the callback's second parameter. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use. fs.mkdtemp(path.join(os.tmpdir(), 'foo-'), (err, directory) => {   if (err) throw err;   console.log(directory);   \/\/ Prints: \/tmp\/foo-itXde2 or C:\\Users\\...\\AppData\\Local\\Temp\\foo-itXde2 });  The fs.mkdtemp() method will append the six randomly selected characters directly to the prefix string. For instance, given a directory \/tmp, if the intention is to create a temporary directory within \/tmp, the prefix must end with a trailing platform-specific path separator (require('path').sep). \/\/ The parent directory for the new temporary directory const tmpDir = os.tmpdir();  \/\/ This method is *INCORRECT*: fs.mkdtemp(tmpDir, (err, directory) => {   if (err) throw err;   console.log(directory);   \/\/ Will print something similar to `\/tmpabc123`.   \/\/ A new temporary directory is created at the file system root   \/\/ rather than *within* the \/tmp directory. });  \/\/ This method is *CORRECT*: const { sep } = require('path'); fs.mkdtemp(`${tmpDir}${sep}`, (err, directory) => {   if (err) throw err;   console.log(directory);   \/\/ Will print something similar to `\/tmp\/abc123`.   \/\/ A new temporary directory is created within   \/\/ the \/tmp directory. });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_mkdtempsync_prefix_options","title":"`fs.mkdtempSync(prefix[, options])`","description":"Returns the created directory path. For detailed information, see the documentation of the asynchronous version of this API: fs.mkdtemp(). The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_open_path_flags_mode_callback","title":"`fs.open(path[, flags[, mode]], callback)`","description":"Asynchronous file open. See open(2). mode sets the file mode (permission and sticky bits), but only if the file was created. On Windows, only the write permission can be manipulated; see fs.chmod(). The callback gets two arguments (err, fd). Some characters (< > : \" \/ \\ | ? *) are reserved under Windows as documented by Naming Files, Paths, and Namespaces. Under NTFS, if the filename contains a colon, Node.js will open a file system stream, as described by this MSDN page. Functions based on fs.open() exhibit this behavior as well: fs.writeFile(), fs.readFile(), etc."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_opendir_path_options_callback","title":"`fs.opendir(path[, options], callback)`","description":"Asynchronously open a directory. See opendir(3). Creates an fs.Dir, which contains all further functions for reading from and cleaning up the directory. The encoding option sets the encoding for the path while opening the directory and subsequent read operations."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_opendirsync_path_options","title":"`fs.opendirSync(path[, options])`","description":"Synchronously open a directory. See opendir(3). Creates an fs.Dir, which contains all further functions for reading from and cleaning up the directory. The encoding option sets the encoding for the path while opening the directory and subsequent read operations."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_opensync_path_flags_mode","title":"`fs.openSync(path[, flags, mode])`","description":"Returns an integer representing the file descriptor. For detailed information, see the documentation of the asynchronous version of this API: fs.open()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_read_fd_buffer_offset_length_position_callback","title":"`fs.read(fd, buffer, offset, length, position, callback)`","description":"Read data from the file specified by fd. buffer is the buffer that the data (read from the fd) will be written to. offset is the offset in the buffer to start writing at. length is an integer specifying the number of bytes to read. position is an argument specifying where to begin reading from in the file. If position is null, data will be read from the current file position, and the file position will be updated. If position is an integer, the file position will remain unchanged. The callback is given the three arguments, (err, bytesRead, buffer). If the file is not modified concurrently, the end-of-file is reached when the number of bytes read is zero. If this method is invoked as its util.promisify()ed version, it returns a Promise for an Object with bytesRead and buffer properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_read_fd_options_callback","title":"`fs.read(fd, [options,] callback)`","description":"Similar to the above fs.read function, this version takes an optional options object. If no options object is specified, it will default with the above values."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readdir_path_options_callback","title":"`fs.readdir(path[, options], callback)`","description":"Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the filenames passed to the callback. If the encoding is set to 'buffer', the filenames returned will be passed as Buffer objects. If options.withFileTypes is set to true, the files array will contain fs.Dirent objects."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readdirsync_path_options","title":"`fs.readdirSync(path[, options])`","description":"Synchronous readdir(3). The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the filenames returned. If the encoding is set to 'buffer', the filenames returned will be passed as Buffer objects. If options.withFileTypes is set to true, the result will contain fs.Dirent objects."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readfile_path_options_callback","title":"`fs.readFile(path[, options], callback)`","description":"Asynchronously reads the entire contents of a file. fs.readFile('\/etc\/passwd', (err, data) => {   if (err) throw err;   console.log(data); });  The callback is passed two arguments (err, data), where data is the contents of the file. If no encoding is specified, then the raw buffer is returned. If options is a string, then it specifies the encoding: fs.readFile('\/etc\/passwd', 'utf8', callback);  When the path is a directory, the behavior of fs.readFile() and fs.readFileSync() is platform-specific. On macOS, Linux, and Windows, an error will be returned. On FreeBSD, a representation of the directory's contents will be returned. \/\/ macOS, Linux, and Windows fs.readFile('<directory>', (err, data) => {   \/\/ => [Error: EISDIR: illegal operation on a directory, read <directory>] });  \/\/  FreeBSD fs.readFile('<directory>', (err, data) => {   \/\/ => null, <data> });  It is possible to abort an ongoing request using an AbortSignal. If a request is aborted the callback is called with an AbortError: const controller = new AbortController(); const signal = controller.signal; fs.readFile(fileInfo[0].name, { signal }, (err, buf) => {   \/\/ ... }); \/\/ When you want to abort the request controller.abort();  The fs.readFile() function buffers the entire file. To minimize memory costs, when possible prefer streaming via fs.createReadStream(). Aborting an ongoing request does not abort individual operating system requests but rather the internal buffering fs.readFile performs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_descriptors","title":"File descriptors","description":"Any specified file descriptor has to support reading. If a file descriptor is specified as the path, it will not be closed automatically. The reading will begin at the current position. For example, if the file already had 'Hello World' and six bytes are read with the file descriptor, the call to fs.readFile() with the same file descriptor, would give 'World', rather than 'Hello World'."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readfilesync_path_options","title":"`fs.readFileSync(path[, options])`","description":"Returns the contents of the path. For detailed information, see the documentation of the asynchronous version of this API: fs.readFile(). If the encoding option is specified then this function returns a string. Otherwise it returns a buffer. Similar to fs.readFile(), when the path is a directory, the behavior of fs.readFileSync() is platform-specific. \/\/ macOS, Linux, and Windows fs.readFileSync('<directory>'); \/\/ => [Error: EISDIR: illegal operation on a directory, read <directory>]  \/\/  FreeBSD fs.readFileSync('<directory>'); \/\/ => <data>"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readlink_path_options_callback","title":"`fs.readlink(path[, options], callback)`","description":"Asynchronous readlink(2). The callback gets two arguments (err, linkString). The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the link path passed to the callback. If the encoding is set to 'buffer', the link path returned will be passed as a Buffer object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readlinksync_path_options","title":"`fs.readlinkSync(path[, options])`","description":"Synchronous readlink(2). Returns the symbolic link's string value. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the link path returned. If the encoding is set to 'buffer', the link path returned will be passed as a Buffer object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readsync_fd_buffer_offset_length_position","title":"`fs.readSync(fd, buffer, offset, length, position)`","description":"Returns the number of bytesRead. For detailed information, see the documentation of the asynchronous version of this API: fs.read()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readsync_fd_buffer_options","title":"`fs.readSync(fd, buffer, [options])`","description":"Returns the number of bytesRead. Similar to the above fs.readSync function, this version takes an optional options object. If no options object is specified, it will default with the above values. For detailed information, see the documentation of the asynchronous version of this API: fs.read()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readv_fd_buffers_position_callback","title":"`fs.readv(fd, buffers[, position], callback)`","description":"Read from a file specified by fd and write to an array of ArrayBufferViews using readv(). position is the offset from the beginning of the file from where data should be read. If typeof position !== 'number', the data will be read from the current position. The callback will be given three arguments: err, bytesRead, and buffers. bytesRead is how many bytes were read from the file. If this method is invoked as its util.promisify()ed version, it returns a Promise for an Object with bytesRead and buffers properties."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_readvsync_fd_buffers_position","title":"`fs.readvSync(fd, buffers[, position])`","description":"For detailed information, see the documentation of the asynchronous version of this API: fs.readv()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_realpath_path_options_callback","title":"`fs.realpath(path[, options], callback)`","description":"Asynchronously computes the canonical pathname by resolving ., .. and symbolic links. A canonical pathname is not necessarily unique. Hard links and bind mounts can expose a file system entity through many pathnames. This function behaves like realpath(3), with some exceptions:   No case conversion is performed on case-insensitive file systems.   The maximum number of symbolic links is platform-independent and generally (much) higher than what the native realpath(3) implementation supports.   The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. Only paths that can be converted to UTF8 strings are supported. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the path passed to the callback. If the encoding is set to 'buffer', the path returned will be passed as a Buffer object. If path resolves to a socket or a pipe, the function will return a system dependent name for that object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_realpath_native_path_options_callback","title":"`fs.realpath.native(path[, options], callback)`","description":"Asynchronous realpath(3). The callback gets two arguments (err, resolvedPath). Only paths that can be converted to UTF8 strings are supported. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the path passed to the callback. If the encoding is set to 'buffer', the path returned will be passed as a Buffer object. On Linux, when Node.js is linked against musl libc, the procfs file system must be mounted on \/proc in order for this function to work. Glibc does not have this restriction."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_realpathsync_path_options","title":"`fs.realpathSync(path[, options])`","description":"Returns the resolved pathname. For detailed information, see the documentation of the asynchronous version of this API: fs.realpath()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_realpathsync_native_path_options","title":"`fs.realpathSync.native(path[, options])`","description":"Synchronous realpath(3). Only paths that can be converted to UTF8 strings are supported. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the path returned. If the encoding is set to 'buffer', the path returned will be passed as a Buffer object. On Linux, when Node.js is linked against musl libc, the procfs file system must be mounted on \/proc in order for this function to work. Glibc does not have this restriction."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rename_oldpath_newpath_callback","title":"`fs.rename(oldPath, newPath, callback)`","description":"Asynchronously rename file at oldPath to the pathname provided as newPath. In the case that newPath already exists, it will be overwritten. If there is a directory at newPath, an error will be raised instead. No arguments other than a possible exception are given to the completion callback. See also: rename(2). fs.rename('oldFile.txt', 'newFile.txt', (err) => {   if (err) throw err;   console.log('Rename complete!'); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_renamesync_oldpath_newpath","title":"`fs.renameSync(oldPath, newPath)`","description":"Synchronous rename(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rmdir_path_options_callback","title":"`fs.rmdir(path[, options], callback)`","description":"Asynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback. Using fs.rmdir() on a file (not a directory) results in an ENOENT error on Windows and an ENOTDIR error on POSIX. Setting recursive to true results in behavior similar to the Unix command rm -rf: an error will not be raised for paths that do not exist, and paths that represent files will be deleted. The permissive behavior of the recursive option is deprecated, ENOTDIR and ENOENT will be thrown in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rmdirsync_path_options","title":"`fs.rmdirSync(path[, options])`","description":"Synchronous rmdir(2). Returns undefined. Using fs.rmdirSync() on a file (not a directory) results in an ENOENT error on Windows and an ENOTDIR error on POSIX. Setting recursive to true results in behavior similar to the Unix command rm -rf: an error will not be raised for paths that do not exist, and paths that represent files will be deleted. The permissive behavior of the recursive option is deprecated, ENOTDIR and ENOENT will be thrown in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rm_path_options_callback","title":"`fs.rm(path[, options], callback)`","description":"Asynchronously removes files and directories (modeled on the standard POSIX rm utility). No arguments other than a possible exception are given to the completion callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_rmsync_path_options","title":"`fs.rmSync(path[, options])`","description":"Synchronously removes files and directories (modeled on the standard POSIX rm utility). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_stat_path_options_callback","title":"`fs.stat(path[, options], callback)`","description":"Asynchronous stat(2). The callback gets two arguments (err, stats) where stats is an fs.Stats object. In case of an error, the err.code will be one of Common System Errors. Using fs.stat() to check for the existence of a file before calling fs.open(), fs.readFile() or fs.writeFile() is not recommended. Instead, user code should open\/read\/write the file directly and handle the error raised if the file is not available. To check if a file exists without manipulating it afterwards, fs.access() is recommended. For example, given the following directory structure: - txtDir -- file.txt - app.js  The next program will check for the stats of the given paths: const fs = require('fs');  const pathsToCheck = ['.\/txtDir', '.\/txtDir\/file.txt'];  for (let i = 0; i < pathsToCheck.length; i++) {   fs.stat(pathsToCheck[i], function(err, stats) {     console.log(stats.isDirectory());     console.log(stats);   }); }  The resulting output will resemble: true Stats {   dev: 16777220,   mode: 16877,   nlink: 3,   uid: 501,   gid: 20,   rdev: 0,   blksize: 4096,   ino: 14214262,   size: 96,   blocks: 0,   atimeMs: 1561174653071.963,   mtimeMs: 1561174614583.3518,   ctimeMs: 1561174626623.5366,   birthtimeMs: 1561174126937.2893,   atime: 2019-06-22T03:37:33.072Z,   mtime: 2019-06-22T03:36:54.583Z,   ctime: 2019-06-22T03:37:06.624Z,   birthtime: 2019-06-22T03:28:46.937Z } false Stats {   dev: 16777220,   mode: 33188,   nlink: 1,   uid: 501,   gid: 20,   rdev: 0,   blksize: 4096,   ino: 14214074,   size: 8,   blocks: 8,   atimeMs: 1561174616618.8555,   mtimeMs: 1561174614584,   ctimeMs: 1561174614583.8145,   birthtimeMs: 1561174007710.7478,   atime: 2019-06-22T03:36:56.619Z,   mtime: 2019-06-22T03:36:54.584Z,   ctime: 2019-06-22T03:36:54.584Z,   birthtime: 2019-06-22T03:26:47.711Z }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_statsync_path_options","title":"`fs.statSync(path[, options])`","description":"Synchronous stat(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_symlink_target_path_type_callback","title":"`fs.symlink(target, path[, type], callback)`","description":"Asynchronous symlink(2) which creates the link called path pointing to target. No arguments other than a possible exception are given to the completion callback. The type argument is only available on Windows and ignored on other platforms. It can be set to 'dir', 'file', or 'junction'. If the type argument is not set, Node.js will autodetect target type and use 'file' or 'dir'. If the target does not exist, 'file' will be used. Windows junction points require the destination path to be absolute. When using 'junction', the target argument will automatically be normalized to absolute path. Relative targets are relative to the link\u2019s parent directory. fs.symlink('.\/mew', '.\/example\/mewtwo', callback);  The above example creates a symbolic link mewtwo in the example which points to mew in the same directory: $ tree example\/ example\/ \u251c\u2500\u2500 mew \u2514\u2500\u2500 mewtwo -> .\/mew"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_symlinksync_target_path_type","title":"`fs.symlinkSync(target, path[, type])`","description":"Returns undefined. For detailed information, see the documentation of the asynchronous version of this API: fs.symlink()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_truncate_path_len_callback","title":"`fs.truncate(path[, len], callback)`","description":"Asynchronous truncate(2). No arguments other than a possible exception are given to the completion callback. A file descriptor can also be passed as the first argument. In this case, fs.ftruncate() is called. Passing a file descriptor is deprecated and may result in an error being thrown in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_truncatesync_path_len","title":"`fs.truncateSync(path[, len])`","description":"Synchronous truncate(2). Returns undefined. A file descriptor can also be passed as the first argument. In this case, fs.ftruncateSync() is called. Passing a file descriptor is deprecated and may result in an error being thrown in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_unlink_path_callback","title":"`fs.unlink(path, callback)`","description":"Asynchronously removes a file or symbolic link. No arguments other than a possible exception are given to the completion callback. \/\/ Assuming that 'path\/file.txt' is a regular file. fs.unlink('path\/file.txt', (err) => {   if (err) throw err;   console.log('path\/file.txt was deleted'); });  fs.unlink() will not work on a directory, empty or otherwise. To remove a directory, use fs.rmdir(). See also: unlink(2)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_unlinksync_path","title":"`fs.unlinkSync(path)`","description":"Synchronous unlink(2). Returns undefined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_unwatchfile_filename_listener","title":"`fs.unwatchFile(filename[, listener])`","description":"Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed, effectively stopping watching of filename. Calling fs.unwatchFile() with a filename that is not being watched is a no-op, not an error. Using fs.watch() is more efficient than fs.watchFile() and fs.unwatchFile(). fs.watch() should be used instead of fs.watchFile() and fs.unwatchFile() when possible."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_utimes_path_atime_mtime_callback","title":"`fs.utimes(path, atime, mtime, callback)`","description":"Change the file system timestamps of the object referenced by path. The atime and mtime arguments follow these rules:  Values can be either numbers representing Unix epoch time in seconds, Dates, or a numeric string like '123456789.0'. If the value can not be converted to a number, or is NaN, Infinity or -Infinity, an Error will be thrown."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_utimessync_path_atime_mtime","title":"`fs.utimesSync(path, atime, mtime)`","description":"Returns undefined. For detailed information, see the documentation of the asynchronous version of this API: fs.utimes()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_watch_filename_options_listener","title":"`fs.watch(filename[, options][, listener])`","description":"Watch for changes on filename, where filename is either a file or a directory. The second argument is optional. If options is provided as a string, it specifies the encoding. Otherwise options should be passed as an object. The listener callback gets two arguments (eventType, filename). eventType is either 'rename' or 'change', and filename is the name of the file which triggered the event. On most platforms, 'rename' is emitted whenever a filename appears or disappears in the directory. The listener callback is attached to the 'change' event fired by fs.FSWatcher, but it is not the same thing as the 'change' value of eventType."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_caveats","title":"Caveats","description":"The fs.watch API is not 100% consistent across platforms, and is unavailable in some situations. The recursive option is only supported on macOS and Windows. An ERR_FEATURE_UNAVAILABLE_ON_PLATFORM exception will be thrown when the option is used on a platform that does not support it. On Windows, no events will be emitted if the watched directory is moved or renamed. An EPERM error is reported when the watched directory is deleted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_availability","title":"Availability","description":"This feature depends on the underlying operating system providing a way to be notified of filesystem changes.  On Linux systems, this uses inotify(7). On BSD systems, this uses kqueue(2). On macOS, this uses kqueue(2) for files and FSEvents for directories. On SunOS systems (including Solaris and SmartOS), this uses event ports. On Windows systems, this feature depends on ReadDirectoryChangesW. On Aix systems, this feature depends on AHAFS, which must be enabled. On IBM i systems, this feature is not supported.  If the underlying functionality is not available for some reason, then fs.watch() will not be able to function and may thrown an exception. For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc) or host file systems when using virtualization software such as Vagrant or Docker. It is still possible to use fs.watchFile(), which uses stat polling, but this method is slower and less reliable."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inodes","title":"Inodes","description":"On Linux and macOS systems, fs.watch() resolves the path to an inode and watches the inode. If the watched path is deleted and recreated, it is assigned a new inode. The watch will emit an event for the delete but will continue watching the original inode. Events for the new inode will not be emitted. This is expected behavior. AIX files retain the same inode for the lifetime of a file. Saving and closing a watched file on AIX will result in two notifications (one for adding new content, and one for truncation)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_filename_argument","title":"Filename argument","description":"Providing filename argument in the callback is only supported on Linux, macOS, Windows, and AIX. Even on supported platforms, filename is not always guaranteed to be provided. Therefore, don't assume that filename argument is always provided in the callback, and have some fallback logic if it is null. fs.watch('somedir', (eventType, filename) => {   console.log(`event type is: ${eventType}`);   if (filename) {     console.log(`filename provided: ${filename}`);   } else {     console.log('filename not provided');   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_watchfile_filename_options_listener","title":"`fs.watchFile(filename[, options], listener)`","description":"Watch for changes on filename. The callback listener will be called each time the file is accessed. The options argument may be omitted. If provided, it should be an object. The options object may contain a boolean named persistent that indicates whether the process should continue to run as long as files are being watched. The options object may specify an interval property indicating how often the target should be polled in milliseconds. The listener gets two arguments the current stat object and the previous stat object: fs.watchFile('message.text', (curr, prev) => {   console.log(`the current mtime is: ${curr.mtime}`);   console.log(`the previous mtime was: ${prev.mtime}`); });  These stat objects are instances of fs.Stat. If the bigint option is true, the numeric values in these objects are specified as BigInts. To be notified when the file was modified, not just accessed, it is necessary to compare curr.mtime and prev.mtime. When an fs.watchFile operation results in an ENOENT error, it will invoke the listener once, with all the fields zeroed (or, for dates, the Unix Epoch). If the file is created later on, the listener will be called again, with the latest stat objects. This is a change in functionality since v0.10. Using fs.watch() is more efficient than fs.watchFile and fs.unwatchFile. fs.watch should be used instead of fs.watchFile and fs.unwatchFile when possible. When a file being watched by fs.watchFile() disappears and reappears, then the contents of previous in the second callback event (the file's reappearance) will be the same as the contents of previous in the first callback event (its disappearance). This happens when:  the file is deleted, followed by a restore the file is renamed and then renamed a second time back to its original name"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_write_fd_buffer_offset_length_position_callback","title":"`fs.write(fd, buffer[, offset[, length[, position]]], callback)`","description":"Write buffer to the file specified by fd. If buffer is a normal object, it must have an own toString function property. offset determines the part of the buffer to be written, and length is an integer specifying the number of bytes to write. position refers to the offset from the beginning of the file where this data should be written. If typeof position !== 'number', the data will be written at the current position. See pwrite(2). The callback will be given three arguments (err, bytesWritten, buffer) where bytesWritten specifies how many bytes were written from buffer. If this method is invoked as its util.promisify()ed version, it returns a Promise for an Object with bytesWritten and buffer properties. It is unsafe to use fs.write() multiple times on the same file without waiting for the callback. For this scenario, fs.createWriteStream() is recommended. On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_write_fd_string_position_encoding_callback","title":"`fs.write(fd, string[, position[, encoding]], callback)`","description":"Write string to the file specified by fd. If string is not a string, or an object with an own toString function property, then an exception is thrown. position refers to the offset from the beginning of the file where this data should be written. If typeof position !== 'number' the data will be written at the current position. See pwrite(2). encoding is the expected string encoding. The callback will receive the arguments (err, written, string) where written specifies how many bytes the passed string required to be written. Bytes written is not necessarily the same as string characters written. See Buffer.byteLength. It is unsafe to use fs.write() multiple times on the same file without waiting for the callback. For this scenario, fs.createWriteStream() is recommended. On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file. On Windows, if the file descriptor is connected to the console (e.g. fd == 1 or stdout) a string containing non-ASCII characters will not be rendered properly by default, regardless of the encoding used. It is possible to configure the console to render UTF-8 properly by changing the active codepage with the chcp 65001 command. See the chcp docs for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writefile_file_data_options_callback","title":"`fs.writeFile(file, data[, options], callback)`","description":"When file is a filename, asynchronously writes data to the file, replacing the file if it already exists. data can be a string or a buffer. When file is a file descriptor, the behavior is similar to calling fs.write() directly (which is recommended). See the notes below on using a file descriptor. The encoding option is ignored if data is a buffer. If data is a normal object, it must have an own toString function property. const data = new Uint8Array(Buffer.from('Hello Node.js')); fs.writeFile('message.txt', data, (err) => {   if (err) throw err;   console.log('The file has been saved!'); });  If options is a string, then it specifies the encoding: fs.writeFile('message.txt', 'Hello Node.js', 'utf8', callback);  It is unsafe to use fs.writeFile() multiple times on the same file without waiting for the callback. For this scenario, fs.createWriteStream() is recommended. Similarly to fs.readFile - fs.writeFile is a convenience method that performs multiple write calls internally to write the buffer passed to it. For performance sensitive code consider using fs.createWriteStream(). It is possible to use an <AbortSignal> to cancel an fs.writeFile(). Cancelation is \"best effort\", and some amount of data is likely still to be written. const controller = new AbortController(); const { signal } = controller; const data = new Uint8Array(Buffer.from('Hello Node.js')); fs.writeFile('message.txt', data, { signal }, (err) => {   \/\/ When a request is aborted - the callback is called with an AbortError }); \/\/ When the request should be aborted controller.abort();  Aborting an ongoing request does not abort individual operating system requests but rather the internal buffering fs.writeFile performs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_using_fs_writefile_with_file_descriptors","title":"Using `fs.writeFile()` with file descriptors","description":"When file is a file descriptor, the behavior is almost identical to directly calling fs.write() like: fs.write(fd, Buffer.from(data, options.encoding), callback);  The difference from directly calling fs.write() is that under some unusual conditions, fs.write() might write only part of the buffer and need to be retried to write the remaining data, whereas fs.writeFile() retries until the data is entirely written (or an error occurs). The implications of this are a common source of confusion. In the file descriptor case, the file is not replaced! The data is not necessarily written to the beginning of the file, and the file's original data may remain before and\/or after the newly written data. For example, if fs.writeFile() is called twice in a row, first to write the string 'Hello', then to write the string ', World', the file would contain 'Hello, World', and might contain some of the file's original data (depending on the size of the original file, and the position of the file descriptor). If a file name had been used instead of a descriptor, the file would be guaranteed to contain only ', World'."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writefilesync_file_data_options","title":"`fs.writeFileSync(file, data[, options])`","description":"Returns undefined. For detailed information, see the documentation of the asynchronous version of this API: fs.writeFile()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writesync_fd_buffer_offset_length_position","title":"`fs.writeSync(fd, buffer[, offset[, length[, position]]])`","description":"For detailed information, see the documentation of the asynchronous version of this API: fs.write(fd, buffer...)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writesync_fd_string_position_encoding","title":"`fs.writeSync(fd, string[, position[, encoding]])`","description":"For detailed information, see the documentation of the asynchronous version of this API: fs.write(fd, string...)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writev_fd_buffers_position_callback","title":"`fs.writev(fd, buffers[, position], callback)`","description":"Write an array of ArrayBufferViews to the file specified by fd using writev(). position is the offset from the beginning of the file where this data should be written. If typeof position !== 'number', the data will be written at the current position. The callback will be given three arguments: err, bytesWritten, and buffers. bytesWritten is how many bytes were written from buffers. If this method is util.promisify()ed, it returns a Promise for an Object with bytesWritten and buffers properties. It is unsafe to use fs.writev() multiple times on the same file without waiting for the callback. For this scenario, use fs.createWriteStream(). On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_writevsync_fd_buffers_position","title":"`fs.writevSync(fd, buffers[, position])`","description":"For detailed information, see the documentation of the asynchronous version of this API: fs.writev()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_synchronous_example","title":"Synchronous example","description":"The synchronous form blocks the Node.js event loop and further JavaScript execution until the operation is complete. Exceptions are thrown immediately and can be handled using try\u2026catch, or can be allowed to bubble up. const fs = require('fs');  try {   fs.unlinkSync('\/tmp\/hello');   console.log('successfully deleted \/tmp\/hello'); } catch (err) {   \/\/ handle the error }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_callback_example","title":"Callback example","description":"The callback form takes a completion callback function as its last argument and invokes the operation asynchronously. The arguments passed to the completion callback depend on the method, but the first argument is always reserved for an exception. If the operation is completed successfully, then the first argument is null or undefined. const fs = require('fs');  fs.unlink('\/tmp\/hello', (err) => {   if (err) throw err;   console.log('successfully deleted \/tmp\/hello'); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_promise_example","title":"Promise example","description":"Promise-based operations return a Promise that is resolved when the asynchronous operation is complete. const fs = require('fs\/promises');  (async function(path) {   try {     await fs.unlink(path);     console.log(`successfully deleted ${path}`);   } catch (error) {     console.error('there was an error:', error.message);   } })('\/tmp\/hello');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_ordering_of_callback_and_promise_based_operations","title":"Ordering of callback and promise-based operations","description":"There is no guaranteed ordering when using either the callback or promise-based methods. For example, the following is prone to error because the fs.stat() operation might complete before the fs.rename() operation: fs.rename('\/tmp\/hello', '\/tmp\/world', (err) => {   if (err) throw err;   console.log('renamed complete'); }); fs.stat('\/tmp\/world', (err, stats) => {   if (err) throw err;   console.log(`stats: ${JSON.stringify(stats)}`); });  To correctly order the operations, move the fs.stat() call into the callback of the fs.rename() operation: fs.rename('\/tmp\/hello', '\/tmp\/world', (err) => {   if (err) throw err;   fs.stat('\/tmp\/world', (err, stats) => {     if (err) throw err;     console.log(`stats: ${JSON.stringify(stats)}`);   }); });  Or, use the promise-based API: const fs = require('fs\/promises');  (async function(from, to) {   try {     await fs.rename(from, to);     const stats = await fs.stat(to);     console.log(`stats: ${JSON.stringify(stats)}`);   } catch (error) {     console.error('there was an error:', error.message);   } })('\/tmp\/hello', '\/tmp\/world');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_paths","title":"File paths","description":"Most fs operations accept filepaths that may be specified in the form of a string, a Buffer, or a URL object using the file: protocol. String form paths are interpreted as UTF-8 character sequences identifying the absolute or relative filename. Relative paths will be resolved relative to the current working directory as determined by calling process.cwd(). Example using an absolute path on POSIX: const fs = require('fs');  fs.open('\/open\/some\/file.txt', 'r', (err, fd) => {   if (err) throw err;   fs.close(fd, (err) => {     if (err) throw err;   }); });  Example using a relative path on POSIX (relative to process.cwd()): fs.open('file.txt', 'r', (err, fd) => {   if (err) throw err;   fs.close(fd, (err) => {     if (err) throw err;   }); });  Paths specified using a Buffer are useful primarily on certain POSIX operating systems that treat file paths as opaque byte sequences. On such systems, it is possible for a single file path to contain sub-sequences that use multiple character encodings. As with string paths, Buffer paths may be relative or absolute: Example using an absolute path on POSIX: fs.open(Buffer.from('\/open\/some\/file.txt'), 'r', (err, fd) => {   if (err) throw err;   fs.close(fd, (err) => {     if (err) throw err;   }); });  On Windows, Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example fs.readdirSync('C:\\\\') can potentially return a different result than fs.readdirSync('C:'). For more information, see this MSDN page."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_object_support","title":"URL object support","description":"For most fs module functions, the path or filename argument may be passed as a WHATWG URL object. Only URL objects using the file: protocol are supported. const fs = require('fs'); const fileUrl = new URL('file:\/\/\/tmp\/hello');  fs.readFileSync(fileUrl);  file: URLs are always absolute paths. Using WHATWG URL objects might introduce platform-specific behaviors. On Windows, file: URLs with a host name convert to UNC paths, while file: URLs with drive letters convert to local absolute paths. file: URLs without a host name nor a drive letter will result in a throw: \/\/ On Windows :  \/\/ - WHATWG file URLs with hostname convert to UNC path \/\/ file:\/\/hostname\/p\/a\/t\/h\/file => \\\\hostname\\p\\a\\t\\h\\file fs.readFileSync(new URL('file:\/\/hostname\/p\/a\/t\/h\/file'));  \/\/ - WHATWG file URLs with drive letters convert to absolute path \/\/ file:\/\/\/C:\/tmp\/hello => C:\\tmp\\hello fs.readFileSync(new URL('file:\/\/\/C:\/tmp\/hello'));  \/\/ - WHATWG file URLs without hostname must have a drive letters fs.readFileSync(new URL('file:\/\/\/notdriveletter\/p\/a\/t\/h\/file')); fs.readFileSync(new URL('file:\/\/\/c\/p\/a\/t\/h\/file')); \/\/ TypeError [ERR_INVALID_FILE_URL_PATH]: File URL path must be absolute  file: URLs with drive letters must use : as a separator just after the drive letter. Using another separator will result in a throw. On all other platforms, file: URLs with a host name are unsupported and will result in a throw: \/\/ On other platforms:  \/\/ - WHATWG file URLs with hostname are unsupported \/\/ file:\/\/hostname\/p\/a\/t\/h\/file => throw! fs.readFileSync(new URL('file:\/\/hostname\/p\/a\/t\/h\/file')); \/\/ TypeError [ERR_INVALID_FILE_URL_PATH]: must be absolute  \/\/ - WHATWG file URLs convert to absolute path \/\/ file:\/\/\/tmp\/hello => \/tmp\/hello fs.readFileSync(new URL('file:\/\/\/tmp\/hello'));  A file: URL having encoded slash characters will result in a throw on all platforms: \/\/ On Windows fs.readFileSync(new URL('file:\/\/\/C:\/p\/a\/t\/h\/%2F')); fs.readFileSync(new URL('file:\/\/\/C:\/p\/a\/t\/h\/%2f')); \/* TypeError [ERR_INVALID_FILE_URL_PATH]: File URL path must not include encoded \\ or \/ characters *\/  \/\/ On POSIX fs.readFileSync(new URL('file:\/\/\/p\/a\/t\/h\/%2F')); fs.readFileSync(new URL('file:\/\/\/p\/a\/t\/h\/%2f')); \/* TypeError [ERR_INVALID_FILE_URL_PATH]: File URL path must not include encoded \/ characters *\/  On Windows, file: URLs having encoded backslash will result in a throw: \/\/ On Windows fs.readFileSync(new URL('file:\/\/\/C:\/path\/%5C')); fs.readFileSync(new URL('file:\/\/\/C:\/path\/%5c')); \/* TypeError [ERR_INVALID_FILE_URL_PATH]: File URL path must not include encoded \\ or \/ characters *\/"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_descriptors","title":"File descriptors","description":"On POSIX systems, for every process, the kernel maintains a table of currently open files and resources. Each open file is assigned a simple numeric identifier called a file descriptor. At the system-level, all file system operations use these file descriptors to identify and track each specific file. Windows systems use a different but conceptually similar mechanism for tracking resources. To simplify things for users, Node.js abstracts away the specific differences between operating systems and assigns all open files a numeric file descriptor. The fs.open() method is used to allocate a new file descriptor. Once allocated, the file descriptor may be used to read data from, write data to, or request information about the file. fs.open('\/open\/some\/file.txt', 'r', (err, fd) => {   if (err) throw err;   fs.fstat(fd, (err, stat) => {     if (err) throw err;     \/\/ use stat      \/\/ always close the file descriptor!     fs.close(fd, (err) => {       if (err) throw err;     });   }); });  Most operating systems limit the number of file descriptors that may be open at any given time so it is critical to close the descriptor when operations are completed. Failure to do so will result in a memory leak that will eventually cause an application to crash."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_threadpool_usage","title":"Threadpool usage","description":"All file system APIs except fs.FSWatcher() and those that are explicitly synchronous use libuv's threadpool, which can have surprising and negative performance implications for some applications. See the UV_THREADPOOL_SIZE documentation for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_promises_api","title":"`fs` Promises API","description":"The fs.promises API provides an alternative set of asynchronous file system methods that return Promise objects rather than using callbacks. The API is accessible via require('fs').promises or require('fs\/promises')."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_access_path_mode","title":"`fsPromises.access(path[, mode])`","description":"Tests a user's permissions for the file or directory specified by path. The mode argument is an optional integer that specifies the accessibility checks to be performed. Check File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK). If the accessibility check is successful, the Promise is resolved with no value. If any of the accessibility checks fail, the Promise is rejected with an Error object. The following example checks if the file \/etc\/passwd can be read and written by the current process. const fs = require('fs'); const fsPromises = fs.promises;  fsPromises.access('\/etc\/passwd', fs.constants.R_OK | fs.constants.W_OK)   .then(() => console.log('can access'))   .catch(() => console.error('cannot access'));  Using fsPromises.access() to check for the accessibility of a file before calling fsPromises.open() is not recommended. Doing so introduces a race condition, since other processes may change the file's state between the two calls. Instead, user code should open\/read\/write the file directly and handle the error raised if the file is not accessible."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_appendfile_path_data_options","title":"`fsPromises.appendFile(path, data[, options])`","description":"Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer. The Promise will be resolved with no arguments upon success. If options is a string, then it specifies the encoding. The path may be specified as a FileHandle that has been opened for appending (using fsPromises.open())."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_chmod_path_mode","title":"`fsPromises.chmod(path, mode)`","description":"Changes the permissions of a file then resolves the Promise with no arguments upon succces."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_chown_path_uid_gid","title":"`fsPromises.chown(path, uid, gid)`","description":"Changes the ownership of a file then resolves the Promise with no arguments upon success."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_copyfile_src_dest_mode","title":"`fsPromises.copyFile(src, dest[, mode])`","description":"Asynchronously copies src to dest. By default, dest is overwritten if it already exists. The Promise will be resolved with no arguments upon success. Node.js makes no guarantees about the atomicity of the copy operation. If an error occurs after the destination file has been opened for writing, Node.js will attempt to remove the destination. mode is an optional integer that specifies the behavior of the copy operation. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE).  fs.constants.COPYFILE_EXCL: The copy operation will fail if dest already exists. fs.constants.COPYFILE_FICLONE: The copy operation will attempt to create a copy-on-write reflink. If the platform does not support copy-on-write, then a fallback copy mechanism is used. fs.constants.COPYFILE_FICLONE_FORCE: The copy operation will attempt to create a copy-on-write reflink. If the platform does not support copy-on-write, then the operation will fail.  const {   promises: fsPromises,   constants: {     COPYFILE_EXCL   } } = require('fs');  \/\/ destination.txt will be created or overwritten by default. fsPromises.copyFile('source.txt', 'destination.txt')   .then(() => console.log('source.txt was copied to destination.txt'))   .catch(() => console.log('The file could not be copied'));  \/\/ By using COPYFILE_EXCL, the operation will fail if destination.txt exists. fsPromises.copyFile('source.txt', 'destination.txt', COPYFILE_EXCL)   .then(() => console.log('source.txt was copied to destination.txt'))   .catch(() => console.log('The file could not be copied'));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_lchmod_path_mode","title":"`fsPromises.lchmod(path, mode)`","description":"Changes the permissions on a symbolic link then resolves the Promise with no arguments upon success. This method is only implemented on macOS."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_lchown_path_uid_gid","title":"`fsPromises.lchown(path, uid, gid)`","description":"Changes the ownership on a symbolic link then resolves the Promise with no arguments upon success."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_lutimes_path_atime_mtime","title":"`fsPromises.lutimes(path, atime, mtime)`","description":"Changes the access and modification times of a file in the same way as fsPromises.utimes(), with the difference that if the path refers to a symbolic link, then the link is not dereferenced: instead, the timestamps of the symbolic link itself are changed. Upon success, the Promise is resolved without arguments."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_link_existingpath_newpath","title":"`fsPromises.link(existingPath, newPath)`","description":"Asynchronous link(2). The Promise is resolved with no arguments upon success."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_lstat_path_options","title":"`fsPromises.lstat(path[, options])`","description":"Asynchronous lstat(2). The Promise is resolved with the fs.Stats object for the given symbolic link path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_mkdir_path_options","title":"`fsPromises.mkdir(path[, options])`","description":"Asynchronously creates a directory then resolves the Promise with either no arguments, or the first directory path created if recursive is true. The optional options argument can be an integer specifying mode (permission and sticky bits), or an object with a mode property and a recursive property indicating whether parent directories should be created. Calling fsPromises.mkdir() when path is a directory that exists results in a rejection only when recursive is false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_mkdtemp_prefix_options","title":"`fsPromises.mkdtemp(prefix[, options])`","description":"Creates a unique temporary directory and resolves the Promise with the created directory path. A unique directory name is generated by appending six random characters to the end of the provided prefix. Due to platform inconsistencies, avoid trailing X characters in prefix. Some platforms, notably the BSDs, can return more than six random characters, and replace trailing X characters in prefix with random characters. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use. fsPromises.mkdtemp(path.join(os.tmpdir(), 'foo-'))   .catch(console.error);  The fsPromises.mkdtemp() method will append the six randomly selected characters directly to the prefix string. For instance, given a directory \/tmp, if the intention is to create a temporary directory within \/tmp, the prefix must end with a trailing platform-specific path separator (require('path').sep)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_open_path_flags_mode","title":"`fsPromises.open(path, flags[, mode])`","description":"Asynchronous file open that returns a Promise that, when resolved, yields a FileHandle object. See open(2). mode sets the file mode (permission and sticky bits), but only if the file was created. Some characters (< > : \" \/ \\ | ? *) are reserved under Windows as documented by Naming Files, Paths, and Namespaces. Under NTFS, if the filename contains a colon, Node.js will open a file system stream, as described by this MSDN page."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_opendir_path_options","title":"`fsPromises.opendir(path[, options])`","description":"Asynchronously open a directory. See opendir(3). Creates an fs.Dir, which contains all further functions for reading from and cleaning up the directory. The encoding option sets the encoding for the path while opening the directory and subsequent read operations. Example using async iteration: const fs = require('fs');  async function print(path) {   const dir = await fs.promises.opendir(path);   for await (const dirent of dir) {     console.log(dirent.name);   } } print('.\/').catch(console.error);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_readdir_path_options","title":"`fsPromises.readdir(path[, options])`","description":"Reads the contents of a directory then resolves the Promise with an array of the names of the files in the directory excluding '.' and '..'. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the filenames. If the encoding is set to 'buffer', the filenames returned will be passed as Buffer objects. If options.withFileTypes is set to true, the resolved array will contain fs.Dirent objects. const fs = require('fs');  async function print(path) {   const files = await fs.promises.readdir(path);   for (const file of files) {     console.log(file);   } } print('.\/').catch(console.error);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_readfile_path_options","title":"`fsPromises.readFile(path[, options])`","description":"Asynchronously reads the entire contents of a file. The Promise is resolved with the contents of the file. If no encoding is specified (using options.encoding), the data is returned as a Buffer object. Otherwise, the data will be a string. If options is a string, then it specifies the encoding. When the path is a directory, the behavior of fsPromises.readFile() is platform-specific. On macOS, Linux, and Windows, the promise will be rejected with an error. On FreeBSD, a representation of the directory's contents will be returned. It is possible to abort an ongoing readFile using an AbortSignal. If a request is aborted the promise returned is rejected with an AbortError: const controller = new AbortController(); const signal = controller.signal; readFile(fileName, { signal }).then((file) => { \/* ... *\/ }); \/\/ Abort the request controller.abort();  Aborting an ongoing request does not abort individual operating system requests but rather the internal buffering fs.readFile performs. Any specified FileHandle has to support reading."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_readlink_path_options","title":"`fsPromises.readlink(path[, options])`","description":"Asynchronous readlink(2). The Promise is resolved with the linkString upon success. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the link path returned. If the encoding is set to 'buffer', the link path returned will be passed as a Buffer object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_realpath_path_options","title":"`fsPromises.realpath(path[, options])`","description":"Determines the actual location of path using the same semantics as the fs.realpath.native() function then resolves the Promise with the resolved path. Only paths that can be converted to UTF8 strings are supported. The optional options argument can be a string specifying an encoding, or an object with an encoding property specifying the character encoding to use for the path. If the encoding is set to 'buffer', the path returned will be passed as a Buffer object. On Linux, when Node.js is linked against musl libc, the procfs file system must be mounted on \/proc in order for this function to work. Glibc does not have this restriction."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_rename_oldpath_newpath","title":"`fsPromises.rename(oldPath, newPath)`","description":"Renames oldPath to newPath and resolves the Promise with no arguments upon success."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_rmdir_path_options","title":"`fsPromises.rmdir(path[, options])`","description":"Removes the directory identified by path then resolves the Promise with no arguments upon success. Using fsPromises.rmdir() on a file (not a directory) results in the Promise being rejected with an ENOENT error on Windows and an ENOTDIR error on POSIX. Setting recursive to true results in behavior similar to the Unix command rm -rf: an error will not be raised for paths that do not exist, and paths that represent files will be deleted. The permissive behavior of the recursive option is deprecated, ENOTDIR and ENOENT will be thrown in the future."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_rm_path_options","title":"`fsPromises.rm(path[, options])`","description":"Removes files and directories (modeled on the standard POSIX rm utility). Resolves the Promise with no arguments on success."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_stat_path_options","title":"`fsPromises.stat(path[, options])`","description":"The Promise is resolved with the fs.Stats object for the given path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_symlink_target_path_type","title":"`fsPromises.symlink(target, path[, type])`","description":"Creates a symbolic link then resolves the Promise with no arguments upon success. The type argument is only used on Windows platforms and can be one of 'dir', 'file', or 'junction'. Windows junction points require the destination path to be absolute. When using 'junction', the target argument will automatically be normalized to absolute path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_truncate_path_len","title":"`fsPromises.truncate(path[, len])`","description":"Truncates the path then resolves the Promise with no arguments upon success. The path must be a string or Buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_unlink_path","title":"`fsPromises.unlink(path)`","description":"Asynchronous unlink(2). The Promise is resolved with no arguments upon success."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_utimes_path_atime_mtime","title":"`fsPromises.utimes(path, atime, mtime)`","description":"Change the file system timestamps of the object referenced by path then resolves the Promise with no arguments upon success. The atime and mtime arguments follow these rules:  Values can be either numbers representing Unix epoch time, Dates, or a numeric string like '123456789.0'. If the value can not be converted to a number, or is NaN, Infinity or -Infinity, an Error will be thrown."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fspromises_writefile_file_data_options","title":"`fsPromises.writeFile(file, data[, options])`","description":"Asynchronously writes data to a file, replacing the file if it already exists. data can be a string, a buffer, or an object with an own toString function property. The Promise is resolved with no arguments upon success. The encoding option is ignored if data is a buffer. If options is a string, then it specifies the encoding. Any specified FileHandle has to support writing. It is unsafe to use fsPromises.writeFile() multiple times on the same file without waiting for the Promise to be fulfilled (or rejected). Similarly to fsPromises.readFile - fsPromises.writeFile is a convenience method that performs multiple write calls internally to write the buffer passed to it. For performance sensitive code consider using fs.createWriteStream(). It is possible to use an <AbortSignal> to cancel an fsPromises.writeFile(). Cancelation is \"best effort\", and some amount of data is likely still to be written. const controller = new AbortController(); const { signal } = controller; const data = new Uint8Array(Buffer.from('Hello Node.js')); (async () => {   try {     await fs.writeFile('message.txt', data, { signal });   } catch (err) {   \/\/ When a request is aborted - err is an AbortError   } })(); \/\/ When the request should be aborted controller.abort();  Aborting an ongoing request does not abort individual operating system requests but rather the internal buffering fs.writeFile performs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_fs_constants","title":"FS constants","description":"The following constants are exported by fs.constants. Not every constant will be available on every operating system. To use more than one constant, use the bitwise OR | operator. Example: const fs = require('fs');  const {   O_RDWR,   O_CREAT,   O_EXCL } = fs.constants;  fs.open('\/path\/to\/my\/file', O_RDWR | O_CREAT | O_EXCL, (err, fd) => {   \/\/ ... });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_access_constants","title":"File access constants","description":"The following constants are meant for use with fs.access().         Constant     Description           F_OK     Flag indicating that the file is visible to the calling process.      This is useful for determining if a file exists, but says nothing      about rwx permissions. Default if no mode is specified.           R_OK     Flag indicating that the file can be read by the calling process.           W_OK     Flag indicating that the file can be written by the calling     process.           X_OK     Flag indicating that the file can be executed by the calling     process. This has no effect on Windows     (will behave like fs.constants.F_OK)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_copy_constants","title":"File copy constants","description":"The following constants are meant for use with fs.copyFile().         Constant     Description           COPYFILE_EXCL     If present, the copy operation will fail with an error if the     destination path already exists.           COPYFILE_FICLONE     If present, the copy operation will attempt to create a     copy-on-write reflink. If the underlying platform does not support     copy-on-write, then a fallback copy mechanism is used.           COPYFILE_FICLONE_FORCE     If present, the copy operation will attempt to create a     copy-on-write reflink. If the underlying platform does not support     copy-on-write, then the operation will fail with an error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_open_constants","title":"File open constants","description":"The following constants are meant for use with fs.open().         Constant     Description           O_RDONLY     Flag indicating to open a file for read-only access.           O_WRONLY     Flag indicating to open a file for write-only access.           O_RDWR     Flag indicating to open a file for read-write access.           O_CREAT     Flag indicating to create the file if it does not already exist.           O_EXCL     Flag indicating that opening a file should fail if the     O_CREAT flag is set and the file already exists.           O_NOCTTY     Flag indicating that if path identifies a terminal device, opening the     path shall not cause that terminal to become the controlling terminal for     the process (if the process does not already have one).           O_TRUNC     Flag indicating that if the file exists and is a regular file, and the     file is opened successfully for write access, its length shall be truncated     to zero.           O_APPEND     Flag indicating that data will be appended to the end of the file.           O_DIRECTORY     Flag indicating that the open should fail if the path is not a     directory.         O_NOATIME     Flag indicating reading accesses to the file system will no longer     result in an update to the atime information associated with     the file. This flag is available on Linux operating systems only.           O_NOFOLLOW     Flag indicating that the open should fail if the path is a symbolic     link.           O_SYNC     Flag indicating that the file is opened for synchronized I\/O with write     operations waiting for file integrity.           O_DSYNC     Flag indicating that the file is opened for synchronized I\/O with write     operations waiting for data integrity.           O_SYMLINK     Flag indicating to open the symbolic link itself rather than the     resource it is pointing to.           O_DIRECT     When set, an attempt will be made to minimize caching effects of file     I\/O.           O_NONBLOCK     Flag indicating to open the file in nonblocking mode when possible.           UV_FS_O_FILEMAP     When set, a memory file mapping is used to access the file. This flag     is available on Windows operating systems only. On other operating systems,     this flag is ignored."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_type_constants","title":"File type constants","description":"The following constants are meant for use with the fs.Stats object's mode property for determining a file's type.         Constant     Description           S_IFMT     Bit mask used to extract the file type code.           S_IFREG     File type constant for a regular file.           S_IFDIR     File type constant for a directory.           S_IFCHR     File type constant for a character-oriented device file.           S_IFBLK     File type constant for a block-oriented device file.           S_IFIFO     File type constant for a FIFO\/pipe.           S_IFLNK     File type constant for a symbolic link.           S_IFSOCK     File type constant for a socket."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_mode_constants","title":"File mode constants","description":"The following constants are meant for use with the fs.Stats object's mode property for determining the access permissions for a file.         Constant     Description           S_IRWXU     File mode indicating readable, writable, and executable by owner.           S_IRUSR     File mode indicating readable by owner.           S_IWUSR     File mode indicating writable by owner.           S_IXUSR     File mode indicating executable by owner.           S_IRWXG     File mode indicating readable, writable, and executable by group.           S_IRGRP     File mode indicating readable by group.           S_IWGRP     File mode indicating writable by group.           S_IXGRP     File mode indicating executable by group.           S_IRWXO     File mode indicating readable, writable, and executable by others.           S_IROTH     File mode indicating readable by others.           S_IWOTH     File mode indicating writable by others.           S_IXOTH     File mode indicating executable by others."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_system_flags","title":"File system flags","description":"The following flags are available wherever the flag option takes a string.   'a': Open file for appending. The file is created if it does not exist.   'ax': Like 'a' but fails if the path exists.   'a+': Open file for reading and appending. The file is created if it does not exist.   'ax+': Like 'a+' but fails if the path exists.   'as': Open file for appending in synchronous mode. The file is created if it does not exist.   'as+': Open file for reading and appending in synchronous mode. The file is created if it does not exist.   'r': Open file for reading. An exception occurs if the file does not exist.   'r+': Open file for reading and writing. An exception occurs if the file does not exist.   'rs+': Open file for reading and writing in synchronous mode. Instructs the operating system to bypass the local file system cache. This is primarily useful for opening files on NFS mounts as it allows skipping the potentially stale local cache. It has a very real impact on I\/O performance so using this flag is not recommended unless it is needed. This doesn't turn fs.open() or fsPromises.open() into a synchronous blocking call. If synchronous operation is desired, something like fs.openSync() should be used.   'w': Open file for writing. The file is created (if it does not exist) or truncated (if it exists).   'wx': Like 'w' but fails if the path exists.   'w+': Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).   'wx+': Like 'w+' but fails if the path exists.   flag can also be a number as documented by open(2); commonly used constants are available from fs.constants. On Windows, flags are translated to their equivalent ones where applicable, e.g. O_WRONLY to FILE_GENERIC_WRITE, or O_EXCL|O_CREAT to CREATE_NEW, as accepted by CreateFileW. The exclusive flag 'x' (O_EXCL flag in open(2)) causes the operation to return an error if the path already exists. On POSIX, if the path is a symbolic link, using O_EXCL returns an error even if the link is to a path that does not exist. The exclusive flag might not work with network file systems. On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file. Modifying a file rather than replacing it may require the flag option to be set to 'r+' rather than the default 'w'. The behavior of some flags are platform-specific. As such, opening a directory on macOS and Linux with the 'a+' flag, as in the example below, will return an error. In contrast, on Windows and FreeBSD, a file descriptor or a FileHandle will be returned. \/\/ macOS and Linux fs.open('<directory>', 'a+', (err, fd) => {   \/\/ => [Error: EISDIR: illegal operation on a directory, open <directory>] });  \/\/ Windows and FreeBSD fs.open('<directory>', 'a+', (err, fd) => {   \/\/ => null, <fd> });  On Windows, opening an existing hidden file using the 'w' flag (either through fs.open() or fs.writeFile() or fsPromises.open()) will fail with EPERM. Existing hidden files can be opened for writing with the 'r+' flag. A call to fs.ftruncate() or filehandle.truncate() can be used to reset the file contents."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http","title":"HTTP","description":"Source Code: lib\/http.js To use the HTTP server and client one must require('http'). The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses, so the user is able to stream data. HTTP message headers are represented by an object like this:  { 'content-length': '123',   'content-type': 'text\/plain',   'connection': 'keep-alive',   'host': 'mysite.com',   'accept': '*\/*' }  Keys are lowercased. Values are not modified. In order to support the full spectrum of possible HTTP applications, the Node.js HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body. See message.headers for details on how duplicate headers are handled. The raw headers as they were received are retained in the rawHeaders property, which is an array of [key, value, key2, value2, ...]. For example, the previous message header object might have a rawHeaders list like the following:  [ 'ConTent-Length', '123456',   'content-LENGTH', '123',   'content-type', 'text\/plain',   'CONNECTION', 'keep-alive',   'Host', 'mysite.com',   'accepT', '*\/*' ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_createserver_options_requestlistener","title":"`http.createServer([options][, requestListener])`","description":"Returns a new instance of http.Server. The requestListener is a function which is automatically added to the 'request' event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_get_options_callback","title":"`http.get(options[, callback])`","description":"Since most requests are GET requests without bodies, Node.js provides this convenience method. The only difference between this method and http.request() is that it sets the method to GET and calls req.end() automatically. The callback must take care to consume the response data for reasons stated in http.ClientRequest section. The callback is invoked with a single argument that is an instance of http.IncomingMessage. JSON fetching example: http.get('http:\/\/nodejs.org\/dist\/index.json', (res) => {   const { statusCode } = res;   const contentType = res.headers['content-type'];    let error;   \/\/ Any 2xx status code signals a successful response but   \/\/ here we're only checking for 200.   if (statusCode !== 200) {     error = new Error('Request Failed.\\n' +                       `Status Code: ${statusCode}`);   } else if (!\/^application\\\/json\/.test(contentType)) {     error = new Error('Invalid content-type.\\n' +                       `Expected application\/json but received ${contentType}`);   }   if (error) {     console.error(error.message);     \/\/ Consume response data to free up memory     res.resume();     return;   }    res.setEncoding('utf8');   let rawData = '';   res.on('data', (chunk) => { rawData += chunk; });   res.on('end', () => {     try {       const parsedData = JSON.parse(rawData);       console.log(parsedData);     } catch (e) {       console.error(e.message);     }   }); }).on('error', (e) => {   console.error(`Got error: ${e.message}`); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_get_url_options_callback","title":"`http.get(url[, options][, callback])`","description":"Since most requests are GET requests without bodies, Node.js provides this convenience method. The only difference between this method and http.request() is that it sets the method to GET and calls req.end() automatically. The callback must take care to consume the response data for reasons stated in http.ClientRequest section. The callback is invoked with a single argument that is an instance of http.IncomingMessage. JSON fetching example: http.get('http:\/\/nodejs.org\/dist\/index.json', (res) => {   const { statusCode } = res;   const contentType = res.headers['content-type'];    let error;   \/\/ Any 2xx status code signals a successful response but   \/\/ here we're only checking for 200.   if (statusCode !== 200) {     error = new Error('Request Failed.\\n' +                       `Status Code: ${statusCode}`);   } else if (!\/^application\\\/json\/.test(contentType)) {     error = new Error('Invalid content-type.\\n' +                       `Expected application\/json but received ${contentType}`);   }   if (error) {     console.error(error.message);     \/\/ Consume response data to free up memory     res.resume();     return;   }    res.setEncoding('utf8');   let rawData = '';   res.on('data', (chunk) => { rawData += chunk; });   res.on('end', () => {     try {       const parsedData = JSON.parse(rawData);       console.log(parsedData);     } catch (e) {       console.error(e.message);     }   }); }).on('error', (e) => {   console.error(`Got error: ${e.message}`); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_request_options_callback","title":"`http.request(options[, callback])`","description":"Node.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests. url can be a string or a URL object. If url is a string, it is automatically parsed with new URL(). If it is a URL object, it will be automatically converted to an ordinary options object. If both url and options are specified, the objects are merged, with the options properties taking precedence. The optional callback parameter will be added as a one-time listener for the 'response' event. http.request() returns an instance of the http.ClientRequest class. The ClientRequest instance is a writable stream. If one needs to upload a file with a POST request, then write to the ClientRequest object. const postData = querystring.stringify({   'msg': 'Hello World!' });  const options = {   hostname: 'www.google.com',   port: 80,   path: '\/upload',   method: 'POST',   headers: {     'Content-Type': 'application\/x-www-form-urlencoded',     'Content-Length': Buffer.byteLength(postData)   } };  const req = http.request(options, (res) => {   console.log(`STATUS: ${res.statusCode}`);   console.log(`HEADERS: ${JSON.stringify(res.headers)}`);   res.setEncoding('utf8');   res.on('data', (chunk) => {     console.log(`BODY: ${chunk}`);   });   res.on('end', () => {     console.log('No more data in response.');   }); });  req.on('error', (e) => {   console.error(`problem with request: ${e.message}`); });  \/\/ Write data to request body req.write(postData); req.end();  In the example req.end() was called. With http.request() one must always call req.end() to signify the end of the request - even if there is no data being written to the request body. If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an 'error' event is emitted on the returned request object. As with all 'error' events, if no listeners are registered the error will be thrown. There are a few special headers that should be noted.   Sending a 'Connection: keep-alive' will notify Node.js that the connection to the server should be persisted until the next request.   Sending a 'Content-Length' header will disable the default chunked encoding.   Sending an 'Expect' header will immediately send the request headers. Usually, when sending 'Expect: 100-continue', both a timeout and a listener for the 'continue' event should be set. See RFC 2616 Section 8.2.3 for more information.   Sending an Authorization header will override using the auth option to compute basic authentication.   Example using a URL as options: const options = new URL('http:\/\/abc:xyz@example.com');  const req = http.request(options, (res) => {   \/\/ ... });  In a successful request, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object ('data' will not be emitted at all if the response body is empty, for instance, in most redirects) 'end' on the res object   'close'  In the case of a connection error, the following events will be emitted:  'socket' 'error' 'close'  In the case of a premature connection close before the response is received, the following events will be emitted in the following order:  'socket' 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  In the case of a premature connection close after the response is received, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object   (connection closed here) 'aborted' on the res object 'error' on the res object with an error with message 'Error: aborted' and code 'ECONNRESET'. 'close' 'close' on the res object  If req.destroy() is called before a socket is assigned, the following events will be emitted in the following order:  (req.destroy() called here) 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  If req.destroy() is called before the connection succeeds, the following events will be emitted in the following order:  'socket' (req.destroy() called here) 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  If req.destroy() is called after the response is received, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object   (req.destroy() called here) 'aborted' on the res object 'error' on the res object with an error with message 'Error: aborted' and code 'ECONNRESET'. 'close' 'close' on the res object  If req.abort() is called before a socket is assigned, the following events will be emitted in the following order:  (req.abort() called here) 'abort' 'close'  If req.abort() is called before the connection succeeds, the following events will be emitted in the following order:  'socket' (req.abort() called here) 'abort' 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  If req.abort() is called after the response is received, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object   (req.abort() called here) 'abort' 'aborted' on the res object 'error' on the res object with an error with message 'Error: aborted' and code 'ECONNRESET'. 'close' 'close' on the res object  Setting the timeout option or using the setTimeout() function will not abort the request or do anything besides add a 'timeout' event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_request_url_options_callback","title":"`http.request(url[, options][, callback])`","description":"Node.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests. url can be a string or a URL object. If url is a string, it is automatically parsed with new URL(). If it is a URL object, it will be automatically converted to an ordinary options object. If both url and options are specified, the objects are merged, with the options properties taking precedence. The optional callback parameter will be added as a one-time listener for the 'response' event. http.request() returns an instance of the http.ClientRequest class. The ClientRequest instance is a writable stream. If one needs to upload a file with a POST request, then write to the ClientRequest object. const postData = querystring.stringify({   'msg': 'Hello World!' });  const options = {   hostname: 'www.google.com',   port: 80,   path: '\/upload',   method: 'POST',   headers: {     'Content-Type': 'application\/x-www-form-urlencoded',     'Content-Length': Buffer.byteLength(postData)   } };  const req = http.request(options, (res) => {   console.log(`STATUS: ${res.statusCode}`);   console.log(`HEADERS: ${JSON.stringify(res.headers)}`);   res.setEncoding('utf8');   res.on('data', (chunk) => {     console.log(`BODY: ${chunk}`);   });   res.on('end', () => {     console.log('No more data in response.');   }); });  req.on('error', (e) => {   console.error(`problem with request: ${e.message}`); });  \/\/ Write data to request body req.write(postData); req.end();  In the example req.end() was called. With http.request() one must always call req.end() to signify the end of the request - even if there is no data being written to the request body. If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an 'error' event is emitted on the returned request object. As with all 'error' events, if no listeners are registered the error will be thrown. There are a few special headers that should be noted.   Sending a 'Connection: keep-alive' will notify Node.js that the connection to the server should be persisted until the next request.   Sending a 'Content-Length' header will disable the default chunked encoding.   Sending an 'Expect' header will immediately send the request headers. Usually, when sending 'Expect: 100-continue', both a timeout and a listener for the 'continue' event should be set. See RFC 2616 Section 8.2.3 for more information.   Sending an Authorization header will override using the auth option to compute basic authentication.   Example using a URL as options: const options = new URL('http:\/\/abc:xyz@example.com');  const req = http.request(options, (res) => {   \/\/ ... });  In a successful request, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object ('data' will not be emitted at all if the response body is empty, for instance, in most redirects) 'end' on the res object   'close'  In the case of a connection error, the following events will be emitted:  'socket' 'error' 'close'  In the case of a premature connection close before the response is received, the following events will be emitted in the following order:  'socket' 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  In the case of a premature connection close after the response is received, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object   (connection closed here) 'aborted' on the res object 'error' on the res object with an error with message 'Error: aborted' and code 'ECONNRESET'. 'close' 'close' on the res object  If req.destroy() is called before a socket is assigned, the following events will be emitted in the following order:  (req.destroy() called here) 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  If req.destroy() is called before the connection succeeds, the following events will be emitted in the following order:  'socket' (req.destroy() called here) 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  If req.destroy() is called after the response is received, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object   (req.destroy() called here) 'aborted' on the res object 'error' on the res object with an error with message 'Error: aborted' and code 'ECONNRESET'. 'close' 'close' on the res object  If req.abort() is called before a socket is assigned, the following events will be emitted in the following order:  (req.abort() called here) 'abort' 'close'  If req.abort() is called before the connection succeeds, the following events will be emitted in the following order:  'socket' (req.abort() called here) 'abort' 'error' with an error with message 'Error: socket hang up' and code 'ECONNRESET' 'close'  If req.abort() is called after the response is received, the following events will be emitted in the following order:  'socket' 'response'  'data' any number of times, on the res object   (req.abort() called here) 'abort' 'aborted' on the res object 'error' on the res object with an error with message 'Error: aborted' and code 'ECONNRESET'. 'close' 'close' on the res object  Setting the timeout option or using the setTimeout() function will not abort the request or do anything besides add a 'timeout' event."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_validateheadername_name","title":"`http.validateHeaderName(name)`","description":"Performs the low-level validations on the provided name that are done when res.setHeader(name, value) is called. Passing illegal value as name will result in a TypeError being thrown, identified by code: 'ERR_INVALID_HTTP_TOKEN'. It is not necessary to use this method before passing headers to an HTTP request or response. The HTTP module will automatically validate such headers. Examples: Example: const { validateHeaderName } = require('http');  try {   validateHeaderName(''); } catch (err) {   err instanceof TypeError; \/\/ --> true   err.code; \/\/ --> 'ERR_INVALID_HTTP_TOKEN'   err.message; \/\/ --> 'Header name must be a valid HTTP token [\"\"]' }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_validateheadervalue_name_value","title":"`http.validateHeaderValue(name, value)`","description":"Performs the low-level validations on the provided value that are done when res.setHeader(name, value) is called. Passing illegal value as value will result in a TypeError being thrown.  Undefined value error is identified by code: 'ERR_HTTP_INVALID_HEADER_VALUE'. Invalid value character error is identified by code: 'ERR_INVALID_CHAR'.  It is not necessary to use this method before passing headers to an HTTP request or response. The HTTP module will automatically validate such headers. Examples: const { validateHeaderValue } = require('http');  try {   validateHeaderValue('x-my-header', undefined); } catch (err) {   err instanceof TypeError; \/\/ --> true   err.code === 'ERR_HTTP_INVALID_HEADER_VALUE'; \/\/ --> true   err.message; \/\/ --> 'Invalid value \"undefined\" for header \"x-my-header\"' }  try {   validateHeaderValue('x-my-header', 'o\u028am\u026a\u0261\u0259'); } catch (err) {   err instanceof TypeError; \/\/ --> true   err.code === 'ERR_INVALID_CHAR'; \/\/ --> true   err.message; \/\/ --> 'Invalid character in header content [\"x-my-header\"]' }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http_2","title":"HTTP\/2","description":"Source Code: lib\/http2.js The http2 module provides an implementation of the HTTP\/2 protocol. It can be accessed using: const http2 = require('http2');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_core_api","title":"Core API","description":"The Core API provides a low-level interface designed specifically around support for HTTP\/2 protocol features. It is specifically not designed for compatibility with the existing HTTP\/1 module API. However, the Compatibility API is. The http2 Core API is much more symmetric between client and server than the http API. For instance, most events, like 'error', 'connect' and 'stream', can be emitted either by client-side code or server-side code."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http2_createserver_options_onrequesthandler","title":"`http2.createServer(options[, onRequestHandler])`","description":"Returns a net.Server instance that creates and manages Http2Session instances. Since there are no browsers known that support unencrypted HTTP\/2, the use of http2.createSecureServer() is necessary when communicating with browser clients. const http2 = require('http2');  \/\/ Create an unencrypted HTTP\/2 server. \/\/ Since there are no browsers known that support \/\/ unencrypted HTTP\/2, the use of `http2.createSecureServer()` \/\/ is necessary when communicating with browser clients. const server = http2.createServer();  server.on('stream', (stream, headers) => {   stream.respond({     'content-type': 'text\/html; charset=utf-8',     ':status': 200   });   stream.end('<h1>Hello World<\/h1>'); });  server.listen(80);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http2_createsecureserver_options_onrequesthandler","title":"`http2.createSecureServer(options[, onRequestHandler])`","description":"Returns a tls.Server instance that creates and manages Http2Session instances. const http2 = require('http2'); const fs = require('fs');  const options = {   key: fs.readFileSync('server-key.pem'),   cert: fs.readFileSync('server-cert.pem') };  \/\/ Create a secure HTTP\/2 server const server = http2.createSecureServer(options);  server.on('stream', (stream, headers) => {   stream.respond({     'content-type': 'text\/html; charset=utf-8',     ':status': 200   });   stream.end('<h1>Hello World<\/h1>'); });  server.listen(80);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http2_connect_authority_options_listener","title":"`http2.connect(authority[, options][, listener])`","description":"Returns a ClientHttp2Session instance. const http2 = require('http2'); const client = http2.connect('https:\/\/localhost:1234');  \/* Use the client *\/  client.close();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http2_getdefaultsettings","title":"`http2.getDefaultSettings()`","description":"Returns an object containing the default settings for an Http2Session instance. This method returns a new object instance every time it is called so instances returned may be safely modified for use."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http2_getpackedsettings_settings","title":"`http2.getPackedSettings([settings])`","description":"Returns a Buffer instance containing serialized representation of the given HTTP\/2 settings as specified in the HTTP\/2 specification. This is intended for use with the HTTP2-Settings header field. const http2 = require('http2');  const packed = http2.getPackedSettings({ enablePush: false });  console.log(packed.toString('base64')); \/\/ Prints: AAIAAAAA"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_http2_getunpackedsettings_buf","title":"`http2.getUnpackedSettings(buf)`","description":"Returns a HTTP\/2 Settings Object containing the deserialized settings from the given Buffer as generated by http2.getPackedSettings()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_server_side_example","title":"Server-side example","description":"The following illustrates a simple HTTP\/2 server using the Core API. Since there are no browsers known that support unencrypted HTTP\/2, the use of http2.createSecureServer() is necessary when communicating with browser clients. const http2 = require('http2'); const fs = require('fs');  const server = http2.createSecureServer({   key: fs.readFileSync('localhost-privkey.pem'),   cert: fs.readFileSync('localhost-cert.pem') }); server.on('error', (err) => console.error(err));  server.on('stream', (stream, headers) => {   \/\/ stream is a Duplex   stream.respond({     'content-type': 'text\/html; charset=utf-8',     ':status': 200   });   stream.end('<h1>Hello World<\/h1>'); });  server.listen(8443);  To generate the certificate and key for this example, run: openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj '\/CN=localhost' \\   -keyout localhost-privkey.pem -out localhost-cert.pem"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_client_side_example","title":"Client-side example","description":"The following illustrates an HTTP\/2 client: const http2 = require('http2'); const fs = require('fs'); const client = http2.connect('https:\/\/localhost:8443', {   ca: fs.readFileSync('localhost-cert.pem') }); client.on('error', (err) => console.error(err));  const req = client.request({ ':path': '\/' });  req.on('response', (headers, flags) => {   for (const name in headers) {     console.log(`${name}: ${headers[name]}`);   } });  req.setEncoding('utf8'); let data = ''; req.on('data', (chunk) => { data += chunk; }); req.on('end', () => {   console.log(`\\n${data}`);   client.close(); }); req.end();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_headers_object","title":"Headers object","description":"Headers are represented as own-properties on JavaScript objects. The property keys will be serialized to lower-case. Property values should be strings (if they are not they will be coerced to strings) or an Array of strings (in order to send more than one value per header field). const headers = {   ':status': '200',   'content-type': 'text-plain',   'ABC': ['has', 'more', 'than', 'one', 'value'] };  stream.respond(headers);  Header objects passed to callback functions will have a null prototype. This means that normal JavaScript object methods such as Object.prototype.toString() and Object.prototype.hasOwnProperty() will not work. For incoming headers:  The :status header is converted to number. Duplicates of :status, :method, :authority, :scheme, :path, :protocol, age, authorization, access-control-allow-credentials, access-control-max-age, access-control-request-method, content-encoding, content-language, content-length, content-location, content-md5, content-range, content-type, date, dnt, etag, expires, from, host, if-match, if-modified-since, if-none-match, if-range, if-unmodified-since, last-modified, location, max-forwards, proxy-authorization, range, referer,retry-after, tk, upgrade-insecure-requests, user-agent or x-content-type-options are discarded. set-cookie is always an array. Duplicates are added to the array. For duplicate cookie headers, the values are joined together with '; '. For all other headers, the values are joined together with ', '.  const http2 = require('http2'); const server = http2.createServer(); server.on('stream', (stream, headers) => {   console.log(headers[':path']);   console.log(headers.ABC); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_sensitive_headers","title":"Sensitive headers","description":"HTTP2 headers can be marked as sensitive, which means that the HTTP\/2 header compression algorithm will never index them. This can make sense for header values with low entropy and that may be considered valuable to an attacker, for example Cookie or Authorization. To achieve this, add the header name to the [http2.sensitiveHeaders] property as an array: const headers = {   ':status': '200',   'content-type': 'text-plain',   'cookie': 'some-cookie',   'other-sensitive-header': 'very secret data',   [http2.sensitiveHeaders]: ['cookie', 'other-sensitive-header'] };  stream.respond(headers);  For some headers, such as Authorization and short Cookie headers, this flag is set automatically. This property is also set for received headers. It will contain the names of all headers marked as sensitive, including ones marked that way automatically."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_settings_object","title":"Settings object","description":"The http2.getDefaultSettings(), http2.getPackedSettings(), http2.createServer(), http2.createSecureServer(), http2session.settings(), http2session.localSettings, and http2session.remoteSettings APIs either return or receive as input an object that defines configuration settings for an Http2Session object. These objects are ordinary JavaScript objects containing the following properties.  headerTableSize <number> Specifies the maximum number of bytes used for header compression. The minimum allowed value is 0. The maximum allowed value is 232-1. Default: 4096. enablePush <boolean> Specifies true if HTTP\/2 Push Streams are to be permitted on the Http2Session instances. Default: true. initialWindowSize <number> Specifies the sender's initial window size in bytes for stream-level flow control. The minimum allowed value is 0. The maximum allowed value is 232-1. Default: 65535. maxFrameSize <number> Specifies the size in bytes of the largest frame payload. The minimum allowed value is 16,384. The maximum allowed value is 224-1. Default: 16384. maxConcurrentStreams <number> Specifies the maximum number of concurrent streams permitted on an Http2Session. There is no default value which implies, at least theoretically, 232-1 streams may be open concurrently at any given time in an Http2Session. The minimum value is 0. The maximum allowed value is 232-1. Default: 4294967295. maxHeaderListSize <number> Specifies the maximum size (uncompressed octets) of header list that will be accepted. The minimum allowed value is 0. The maximum allowed value is 232-1. Default: 65535. maxHeaderSize <number> Alias for maxHeaderListSize. enableConnectProtocol<boolean> Specifies true if the \"Extended Connect Protocol\" defined by RFC 8441 is to be enabled. This setting is only meaningful if sent by the server. Once the enableConnectProtocol setting has been enabled for a given Http2Session, it cannot be disabled. Default: false.  All additional properties on the settings object are ignored."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_handling","title":"Error handling","description":"There are several types of error conditions that may arise when using the http2 module: Validation errors occur when an incorrect argument, option, or setting value is passed in. These will always be reported by a synchronous throw. State errors occur when an action is attempted at an incorrect time (for instance, attempting to send data on a stream after it has closed). These will be reported using either a synchronous throw or via an 'error' event on the Http2Stream, Http2Session or HTTP\/2 Server objects, depending on where and when the error occurs. Internal errors occur when an HTTP\/2 session fails unexpectedly. These will be reported via an 'error' event on the Http2Session or HTTP\/2 Server objects. Protocol errors occur when various HTTP\/2 protocol constraints are violated. These will be reported using either a synchronous throw or via an 'error' event on the Http2Stream, Http2Session or HTTP\/2 Server objects, depending on where and when the error occurs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_invalid_character_handling_in_header_names_and_values","title":"Invalid character handling in header names and values","description":"The HTTP\/2 implementation applies stricter handling of invalid characters in HTTP header names and values than the HTTP\/1 implementation. Header field names are case-insensitive and are transmitted over the wire strictly as lower-case strings. The API provided by Node.js allows header names to be set as mixed-case strings (e.g. Content-Type) but will convert those to lower-case (e.g. content-type) upon transmission. Header field-names must only contain one or more of the following ASCII characters: a-z, A-Z, 0-9, !, #, $, %, &, ', *, +, -, ., ^, _, ` (backtick), |, and ~. Using invalid characters within an HTTP header field name will cause the stream to be closed with a protocol error being reported. Header field values are handled with more leniency but should not contain new-line or carriage return characters and should be limited to US-ASCII characters, per the requirements of the HTTP specification."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_push_streams_on_the_client","title":"Push streams on the client","description":"To receive pushed streams on the client, set a listener for the 'stream' event on the ClientHttp2Session: const http2 = require('http2');  const client = http2.connect('http:\/\/localhost');  client.on('stream', (pushedStream, requestHeaders) => {   pushedStream.on('push', (responseHeaders) => {     \/\/ Process response headers   });   pushedStream.on('data', (chunk) => { \/* handle pushed data *\/ }); });  const req = client.request({ ':path': '\/' });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_supporting_the_connect_method","title":"Supporting the `CONNECT` method","description":"The CONNECT method is used to allow an HTTP\/2 server to be used as a proxy for TCP\/IP connections. A simple TCP Server: const net = require('net');  const server = net.createServer((socket) => {   let name = '';   socket.setEncoding('utf8');   socket.on('data', (chunk) => name += chunk);   socket.on('end', () => socket.end(`hello ${name}`)); });  server.listen(8000);  An HTTP\/2 CONNECT proxy: const http2 = require('http2'); const { NGHTTP2_REFUSED_STREAM } = http2.constants; const net = require('net');  const proxy = http2.createServer(); proxy.on('stream', (stream, headers) => {   if (headers[':method'] !== 'CONNECT') {     \/\/ Only accept CONNECT requests     stream.close(NGHTTP2_REFUSED_STREAM);     return;   }   const auth = new URL(`tcp:\/\/${headers[':authority']}`);   \/\/ It's a very good idea to verify that hostname and port are   \/\/ things this proxy should be connecting to.   const socket = net.connect(auth.port, auth.hostname, () => {     stream.respond();     socket.pipe(stream);     stream.pipe(socket);   });   socket.on('error', (error) => {     stream.close(http2.constants.NGHTTP2_CONNECT_ERROR);   }); });  proxy.listen(8001);  An HTTP\/2 CONNECT client: const http2 = require('http2');  const client = http2.connect('http:\/\/localhost:8001');  \/\/ Must not specify the ':path' and ':scheme' headers \/\/ for CONNECT requests or an error will be thrown. const req = client.request({   ':method': 'CONNECT',   ':authority': `localhost:${port}` });  req.on('response', (headers) => {   console.log(headers[http2.constants.HTTP2_HEADER_STATUS]); }); let data = ''; req.setEncoding('utf8'); req.on('data', (chunk) => data += chunk); req.on('end', () => {   console.log(`The server says: ${data}`);   client.close(); }); req.end('Jane');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_extended_connect_protocol","title":"The extended `CONNECT` protocol","description":"RFC 8441 defines an \"Extended CONNECT Protocol\" extension to HTTP\/2 that may be used to bootstrap the use of an Http2Stream using the CONNECT method as a tunnel for other communication protocols (such as WebSockets). The use of the Extended CONNECT Protocol is enabled by HTTP\/2 servers by using the enableConnectProtocol setting: const http2 = require('http2'); const settings = { enableConnectProtocol: true }; const server = http2.createServer({ settings });  Once the client receives the SETTINGS frame from the server indicating that the extended CONNECT may be used, it may send CONNECT requests that use the ':protocol' HTTP\/2 pseudo-header: const http2 = require('http2'); const client = http2.connect('http:\/\/localhost:8080'); client.on('remoteSettings', (settings) => {   if (settings.enableConnectProtocol) {     const req = client.request({ ':method': 'CONNECT', ':protocol': 'foo' });     \/\/ ...   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_compatibility_api","title":"Compatibility API","description":"The Compatibility API has the goal of providing a similar developer experience of HTTP\/1 when using HTTP\/2, making it possible to develop applications that support both HTTP\/1 and HTTP\/2. This API targets only the public API of the HTTP\/1. However many modules use internal methods or state, and those are not supported as it is a completely different implementation. The following example creates an HTTP\/2 server using the compatibility API: const http2 = require('http2'); const server = http2.createServer((req, res) => {   res.setHeader('Content-Type', 'text\/html');   res.setHeader('X-Foo', 'bar');   res.writeHead(200, { 'Content-Type': 'text\/plain; charset=utf-8' });   res.end('ok'); });  In order to create a mixed HTTPS and HTTP\/2 server, refer to the ALPN negotiation section. Upgrading from non-tls HTTP\/1 servers is not supported. The HTTP\/2 compatibility API is composed of Http2ServerRequest and Http2ServerResponse. They aim at API compatibility with HTTP\/1, but they do not hide the differences between the protocols. As an example, the status message for HTTP codes is ignored."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_alpn_negotiation","title":"ALPN negotiation","description":"ALPN negotiation allows supporting both HTTPS and HTTP\/2 over the same socket. The req and res objects can be either HTTP\/1 or HTTP\/2, and an application must restrict itself to the public API of HTTP\/1, and detect if it is possible to use the more advanced features of HTTP\/2. The following example creates a server that supports both protocols: const { createSecureServer } = require('http2'); const { readFileSync } = require('fs');  const cert = readFileSync('.\/cert.pem'); const key = readFileSync('.\/key.pem');  const server = createSecureServer(   { cert, key, allowHTTP1: true },   onRequest ).listen(4443);  function onRequest(req, res) {   \/\/ Detects if it is a HTTPS request or HTTP\/2   const { socket: { alpnProtocol } } = req.httpVersion === '2.0' ?     req.stream.session : req;   res.writeHead(200, { 'content-type': 'application\/json' });   res.end(JSON.stringify({     alpnProtocol,     httpVersion: req.httpVersion   })); }  The 'request' event works identically on both HTTPS and HTTP\/2."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_collecting_http_2_performance_metrics","title":"Collecting HTTP\/2 performance metrics","description":"The Performance Observer API can be used to collect basic performance metrics for each Http2Session and Http2Stream instance. const { PerformanceObserver } = require('perf_hooks');  const obs = new PerformanceObserver((items) => {   const entry = items.getEntries()[0];   console.log(entry.entryType);  \/\/ prints 'http2'   if (entry.name === 'Http2Session') {     \/\/ Entry contains statistics about the Http2Session   } else if (entry.name === 'Http2Stream') {     \/\/ Entry contains statistics about the Http2Stream   } }); obs.observe({ entryTypes: ['http2'] });  The entryType property of the PerformanceEntry will be equal to 'http2'. The name property of the PerformanceEntry will be equal to either 'Http2Stream' or 'Http2Session'. If name is equal to Http2Stream, the PerformanceEntry will contain the following additional properties:  bytesRead <number> The number of DATA frame bytes received for this Http2Stream. bytesWritten <number> The number of DATA frame bytes sent for this Http2Stream. id <number> The identifier of the associated Http2Stream timeToFirstByte <number> The number of milliseconds elapsed between the PerformanceEntry startTime and the reception of the first DATA frame. timeToFirstByteSent <number> The number of milliseconds elapsed between the PerformanceEntry startTime and sending of the first DATA frame. timeToFirstHeader <number> The number of milliseconds elapsed between the PerformanceEntry startTime and the reception of the first header.  If name is equal to Http2Session, the PerformanceEntry will contain the following additional properties:  bytesRead <number> The number of bytes received for this Http2Session. bytesWritten <number> The number of bytes sent for this Http2Session. framesReceived <number> The number of HTTP\/2 frames received by the Http2Session. framesSent <number> The number of HTTP\/2 frames sent by the Http2Session. maxConcurrentStreams <number> The maximum number of streams concurrently open during the lifetime of the Http2Session. pingRTT <number> The number of milliseconds elapsed since the transmission of a PING frame and the reception of its acknowledgment. Only present if a PING frame has been sent on the Http2Session. streamAverageDuration <number> The average duration (in milliseconds) for all Http2Stream instances. streamCount <number> The number of Http2Stream instances processed by the Http2Session. type <string> Either 'server' or 'client' to identify the type of Http2Session."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_note_on_authority_and_host","title":"Note on `:authority` and `host`","description":"HTTP\/2 requires requests to have either the :authority pseudo-header or the host header. Prefer :authority when constructing an HTTP\/2 request directly, and host when converting from HTTP\/1 (in proxies, for instance). The compatibility API falls back to host if :authority is not present. See request.authority for more information. However, if you don't use the compatibility API (or use req.headers directly), you need to implement any fall-back behaviour yourself."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https","title":"HTTPS","description":"Source Code: lib\/https.js HTTPS is the HTTP protocol over TLS\/SSL. In Node.js this is implemented as a separate module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_createserver_options_requestlistener","title":"`https.createServer([options][, requestListener])`","description":"\/\/ curl -k https:\/\/localhost:8000\/ const https = require('https'); const fs = require('fs');  const options = {   key: fs.readFileSync('test\/fixtures\/keys\/agent2-key.pem'),   cert: fs.readFileSync('test\/fixtures\/keys\/agent2-cert.pem') };  https.createServer(options, (req, res) => {   res.writeHead(200);   res.end('hello world\\n'); }).listen(8000);  Or const https = require('https'); const fs = require('fs');  const options = {   pfx: fs.readFileSync('test\/fixtures\/test_cert.pfx'),   passphrase: 'sample' };  https.createServer(options, (req, res) => {   res.writeHead(200);   res.end('hello world\\n'); }).listen(8000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_get_options_callback","title":"`https.get(options[, callback])`","description":"Like http.get() but for HTTPS. options can be an object, a string, or a URL object. If options is a string, it is automatically parsed with new URL(). If it is a URL object, it will be automatically converted to an ordinary options object. const https = require('https');  https.get('https:\/\/encrypted.google.com\/', (res) => {   console.log('statusCode:', res.statusCode);   console.log('headers:', res.headers);    res.on('data', (d) => {     process.stdout.write(d);   });  }).on('error', (e) => {   console.error(e); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_get_url_options_callback","title":"`https.get(url[, options][, callback])`","description":"Like http.get() but for HTTPS. options can be an object, a string, or a URL object. If options is a string, it is automatically parsed with new URL(). If it is a URL object, it will be automatically converted to an ordinary options object. const https = require('https');  https.get('https:\/\/encrypted.google.com\/', (res) => {   console.log('statusCode:', res.statusCode);   console.log('headers:', res.headers);    res.on('data', (d) => {     process.stdout.write(d);   });  }).on('error', (e) => {   console.error(e); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_request_options_callback","title":"`https.request(options[, callback])`","description":"Makes a request to a secure web server. The following additional options from tls.connect() are also accepted: ca, cert, ciphers, clientCertEngine, crl, dhparam, ecdhCurve, honorCipherOrder, key, passphrase, pfx, rejectUnauthorized, secureOptions, secureProtocol, servername, sessionIdContext, highWaterMark. options can be an object, a string, or a URL object. If options is a string, it is automatically parsed with new URL(). If it is a URL object, it will be automatically converted to an ordinary options object. const https = require('https');  const options = {   hostname: 'encrypted.google.com',   port: 443,   path: '\/',   method: 'GET' };  const req = https.request(options, (res) => {   console.log('statusCode:', res.statusCode);   console.log('headers:', res.headers);    res.on('data', (d) => {     process.stdout.write(d);   }); });  req.on('error', (e) => {   console.error(e); }); req.end();  Example using options from tls.connect(): const options = {   hostname: 'encrypted.google.com',   port: 443,   path: '\/',   method: 'GET',   key: fs.readFileSync('test\/fixtures\/keys\/agent2-key.pem'),   cert: fs.readFileSync('test\/fixtures\/keys\/agent2-cert.pem') }; options.agent = new https.Agent(options);  const req = https.request(options, (res) => {   \/\/ ... });  Alternatively, opt out of connection pooling by not using an Agent. const options = {   hostname: 'encrypted.google.com',   port: 443,   path: '\/',   method: 'GET',   key: fs.readFileSync('test\/fixtures\/keys\/agent2-key.pem'),   cert: fs.readFileSync('test\/fixtures\/keys\/agent2-cert.pem'),   agent: false };  const req = https.request(options, (res) => {   \/\/ ... });  Example using a URL as options: const options = new URL('https:\/\/abc:xyz@example.com');  const req = https.request(options, (res) => {   \/\/ ... });  Example pinning on certificate fingerprint, or the public key (similar to pin-sha256): const tls = require('tls'); const https = require('https'); const crypto = require('crypto');  function sha256(s) {   return crypto.createHash('sha256').update(s).digest('base64'); } const options = {   hostname: 'github.com',   port: 443,   path: '\/',   method: 'GET',   checkServerIdentity: function(host, cert) {     \/\/ Make sure the certificate is issued to the host we are connected to     const err = tls.checkServerIdentity(host, cert);     if (err) {       return err;     }      \/\/ Pin the public key, similar to HPKP pin-sha25 pinning     const pubkey256 = 'pL1+qb9HTMRZJmuC\/bB\/ZI9d302BYrrqiVuRyW+DGrU=';     if (sha256(cert.pubkey) !== pubkey256) {       const msg = 'Certificate verification error: ' +         `The public key of '${cert.subject.CN}' ` +         'does not match our pinned fingerprint';       return new Error(msg);     }      \/\/ Pin the exact certificate, rather than the pub key     const cert256 = '25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:' +       'D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16';     if (cert.fingerprint256 !== cert256) {       const msg = 'Certificate verification error: ' +         `The certificate of '${cert.subject.CN}' ` +         'does not match our pinned fingerprint';       return new Error(msg);     }      \/\/ This loop is informational only.     \/\/ Print the certificate and public key fingerprints of all certs in the     \/\/ chain. Its common to pin the public key of the issuer on the public     \/\/ internet, while pinning the public key of the service in sensitive     \/\/ environments.     do {       console.log('Subject Common Name:', cert.subject.CN);       console.log('  Certificate SHA256 fingerprint:', cert.fingerprint256);        hash = crypto.createHash('sha256');       console.log('  Public key ping-sha256:', sha256(cert.pubkey));        lastprint256 = cert.fingerprint256;       cert = cert.issuerCertificate;     } while (cert.fingerprint256 !== lastprint256);    }, };  options.agent = new https.Agent(options); const req = https.request(options, (res) => {   console.log('All OK. Server matched our pinned cert or public key');   console.log('statusCode:', res.statusCode);   \/\/ Print the HPKP values   console.log('headers:', res.headers['public-key-pins']);    res.on('data', (d) => {}); });  req.on('error', (e) => {   console.error(e.message); }); req.end();  Outputs for example: Subject Common Name: github.com   Certificate SHA256 fingerprint: 25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16   Public key ping-sha256: pL1+qb9HTMRZJmuC\/bB\/ZI9d302BYrrqiVuRyW+DGrU= Subject Common Name: DigiCert SHA2 Extended Validation Server CA   Certificate SHA256 fingerprint: 40:3E:06:2A:26:53:05:91:13:28:5B:AF:80:A0:D4:AE:42:2C:84:8C:9F:78:FA:D0:1F:C9:4B:C5:B8:7F:EF:1A   Public key ping-sha256: RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn\/yOhI\/y+ho= Subject Common Name: DigiCert High Assurance EV Root CA   Certificate SHA256 fingerprint: 74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF   Public key ping-sha256: WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18= All OK. Server matched our pinned cert or public key statusCode: 200 headers: max-age=0; pin-sha256=\"WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=\"; pin-sha256=\"RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn\/yOhI\/y+ho=\"; pin-sha256=\"k2v657xBsOVe1PQRwOsHsw3bsGT2VzIqz5K+59sNQws=\"; pin-sha256=\"K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q=\"; pin-sha256=\"IQBnNBEiFuhj+8x6X8XLgh01V9Ic5\/V3IRQLNFFc7v4=\"; pin-sha256=\"iie1VXtL7HzAMF+\/PVPR9xzT80kQxdZeJ+zduCB3uj0=\"; pin-sha256=\"LvRiGEjRqfzurezaWuj8Wie2gyHMrW5Q06LspMnox7A=\"; includeSubDomains"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_https_request_url_options_callback","title":"`https.request(url[, options][, callback])`","description":"Makes a request to a secure web server. The following additional options from tls.connect() are also accepted: ca, cert, ciphers, clientCertEngine, crl, dhparam, ecdhCurve, honorCipherOrder, key, passphrase, pfx, rejectUnauthorized, secureOptions, secureProtocol, servername, sessionIdContext, highWaterMark. options can be an object, a string, or a URL object. If options is a string, it is automatically parsed with new URL(). If it is a URL object, it will be automatically converted to an ordinary options object. const https = require('https');  const options = {   hostname: 'encrypted.google.com',   port: 443,   path: '\/',   method: 'GET' };  const req = https.request(options, (res) => {   console.log('statusCode:', res.statusCode);   console.log('headers:', res.headers);    res.on('data', (d) => {     process.stdout.write(d);   }); });  req.on('error', (e) => {   console.error(e); }); req.end();  Example using options from tls.connect(): const options = {   hostname: 'encrypted.google.com',   port: 443,   path: '\/',   method: 'GET',   key: fs.readFileSync('test\/fixtures\/keys\/agent2-key.pem'),   cert: fs.readFileSync('test\/fixtures\/keys\/agent2-cert.pem') }; options.agent = new https.Agent(options);  const req = https.request(options, (res) => {   \/\/ ... });  Alternatively, opt out of connection pooling by not using an Agent. const options = {   hostname: 'encrypted.google.com',   port: 443,   path: '\/',   method: 'GET',   key: fs.readFileSync('test\/fixtures\/keys\/agent2-key.pem'),   cert: fs.readFileSync('test\/fixtures\/keys\/agent2-cert.pem'),   agent: false };  const req = https.request(options, (res) => {   \/\/ ... });  Example using a URL as options: const options = new URL('https:\/\/abc:xyz@example.com');  const req = https.request(options, (res) => {   \/\/ ... });  Example pinning on certificate fingerprint, or the public key (similar to pin-sha256): const tls = require('tls'); const https = require('https'); const crypto = require('crypto');  function sha256(s) {   return crypto.createHash('sha256').update(s).digest('base64'); } const options = {   hostname: 'github.com',   port: 443,   path: '\/',   method: 'GET',   checkServerIdentity: function(host, cert) {     \/\/ Make sure the certificate is issued to the host we are connected to     const err = tls.checkServerIdentity(host, cert);     if (err) {       return err;     }      \/\/ Pin the public key, similar to HPKP pin-sha25 pinning     const pubkey256 = 'pL1+qb9HTMRZJmuC\/bB\/ZI9d302BYrrqiVuRyW+DGrU=';     if (sha256(cert.pubkey) !== pubkey256) {       const msg = 'Certificate verification error: ' +         `The public key of '${cert.subject.CN}' ` +         'does not match our pinned fingerprint';       return new Error(msg);     }      \/\/ Pin the exact certificate, rather than the pub key     const cert256 = '25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:' +       'D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16';     if (cert.fingerprint256 !== cert256) {       const msg = 'Certificate verification error: ' +         `The certificate of '${cert.subject.CN}' ` +         'does not match our pinned fingerprint';       return new Error(msg);     }      \/\/ This loop is informational only.     \/\/ Print the certificate and public key fingerprints of all certs in the     \/\/ chain. Its common to pin the public key of the issuer on the public     \/\/ internet, while pinning the public key of the service in sensitive     \/\/ environments.     do {       console.log('Subject Common Name:', cert.subject.CN);       console.log('  Certificate SHA256 fingerprint:', cert.fingerprint256);        hash = crypto.createHash('sha256');       console.log('  Public key ping-sha256:', sha256(cert.pubkey));        lastprint256 = cert.fingerprint256;       cert = cert.issuerCertificate;     } while (cert.fingerprint256 !== lastprint256);    }, };  options.agent = new https.Agent(options); const req = https.request(options, (res) => {   console.log('All OK. Server matched our pinned cert or public key');   console.log('statusCode:', res.statusCode);   \/\/ Print the HPKP values   console.log('headers:', res.headers['public-key-pins']);    res.on('data', (d) => {}); });  req.on('error', (e) => {   console.error(e.message); }); req.end();  Outputs for example: Subject Common Name: github.com   Certificate SHA256 fingerprint: 25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16   Public key ping-sha256: pL1+qb9HTMRZJmuC\/bB\/ZI9d302BYrrqiVuRyW+DGrU= Subject Common Name: DigiCert SHA2 Extended Validation Server CA   Certificate SHA256 fingerprint: 40:3E:06:2A:26:53:05:91:13:28:5B:AF:80:A0:D4:AE:42:2C:84:8C:9F:78:FA:D0:1F:C9:4B:C5:B8:7F:EF:1A   Public key ping-sha256: RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn\/yOhI\/y+ho= Subject Common Name: DigiCert High Assurance EV Root CA   Certificate SHA256 fingerprint: 74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF   Public key ping-sha256: WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18= All OK. Server matched our pinned cert or public key statusCode: 200 headers: max-age=0; pin-sha256=\"WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=\"; pin-sha256=\"RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn\/yOhI\/y+ho=\"; pin-sha256=\"k2v657xBsOVe1PQRwOsHsw3bsGT2VzIqz5K+59sNQws=\"; pin-sha256=\"K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q=\"; pin-sha256=\"IQBnNBEiFuhj+8x6X8XLgh01V9Ic5\/V3IRQLNFFc7v4=\"; pin-sha256=\"iie1VXtL7HzAMF+\/PVPR9xzT80kQxdZeJ+zduCB3uj0=\"; pin-sha256=\"LvRiGEjRqfzurezaWuj8Wie2gyHMrW5Q06LspMnox7A=\"; includeSubDomains"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspector","title":"Inspector","description":"Source Code: lib\/inspector.js The inspector module provides an API for interacting with the V8 inspector. It can be accessed using: const inspector = require('inspector');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspector_close","title":"`inspector.close()`","description":"Deactivate the inspector. Blocks until there are no active connections."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspector_open_port_host_wait","title":"`inspector.open([port[, host[, wait]]])`","description":"Activate inspector on host and port. Equivalent to node --inspect=[[host:]port], but can be done programmatically after node has started. If wait is true, will block until a client has connected to the inspect port and flow control has been passed to the debugger client. See the security warning regarding the host parameter usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspector_url","title":"`inspector.url()`","description":"Return the URL of the active inspector, or undefined if there is none. $ node --inspect -p 'inspector.url()' Debugger listening on ws:\/\/127.0.0.1:9229\/166e272e-7a30-4d09-97ce-f1c012b43c34 For help see https:\/\/nodejs.org\/en\/docs\/inspector ws:\/\/127.0.0.1:9229\/166e272e-7a30-4d09-97ce-f1c012b43c34  $ node --inspect=localhost:3000 -p 'inspector.url()' Debugger listening on ws:\/\/localhost:3000\/51cf8d0e-3c36-4c59-8efd-54519839e56a For help see https:\/\/nodejs.org\/en\/docs\/inspector ws:\/\/localhost:3000\/51cf8d0e-3c36-4c59-8efd-54519839e56a  $ node -p 'inspector.url()' undefined"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_inspector_waitfordebugger","title":"`inspector.waitForDebugger()`","description":"Blocks until a client (existing or connected later) has sent Runtime.runIfWaitingForDebugger command. An exception will be thrown if there is no active inspector."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_modules_commonjs_modules","title":"Modules: CommonJS modules","description":"In the Node.js module system, each file is treated as a separate module. For example, consider a file named foo.js: const circle = require('.\/circle.js'); console.log(`The area of a circle of radius 4 is ${circle.area(4)}`);  On the first line, foo.js loads the module circle.js that is in the same directory as foo.js. Here are the contents of circle.js: const { PI } = Math;  exports.area = (r) => PI * r ** 2;  exports.circumference = (r) => 2 * PI * r;  The module circle.js has exported the functions area() and circumference(). Functions and objects are added to the root of a module by specifying additional properties on the special exports object. Variables local to the module will be private, because the module is wrapped in a function by Node.js (see module wrapper). In this example, the variable PI is private to circle.js. The module.exports property can be assigned a new value (such as a function or object). Below, bar.js makes use of the square module, which exports a Square class: const Square = require('.\/square.js'); const mySquare = new Square(2); console.log(`The area of mySquare is ${mySquare.area()}`);  The square module is defined in square.js: \/\/ Assigning to exports will not modify module, must use module.exports module.exports = class Square {   constructor(width) {     this.width = width;   }    area() {     return this.width ** 2;   } };  The module system is implemented in the require('module') module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_accessing_the_main_module","title":"Accessing the main module","description":"When a file is run directly from Node.js, require.main is set to its module. That means that it is possible to determine whether a file has been run directly by testing require.main === module. For a file foo.js, this will be true if run via node foo.js, but false if run by require('.\/foo'). Because module provides a filename property (normally equivalent to __filename), the entry point of the current application can be obtained by checking require.main.filename."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_addenda_package_manager_tips","title":"Addenda: Package manager tips","description":"The semantics of the Node.js require() function were designed to be general enough to support reasonable directory structures. Package manager programs such as dpkg, rpm, and npm will hopefully find it possible to build native packages from Node.js modules without modification. Below we give a suggested directory structure that could work: Let's say that we wanted to have the folder at \/usr\/lib\/node\/<some-package>\/<some-version> hold the contents of a specific version of a package. Packages can depend on one another. In order to install package foo, it may be necessary to install a specific version of package bar. The bar package may itself have dependencies, and in some cases, these may even collide or form cyclic dependencies. Because Node.js looks up the realpath of any modules it loads (that is, it resolves symlinks) and then looks for their dependencies in node_modules folders, this situation can be resolved with the following architecture:  \/usr\/lib\/node\/foo\/1.2.3\/: Contents of the foo package, version 1.2.3. \/usr\/lib\/node\/bar\/4.3.2\/: Contents of the bar package that foo depends on. \/usr\/lib\/node\/foo\/1.2.3\/node_modules\/bar: Symbolic link to \/usr\/lib\/node\/bar\/4.3.2\/. \/usr\/lib\/node\/bar\/4.3.2\/node_modules\/*: Symbolic links to the packages that bar depends on.  Thus, even if a cycle is encountered, or if there are dependency conflicts, every module will be able to get a version of its dependency that it can use. When the code in the foo package does require('bar'), it will get the version that is symlinked into \/usr\/lib\/node\/foo\/1.2.3\/node_modules\/bar. Then, when the code in the bar package calls require('quux'), it'll get the version that is symlinked into \/usr\/lib\/node\/bar\/4.3.2\/node_modules\/quux. Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in \/usr\/lib\/node, we could put them in \/usr\/lib\/node_modules\/<name>\/<version>. Then Node.js will not bother looking for missing dependencies in \/usr\/node_modules or \/node_modules. In order to make modules available to the Node.js REPL, it might be useful to also add the \/usr\/lib\/node_modules folder to the $NODE_PATH environment variable. Since the module lookups using node_modules folders are all relative, and based on the real path of the files making the calls to require(), the packages themselves can be anywhere."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_all_together","title":"All together...","description":"To get the exact filename that will be loaded when require() is called, use the require.resolve() function. Putting together all of the above, here is the high-level algorithm in pseudocode of what require() does: require(X) from module at path Y 1. If X is a core module,    a. return the core module    b. STOP 2. If X begins with '\/'    a. set Y to be the filesystem root 3. If X begins with '.\/' or '\/' or '..\/'    a. LOAD_AS_FILE(Y + X)    b. LOAD_AS_DIRECTORY(Y + X)    c. THROW \"not found\" 4. If X begins with '#'    a. LOAD_PACKAGE_IMPORTS(X, dirname(Y)) 5. LOAD_PACKAGE_SELF(X, dirname(Y)) 6. LOAD_NODE_MODULES(X, dirname(Y)) 7. THROW \"not found\"  LOAD_AS_FILE(X) 1. If X is a file, load X as its file extension format. STOP 2. If X.js is a file, load X.js as JavaScript text. STOP 3. If X.json is a file, parse X.json to a JavaScript Object. STOP 4. If X.node is a file, load X.node as binary addon. STOP  LOAD_INDEX(X) 1. If X\/index.js is a file, load X\/index.js as JavaScript text. STOP 2. If X\/index.json is a file, parse X\/index.json to a JavaScript object. STOP 3. If X\/index.node is a file, load X\/index.node as binary addon. STOP  LOAD_AS_DIRECTORY(X) 1. If X\/package.json is a file,    a. Parse X\/package.json, and look for \"main\" field.    b. If \"main\" is a falsy value, GOTO 2.    c. let M = X + (json main field)    d. LOAD_AS_FILE(M)    e. LOAD_INDEX(M)    f. LOAD_INDEX(X) DEPRECATED    g. THROW \"not found\" 2. LOAD_INDEX(X)  LOAD_NODE_MODULES(X, START) 1. let DIRS = NODE_MODULES_PATHS(START) 2. for each DIR in DIRS:    a. LOAD_PACKAGE_EXPORTS(X, DIR)    b. LOAD_AS_FILE(DIR\/X)    c. LOAD_AS_DIRECTORY(DIR\/X)  NODE_MODULES_PATHS(START) 1. let PARTS = path split(START) 2. let I = count of PARTS - 1 3. let DIRS = [GLOBAL_FOLDERS] 4. while I >= 0,    a. if PARTS[I] = \"node_modules\" CONTINUE    b. DIR = path join(PARTS[0 .. I] + \"node_modules\")    c. DIRS = DIRS + DIR    d. let I = I - 1 5. return DIRS  LOAD_PACKAGE_IMPORTS(X, DIR) 1. Find the closest package scope SCOPE to DIR. 2. If no scope was found, return. 3. If the SCOPE\/package.json \"imports\" is null or undefined, return. 4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),   [\"node\", \"require\"]) defined in the ESM resolver. 5. RESOLVE_ESM_MATCH(MATCH).  LOAD_PACKAGE_EXPORTS(X, DIR) 1. Try to interpret X as a combination of NAME and SUBPATH where the name    may have a @scope\/ prefix and the subpath begins with a slash (`\/`). 2. If X does not match this pattern or DIR\/NAME\/package.json is not a file,    return. 3. Parse DIR\/NAME\/package.json, and look for \"exports\" field. 4. If \"exports\" is null or undefined, return. 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR\/NAME), \".\" + SUBPATH,    `package.json` \"exports\", [\"node\", \"require\"]) defined in the ESM resolver. 6. RESOLVE_ESM_MATCH(MATCH)  LOAD_PACKAGE_SELF(X, DIR) 1. Find the closest package scope SCOPE to DIR. 2. If no scope was found, return. 3. If the SCOPE\/package.json \"exports\" is null or undefined, return. 4. If the SCOPE\/package.json \"name\" is not the first segment of X, return. 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),    \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"])    defined in the ESM resolver. 6. RESOLVE_ESM_MATCH(MATCH)  RESOLVE_ESM_MATCH(MATCH) 1. let { RESOLVED, EXACT } = MATCH 2. let RESOLVED_PATH = fileURLToPath(RESOLVED) 3. If EXACT is true,    a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension       format. STOP 4. Otherwise, if EXACT is false,    a. LOAD_AS_FILE(RESOLVED_PATH)    b. LOAD_AS_DIRECTORY(RESOLVED_PATH) 5. THROW \"not found\""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_caching","title":"Caching","description":"Modules are cached after the first time they are loaded. This means (among other things) that every call to require('foo') will get exactly the same object returned, if it would resolve to the same file. Provided require.cache is not modified, multiple calls to require('foo') will not cause the module code to be executed multiple times. This is an important feature. With it, \"partially done\" objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles. To have a module execute code multiple times, export a function, and call that function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_caching_caveats","title":"Module caching caveats","description":"Modules are cached based on their resolved filename. Since modules may resolve to a different filename based on the location of the calling module (loading from node_modules folders), it is not a guarantee that require('foo') will always return the exact same object, if it would resolve to different files. Additionally, on case-insensitive file systems or operating systems, different resolved filenames can point to the same file, but the cache will still treat them as different modules and will reload the file multiple times. For example, require('.\/foo') and require('.\/FOO') return two different objects, irrespective of whether or not .\/foo and .\/FOO are the same file."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_core_modules","title":"Core modules","description":"Node.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation. The core modules are defined within the Node.js source and are located in the lib\/ folder. Core modules are always preferentially loaded if their identifier is passed to require(). For instance, require('http') will always return the built in HTTP module, even if there is a file by that name."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cycles","title":"Cycles","description":"When there are circular require() calls, a module might not have finished executing when it is returned. Consider this situation: a.js: console.log('a starting'); exports.done = false; const b = require('.\/b.js'); console.log('in a, b.done = %j', b.done); exports.done = true; console.log('a done');  b.js: console.log('b starting'); exports.done = false; const a = require('.\/a.js'); console.log('in b, a.done = %j', a.done); exports.done = true; console.log('b done');  main.js: console.log('main starting'); const a = require('.\/a.js'); const b = require('.\/b.js'); console.log('in main, a.done = %j, b.done = %j', a.done, b.done);  When main.js loads a.js, then a.js in turn loads b.js. At that point, b.js tries to load a.js. In order to prevent an infinite loop, an unfinished copy of the a.js exports object is returned to the b.js module. b.js then finishes loading, and its exports object is provided to the a.js module. By the time main.js has loaded both modules, they're both finished. The output of this program would thus be: $ node main.js main starting a starting b starting in b, a.done = false b done in a, b.done = true a done in main, a.done = true, b.done = true  Careful planning is required to allow cyclic module dependencies to work correctly within an application."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_file_modules","title":"File modules","description":"If the exact filename is not found, then Node.js will attempt to load the required filename with the added extensions: .js, .json, and finally .node. .js files are interpreted as JavaScript text files, and .json files are parsed as JSON text files. .node files are interpreted as compiled addon modules loaded with process.dlopen(). A required module prefixed with '\/' is an absolute path to the file. For example, require('\/home\/marco\/foo.js') will load the file at \/home\/marco\/foo.js. A required module prefixed with '.\/' is relative to the file calling require(). That is, circle.js must be in the same directory as foo.js for require('.\/circle') to find it. Without a leading '\/', '.\/', or '..\/' to indicate a file, the module must either be a core module or is loaded from a node_modules folder. If the given path does not exist, require() will throw an Error with its code property set to 'MODULE_NOT_FOUND'."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_folders_as_modules","title":"Folders as modules","description":"It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to those directories. There are three ways in which a folder may be passed to require() as an argument. The first is to create a package.json file in the root of the folder, which specifies a main module. An example package.json file might look like this: { \"name\" : \"some-library\",   \"main\" : \".\/lib\/some-library.js\" }  If this was in a folder at .\/some-library, then require('.\/some-library') would attempt to load .\/some-library\/lib\/some-library.js. This is the extent of the awareness of package.json files within Node.js. If there is no package.json file present in the directory, or if the \"main\" entry is missing or cannot be resolved, then Node.js will attempt to load an index.js or index.node file out of that directory. For example, if there was no package.json file in the previous example, then require('.\/some-library') would attempt to load:  .\/some-library\/index.js .\/some-library\/index.node  If these attempts fail, then Node.js will report the entire module as missing with the default error: Error: Cannot find module 'some-library'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_loading_from_node_modules_folders","title":"Loading from `node_modules` folders","description":"If the module identifier passed to require() is not a core module, and does not begin with '\/', '..\/', or '.\/', then Node.js starts at the parent directory of the current module, and adds \/node_modules, and attempts to load the module from that location. Node.js will not append node_modules to a path already ending in node_modules. If it is not found there, then it moves to the parent directory, and so on, until the root of the file system is reached. For example, if the file at '\/home\/ry\/projects\/foo.js' called require('bar.js'), then Node.js would look in the following locations, in this order:  \/home\/ry\/projects\/node_modules\/bar.js \/home\/ry\/node_modules\/bar.js \/home\/node_modules\/bar.js \/node_modules\/bar.js  This allows programs to localize their dependencies, so that they do not clash. It is possible to require specific files or sub modules distributed with a module by including a path suffix after the module name. For instance require('example-module\/path\/to\/file') would resolve path\/to\/file relative to where example-module is located. The suffixed path follows the same module resolution semantics."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_loading_from_the_global_folders","title":"Loading from the global folders","description":"If the NODE_PATH environment variable is set to a colon-delimited list of absolute paths, then Node.js will search those paths for modules if they are not found elsewhere. On Windows, NODE_PATH is delimited by semicolons (;) instead of colons. NODE_PATH was originally created to support loading modules from varying paths before the current module resolution algorithm was defined. NODE_PATH is still supported, but is less necessary now that the Node.js ecosystem has settled on a convention for locating dependent modules. Sometimes deployments that rely on NODE_PATH show surprising behavior when people are unaware that NODE_PATH must be set. Sometimes a module's dependencies change, causing a different version (or even a different module) to be loaded as the NODE_PATH is searched. Additionally, Node.js will search in the following list of GLOBAL_FOLDERS:  1: $HOME\/.node_modules 2: $HOME\/.node_libraries 3: $PREFIX\/lib\/node  Where $HOME is the user's home directory, and $PREFIX is the Node.js configured node_prefix. These are mostly for historic reasons. It is strongly encouraged to place dependencies in the local node_modules folder. These will be loaded faster, and more reliably."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_module_wrapper","title":"The module wrapper","description":"Before a module's code is executed, Node.js will wrap it with a function wrapper that looks like the following: (function(exports, require, module, __filename, __dirname) { \/\/ Module code actually lives in here });  By doing this, Node.js achieves a few things:  It keeps top-level variables (defined with var, const or let) scoped to the module rather than the global object. It helps to provide some global-looking variables that are actually specific to the module, such as:  The module and exports objects that the implementor can use to export values from the module. The convenience variables __filename and __dirname, containing the module's absolute filename and directory path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_module_object","title":"The `module` object","description":"<Object>  In each module, the module free variable is a reference to the object representing the current module. For convenience, module.exports is also accessible via the exports module-global. module is not actually a global but rather local to each module."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_require_id","title":"`module.require(id)`","description":"The module.require() method provides a way to load a module as if require() was called from the original module. In order to do this, it is necessary to get a reference to the module object. Since require() returns the module.exports, and the module is typically only available within a specific module's code, it must be explicitly exported in order to be used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_addenda_the_mjs_extension","title":"Addenda: The `.mjs` extension","description":"It is not possible to require() files that have the .mjs extension. Attempting to do so will throw an error. The .mjs extension is reserved for ECMAScript Modules which cannot be loaded via require(). See ECMAScript Modules for more details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_module_scope","title":"The module scope","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all__dirname","title":"`__dirname`","description":"<string>  The directory name of the current module. This is the same as the path.dirname() of the __filename. Example: running node example.js from \/Users\/mjr console.log(__dirname); \/\/ Prints: \/Users\/mjr console.log(path.dirname(__filename)); \/\/ Prints: \/Users\/mjr"},{"url":"http:\/\/nodejs.org\/api\/all.html#all__filename","title":"`__filename`","description":"<string>  The file name of the current module. This is the current module file's absolute path with symlinks resolved. For a main program this is not necessarily the same as the file name used in the command line. See __dirname for the directory name of the current module. Examples: Running node example.js from \/Users\/mjr console.log(__filename); \/\/ Prints: \/Users\/mjr\/example.js console.log(__dirname); \/\/ Prints: \/Users\/mjr  Given two modules: a and b, where b is a dependency of a and there is a directory structure of:  \/Users\/mjr\/app\/a.js \/Users\/mjr\/app\/node_modules\/b\/b.js  References to __filename within b.js will return \/Users\/mjr\/app\/node_modules\/b\/b.js while references to __filename within a.js will return \/Users\/mjr\/app\/a.js."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exports","title":"`exports`","description":"<Object>  A reference to the module.exports that is shorter to type. See the section about the exports shortcut for details on when to use exports and when to use module.exports."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module","title":"`module`","description":"<module>  A reference to the current module, see the section about the module object. In particular, module.exports is used for defining what a module exports and makes available through require()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require_id","title":"`require(id)`","description":"id <string> module name or path Returns: <any> exported module content  Used to import modules, JSON, and local files. Modules can be imported from node_modules. Local modules and JSON files can be imported using a relative path (e.g. .\/, .\/foo, .\/bar\/baz, ..\/foo) that will be resolved against the directory named by __dirname (if defined) or the current working directory. The relative paths of POSIX style are resolved in an OS independent fashion, meaning that the examples above will work on Windows in the same way they would on Unix systems. \/\/ Importing a local module with a path relative to the `__dirname` or current \/\/ working directory. (On Windows, this would resolve to .\\path\\myLocalModule.) const myLocalModule = require('.\/path\/myLocalModule');  \/\/ Importing a JSON file: const jsonData = require('.\/path\/filename.json');  \/\/ Importing a module from node_modules or Node.js built-in module: const crypto = require('crypto');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require_resolve_request_options","title":"`require.resolve(request[, options])`","description":"Use the internal require() machinery to look up the location of a module, but rather than loading the module, just return the resolved filename. If the module can not be found, a MODULE_NOT_FOUND error is thrown."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_require_resolve_paths_request","title":"`require.resolve.paths(request)`","description":"Returns an array containing the paths searched during resolution of request or null if the request string references a core module, for example http or fs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_module_object","title":"The `Module` object","description":"This section was moved to Modules: module core module.   module.builtinModules module.createRequire(filename) module.createRequireFromPath(filename) module.syncBuiltinESMExports()"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_source_map_v3_support","title":"Source map v3 support","description":"This section was moved to Modules: module core module.   module.findSourceMap(path) Class: module.SourceMap  new SourceMap(payload) sourceMap.payload sourceMap.findEntry(lineNumber, columnNumber)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_modules_module_api","title":"Modules: `module` API","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_module_object","title":"The `Module` object","description":"<Object>  Provides general utility methods when interacting with instances of Module, the module variable often seen in CommonJS modules. Accessed via import 'module' or require('module')."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_createrequire_filename","title":"`module.createRequire(filename)`","description":"import { createRequire } from 'module'; const require = createRequire(import.meta.url);  \/\/ sibling-module.js is a CommonJS module. const siblingModule = require('.\/sibling-module');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_createrequirefrompath_filename","title":"`module.createRequireFromPath(filename)`","description":"const { createRequireFromPath } = require('module'); const requireUtil = createRequireFromPath('..\/src\/utils\/');  \/\/ Require `..\/src\/utils\/some-tool` requireUtil('.\/some-tool');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_syncbuiltinesmexports","title":"`module.syncBuiltinESMExports()`","description":"The module.syncBuiltinESMExports() method updates all the live bindings for builtin ES Modules to match the properties of the CommonJS exports. It does not add or remove exported names from the ES Modules. const fs = require('fs'); const { syncBuiltinESMExports } = require('module');  fs.readFile = null;  delete fs.readFileSync;  fs.newAPI = function newAPI() {   \/\/ ... };  syncBuiltinESMExports();  import('fs').then((esmFS) => {   assert.strictEqual(esmFS.readFile, null);   assert.strictEqual('readFileSync' in fs, true);   assert.strictEqual(esmFS.newAPI, undefined); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_source_map_v3_support","title":"Source map v3 support","description":"Helpers for interacting with the source map cache. This cache is populated when source map parsing is enabled and source map include directives are found in a modules' footer. To enable source map parsing, Node.js must be run with the flag --enable-source-maps, or with code coverage enabled by setting NODE_V8_COVERAGE=dir. \/\/ module.mjs \/\/ In an ECMAScript module import { findSourceMap, SourceMap } from 'module';  \/\/ module.cjs \/\/ In a CommonJS module const { findSourceMap, SourceMap } = require('module');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_module_findsourcemap_path","title":"`module.findSourceMap(path)`","description":"path is the resolved path for the file for which a corresponding source map should be fetched."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net","title":"Net","description":"Stability: 2 - Stable  Source Code: lib\/net.js The net module provides an asynchronous network API for creating stream-based TCP or IPC servers (net.createServer()) and clients (net.createConnection()). It can be accessed using: const net = require('net');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_connect","title":"`net.connect()`","description":"Aliases to net.createConnection(). Possible signatures:  net.connect(options[, connectListener]) net.connect(path[, connectListener]) for IPC connections. net.connect(port[, host][, connectListener]) for TCP connections."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_connect_options_connectlistener","title":"`net.connect(options[, connectListener])`","description":"Alias to net.createConnection(options[, connectListener])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_connect_path_connectlistener","title":"`net.connect(path[, connectListener])`","description":"Alias to net.createConnection(path[, connectListener])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_connect_port_host_connectlistener","title":"`net.connect(port[, host][, connectListener])`","description":"Alias to net.createConnection(port[, host][, connectListener])."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createconnection","title":"`net.createConnection()`","description":"A factory function, which creates a new net.Socket, immediately initiates connection with socket.connect(), then returns the net.Socket that starts the connection. When the connection is established, a 'connect' event will be emitted on the returned socket. The last parameter connectListener, if supplied, will be added as a listener for the 'connect' event once. Possible signatures:  net.createConnection(options[, connectListener]) net.createConnection(path[, connectListener]) for IPC connections. net.createConnection(port[, host][, connectListener]) for TCP connections.  The net.connect() function is an alias to this function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createconnection_options_connectlistener","title":"`net.createConnection(options[, connectListener])`","description":"For available options, see new net.Socket([options]) and socket.connect(options[, connectListener]). Additional options:  timeout <number> If set, will be used to call socket.setTimeout(timeout) after the socket is created, but before it starts the connection.  Following is an example of a client of the echo server described in the net.createServer() section: const net = require('net'); const client = net.createConnection({ port: 8124 }, () => {   \/\/ 'connect' listener.   console.log('connected to server!');   client.write('world!\\r\\n'); }); client.on('data', (data) => {   console.log(data.toString());   client.end(); }); client.on('end', () => {   console.log('disconnected from server'); });  To connect on the socket \/tmp\/echo.sock: const client = net.createConnection({ path: '\/tmp\/echo.sock' });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createconnection_path_connectlistener","title":"`net.createConnection(path[, connectListener])`","description":"Initiates an IPC connection. This function creates a new net.Socket with all options set to default, immediately initiates connection with socket.connect(path[, connectListener]), then returns the net.Socket that starts the connection."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createconnection_port_host_connectlistener","title":"`net.createConnection(port[, host][, connectListener])`","description":"Initiates a TCP connection. This function creates a new net.Socket with all options set to default, immediately initiates connection with socket.connect(port[, host][, connectListener]), then returns the net.Socket that starts the connection."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createquicsocket_options","title":"`net.createQuicSocket([options])`","description":"Creates and returns a new QuicSocket. Please refer to the QUIC documentation for details."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createserver_options_connectionlistener","title":"`net.createServer([options][, connectionListener])`","description":"Creates a new TCP or IPC server. If allowHalfOpen is set to true, when the other end of the socket sends a FIN packet, the server will only send a FIN packet back when socket.end() is explicitly called, until then the connection is half-closed (non-readable but still writable). See 'end' event and RFC 1122 (section 4.2.2.13) for more information. If pauseOnConnect is set to true, then the socket associated with each incoming connection will be paused, and no data will be read from its handle. This allows connections to be passed between processes without any data being read by the original process. To begin reading data from a paused socket, call socket.resume(). The server can be a TCP server or an IPC server, depending on what it listen() to. Here is an example of an TCP echo server which listens for connections on port 8124: const net = require('net'); const server = net.createServer((c) => {   \/\/ 'connection' listener.   console.log('client connected');   c.on('end', () => {     console.log('client disconnected');   });   c.write('hello\\r\\n');   c.pipe(c); }); server.on('error', (err) => {   throw err; }); server.listen(8124, () => {   console.log('server bound'); });  Test this by using telnet: $ telnet localhost 8124  To listen on the socket \/tmp\/echo.sock: server.listen('\/tmp\/echo.sock', () => {   console.log('server bound'); });  Use nc to connect to a Unix domain socket server: $ nc -U \/tmp\/echo.sock"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_isip_input","title":"`net.isIP(input)`","description":"Tests if input is an IP address. Returns 0 for invalid strings, returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_isipv4_input","title":"`net.isIPv4(input)`","description":"Returns true if input is a version 4 IP address, otherwise returns false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_isipv6_input","title":"`net.isIPv6(input)`","description":"Returns true if input is a version 6 IP address, otherwise returns false."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_ipc_support","title":"IPC support","description":"The net module supports IPC with named pipes on Windows, and Unix domain sockets on other operating systems."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_identifying_paths_for_ipc_connections","title":"Identifying paths for IPC connections","description":"net.connect(), net.createConnection(), server.listen() and socket.connect() take a path parameter to identify IPC endpoints. On Unix, the local domain is also known as the Unix domain. The path is a filesystem pathname. It gets truncated to an OS-dependent length of sizeof(sockaddr_un.sun_path) - 1. Typical values are 107 bytes on Linux and 103 bytes on macOS. If a Node.js API abstraction creates the Unix domain socket, it will unlink the Unix domain socket as well. For example, net.createServer() may create a Unix domain socket and server.close() will unlink it. But if a user creates the Unix domain socket outside of these abstractions, the user will need to remove it. The same applies when a Node.js API creates a Unix domain socket but the program then crashes. In short, a Unix domain socket will be visible in the filesystem and will persist until unlinked. On Windows, the local domain is implemented using a named pipe. The path must refer to an entry in \\\\?\\pipe\\ or \\\\.\\pipe\\. Any characters are permitted, but the latter may do some processing of pipe names, such as resolving .. sequences. Despite how it might look, the pipe namespace is flat. Pipes will not persist. They are removed when the last reference to them is closed. Unlike Unix domain sockets, Windows will close and remove the pipe when the owning process exits. JavaScript string escaping requires paths to be specified with extra backslash escaping such as: net.createServer().listen(   path.join('\\\\\\\\?\\\\pipe', process.cwd(), 'myctl'));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os","title":"OS","description":"Source Code: lib\/os.js The os module provides operating system-related utility methods and properties. It can be accessed using: const os = require('os');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_arch","title":"`os.arch()`","description":"Returns the operating system CPU architecture for which the Node.js binary was compiled. Possible values are 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'. The return value is equivalent to process.arch."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_cpus","title":"`os.cpus()`","description":"Returns an array of objects containing information about each logical CPU core. The properties included on each object include:  model <string> speed <number> (in MHz) times <Object>  user <number> The number of milliseconds the CPU has spent in user mode. nice <number> The number of milliseconds the CPU has spent in nice mode. sys <number> The number of milliseconds the CPU has spent in sys mode. idle <number> The number of milliseconds the CPU has spent in idle mode. irq <number> The number of milliseconds the CPU has spent in irq mode.     [   {     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',     speed: 2926,     times: {       user: 252020,       nice: 0,       sys: 30340,       idle: 1070356870,       irq: 0     }   },   {     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',     speed: 2926,     times: {       user: 306960,       nice: 0,       sys: 26980,       idle: 1071569080,       irq: 0     }   },   {     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',     speed: 2926,     times: {       user: 248450,       nice: 0,       sys: 21750,       idle: 1070919370,       irq: 0     }   },   {     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',     speed: 2926,     times: {       user: 256880,       nice: 0,       sys: 19430,       idle: 1070905480,       irq: 20     }   } ]  nice values are POSIX-only. On Windows, the nice values of all processors are always 0."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_endianness","title":"`os.endianness()`","description":"Returns a string identifying the endianness of the CPU for which the Node.js binary was compiled. Possible values are 'BE' for big endian and 'LE' for little endian."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_freemem","title":"`os.freemem()`","description":"Returns the amount of free system memory in bytes as an integer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_getpriority_pid","title":"`os.getPriority([pid])`","description":"Returns the scheduling priority for the process specified by pid. If pid is not provided or is 0, the priority of the current process is returned."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_homedir","title":"`os.homedir()`","description":"Returns the string path of the current user's home directory. On POSIX, it uses the $HOME environment variable if defined. Otherwise it uses the effective UID to look up the user's home directory. On Windows, it uses the USERPROFILE environment variable if defined. Otherwise it uses the path to the profile directory of the current user."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_hostname","title":"`os.hostname()`","description":"Returns the host name of the operating system as a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_loadavg","title":"`os.loadavg()`","description":"Returns an array containing the 1, 5, and 15 minute load averages. The load average is a measure of system activity calculated by the operating system and expressed as a fractional number. The load average is a Unix-specific concept. On Windows, the return value is always [0, 0, 0]."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_networkinterfaces","title":"`os.networkInterfaces()`","description":"Returns an object containing network interfaces that have been assigned a network address. Each key on the returned object identifies a network interface. The associated value is an array of objects that each describe an assigned network address. The properties available on the assigned network address object include:  address <string> The assigned IPv4 or IPv6 address netmask <string> The IPv4 or IPv6 network mask family <string> Either IPv4 or IPv6 mac <string> The MAC address of the network interface internal <boolean> true if the network interface is a loopback or similar interface that is not remotely accessible; otherwise false scopeid <number> The numeric IPv6 scope ID (only specified when family is IPv6) cidr <string> The assigned IPv4 or IPv6 address with the routing prefix in CIDR notation. If the netmask is invalid, this property is set to null.   {   lo: [     {       address: '127.0.0.1',       netmask: '255.0.0.0',       family: 'IPv4',       mac: '00:00:00:00:00:00',       internal: true,       cidr: '127.0.0.1\/8'     },     {       address: '::1',       netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',       family: 'IPv6',       mac: '00:00:00:00:00:00',       scopeid: 0,       internal: true,       cidr: '::1\/128'     }   ],   eth0: [     {       address: '192.168.1.108',       netmask: '255.255.255.0',       family: 'IPv4',       mac: '01:02:03:0a:0b:0c',       internal: false,       cidr: '192.168.1.108\/24'     },     {       address: 'fe80::a00:27ff:fe4e:66a1',       netmask: 'ffff:ffff:ffff:ffff::',       family: 'IPv6',       mac: '01:02:03:0a:0b:0c',       scopeid: 1,       internal: false,       cidr: 'fe80::a00:27ff:fe4e:66a1\/64'     }   ] }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_platform","title":"`os.platform()`","description":"Returns a string identifying the operating system platform. The value is set at compile time. Possible values are 'aix', 'darwin', 'freebsd', 'linux', 'openbsd', 'sunos', and 'win32'. The return value is equivalent to process.platform. The value 'android' may also be returned if Node.js is built on the Android operating system. Android support is experimental."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_release","title":"`os.release()`","description":"Returns the operating system as a string. On POSIX systems, the operating system release is determined by calling uname(3). On Windows, GetVersionExW() is used. See https:\/\/en.wikipedia.org\/wiki\/Uname#Examples for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_setpriority_pid_priority","title":"`os.setPriority([pid, ]priority)`","description":"Attempts to set the scheduling priority for the process specified by pid. If pid is not provided or is 0, the process ID of the current process is used. The priority input must be an integer between -20 (high priority) and 19 (low priority). Due to differences between Unix priority levels and Windows priority classes, priority is mapped to one of six priority constants in os.constants.priority. When retrieving a process priority level, this range mapping may cause the return value to be slightly different on Windows. To avoid confusion, set priority to one of the priority constants. On Windows, setting priority to PRIORITY_HIGHEST requires elevated user privileges. Otherwise the set priority will be silently reduced to PRIORITY_HIGH."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_tmpdir","title":"`os.tmpdir()`","description":"Returns the operating system's default directory for temporary files as a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_totalmem","title":"`os.totalmem()`","description":"Returns the total amount of system memory in bytes as an integer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_type","title":"`os.type()`","description":"Returns the operating system name as returned by uname(3). For example, it returns 'Linux' on Linux, 'Darwin' on macOS, and 'Windows_NT' on Windows. See https:\/\/en.wikipedia.org\/wiki\/Uname#Examples for additional information about the output of running uname(3) on various operating systems."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_uptime","title":"`os.uptime()`","description":"Returns the system uptime in number of seconds."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_userinfo_options","title":"`os.userInfo([options])`","description":"Returns information about the currently effective user. On POSIX platforms, this is typically a subset of the password file. The returned object includes the username, uid, gid, shell, and homedir. On Windows, the uid and gid fields are -1, and shell is null. The value of homedir returned by os.userInfo() is provided by the operating system. This differs from the result of os.homedir(), which queries environment variables for the home directory before falling back to the operating system response. Throws a SystemError if a user has no username or homedir."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_version","title":"`os.version()`","description":"Returns a string identifying the kernel version. On POSIX systems, the operating system release is determined by calling uname(3). On Windows, RtlGetVersion() is used, and if it is not available, GetVersionExW() will be used. See https:\/\/en.wikipedia.org\/wiki\/Uname#Examples for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_os_constants","title":"OS constants","description":"The following constants are exported by os.constants. Not all constants will be available on every operating system."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_signal_constants","title":"Signal constants","description":"The following signal constants are exported by os.constants.signals.         Constant     Description           SIGHUP     Sent to indicate when a controlling terminal is closed or a parent     process exits.           SIGINT     Sent to indicate when a user wishes to interrupt a process     (Ctrl+C).           SIGQUIT     Sent to indicate when a user wishes to terminate a process and perform a     core dump.           SIGILL     Sent to a process to notify that it has attempted to perform an illegal,     malformed, unknown, or privileged instruction.           SIGTRAP     Sent to a process when an exception has occurred.           SIGABRT     Sent to a process to request that it abort.           SIGIOT     Synonym for SIGABRT           SIGBUS     Sent to a process to notify that it has caused a bus error.           SIGFPE     Sent to a process to notify that it has performed an illegal arithmetic     operation.           SIGKILL     Sent to a process to terminate it immediately.           SIGUSR1 SIGUSR2     Sent to a process to identify user-defined conditions.           SIGSEGV     Sent to a process to notify of a segmentation fault.           SIGPIPE     Sent to a process when it has attempted to write to a disconnected     pipe.           SIGALRM     Sent to a process when a system timer elapses.           SIGTERM     Sent to a process to request termination.           SIGCHLD     Sent to a process when a child process terminates.           SIGSTKFLT     Sent to a process to indicate a stack fault on a coprocessor.           SIGCONT     Sent to instruct the operating system to continue a paused process.           SIGSTOP     Sent to instruct the operating system to halt a process.           SIGTSTP     Sent to a process to request it to stop.           SIGBREAK     Sent to indicate when a user wishes to interrupt a process.           SIGTTIN     Sent to a process when it reads from the TTY while in the     background.           SIGTTOU     Sent to a process when it writes to the TTY while in the     background.           SIGURG     Sent to a process when a socket has urgent data to read.           SIGXCPU     Sent to a process when it has exceeded its limit on CPU usage.           SIGXFSZ     Sent to a process when it grows a file larger than the maximum     allowed.           SIGVTALRM     Sent to a process when a virtual timer has elapsed.           SIGPROF     Sent to a process when a system timer has elapsed.           SIGWINCH     Sent to a process when the controlling terminal has changed its     size.           SIGIO     Sent to a process when I\/O is available.           SIGPOLL     Synonym for SIGIO           SIGLOST     Sent to a process when a file lock has been lost.           SIGPWR     Sent to a process to notify of a power failure.           SIGINFO     Synonym for SIGPWR           SIGSYS     Sent to a process to notify of a bad argument.           SIGUNUSED     Synonym for SIGSYS"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_error_constants","title":"Error constants","description":"The following error constants are exported by os.constants.errno."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_posix_error_constants","title":"POSIX error constants","description":"Constant     Description           E2BIG     Indicates that the list of arguments is longer than expected.           EACCES     Indicates that the operation did not have sufficient permissions.           EADDRINUSE     Indicates that the network address is already in use.           EADDRNOTAVAIL     Indicates that the network address is currently unavailable for     use.           EAFNOSUPPORT     Indicates that the network address family is not supported.           EAGAIN     Indicates that there is no data available and to try the     operation again later.           EALREADY     Indicates that the socket already has a pending connection in     progress.           EBADF     Indicates that a file descriptor is not valid.           EBADMSG     Indicates an invalid data message.           EBUSY     Indicates that a device or resource is busy.           ECANCELED     Indicates that an operation was canceled.           ECHILD     Indicates that there are no child processes.           ECONNABORTED     Indicates that the network connection has been aborted.           ECONNREFUSED     Indicates that the network connection has been refused.           ECONNRESET     Indicates that the network connection has been reset.           EDEADLK     Indicates that a resource deadlock has been avoided.           EDESTADDRREQ     Indicates that a destination address is required.           EDOM     Indicates that an argument is out of the domain of the function.           EDQUOT     Indicates that the disk quota has been exceeded.           EEXIST     Indicates that the file already exists.           EFAULT     Indicates an invalid pointer address.           EFBIG     Indicates that the file is too large.           EHOSTUNREACH     Indicates that the host is unreachable.           EIDRM     Indicates that the identifier has been removed.           EILSEQ     Indicates an illegal byte sequence.           EINPROGRESS     Indicates that an operation is already in progress.           EINTR     Indicates that a function call was interrupted.           EINVAL     Indicates that an invalid argument was provided.           EIO     Indicates an otherwise unspecified I\/O error.           EISCONN     Indicates that the socket is connected.           EISDIR     Indicates that the path is a directory.           ELOOP     Indicates too many levels of symbolic links in a path.           EMFILE     Indicates that there are too many open files.           EMLINK     Indicates that there are too many hard links to a file.           EMSGSIZE     Indicates that the provided message is too long.           EMULTIHOP     Indicates that a multihop was attempted.           ENAMETOOLONG     Indicates that the filename is too long.           ENETDOWN     Indicates that the network is down.           ENETRESET     Indicates that the connection has been aborted by the network.           ENETUNREACH     Indicates that the network is unreachable.           ENFILE     Indicates too many open files in the system.           ENOBUFS     Indicates that no buffer space is available.           ENODATA     Indicates that no message is available on the stream head read     queue.           ENODEV     Indicates that there is no such device.           ENOENT     Indicates that there is no such file or directory.           ENOEXEC     Indicates an exec format error.           ENOLCK     Indicates that there are no locks available.           ENOLINK     Indications that a link has been severed.           ENOMEM     Indicates that there is not enough space.           ENOMSG     Indicates that there is no message of the desired type.           ENOPROTOOPT     Indicates that a given protocol is not available.           ENOSPC     Indicates that there is no space available on the device.           ENOSR     Indicates that there are no stream resources available.           ENOSTR     Indicates that a given resource is not a stream.           ENOSYS     Indicates that a function has not been implemented.           ENOTCONN     Indicates that the socket is not connected.           ENOTDIR     Indicates that the path is not a directory.           ENOTEMPTY     Indicates that the directory is not empty.           ENOTSOCK     Indicates that the given item is not a socket.           ENOTSUP     Indicates that a given operation is not supported.           ENOTTY     Indicates an inappropriate I\/O control operation.           ENXIO     Indicates no such device or address.           EOPNOTSUPP     Indicates that an operation is not supported on the socket. Although     ENOTSUP and EOPNOTSUPP have the same value     on Linux, according to POSIX.1 these error values should be distinct.)           EOVERFLOW     Indicates that a value is too large to be stored in a given data     type.           EPERM     Indicates that the operation is not permitted.           EPIPE     Indicates a broken pipe.           EPROTO     Indicates a protocol error.           EPROTONOSUPPORT     Indicates that a protocol is not supported.           EPROTOTYPE     Indicates the wrong type of protocol for a socket.           ERANGE     Indicates that the results are too large.           EROFS     Indicates that the file system is read only.           ESPIPE     Indicates an invalid seek operation.           ESRCH     Indicates that there is no such process.           ESTALE     Indicates that the file handle is stale.           ETIME     Indicates an expired timer.           ETIMEDOUT     Indicates that the connection timed out.           ETXTBSY     Indicates that a text file is busy.           EWOULDBLOCK     Indicates that the operation would block.           EXDEV     Indicates an improper link."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_windows_specific_error_constants","title":"Windows-specific error constants","description":"The following error codes are specific to the Windows operating system.         Constant     Description           WSAEINTR     Indicates an interrupted function call.           WSAEBADF     Indicates an invalid file handle.           WSAEACCES     Indicates insufficient permissions to complete the operation.           WSAEFAULT     Indicates an invalid pointer address.           WSAEINVAL     Indicates that an invalid argument was passed.           WSAEMFILE     Indicates that there are too many open files.           WSAEWOULDBLOCK     Indicates that a resource is temporarily unavailable.           WSAEINPROGRESS     Indicates that an operation is currently in progress.           WSAEALREADY     Indicates that an operation is already in progress.           WSAENOTSOCK     Indicates that the resource is not a socket.           WSAEDESTADDRREQ     Indicates that a destination address is required.           WSAEMSGSIZE     Indicates that the message size is too long.           WSAEPROTOTYPE     Indicates the wrong protocol type for the socket.           WSAENOPROTOOPT     Indicates a bad protocol option.           WSAEPROTONOSUPPORT     Indicates that the protocol is not supported.           WSAESOCKTNOSUPPORT     Indicates that the socket type is not supported.           WSAEOPNOTSUPP     Indicates that the operation is not supported.           WSAEPFNOSUPPORT     Indicates that the protocol family is not supported.           WSAEAFNOSUPPORT     Indicates that the address family is not supported.           WSAEADDRINUSE     Indicates that the network address is already in use.           WSAEADDRNOTAVAIL     Indicates that the network address is not available.           WSAENETDOWN     Indicates that the network is down.           WSAENETUNREACH     Indicates that the network is unreachable.           WSAENETRESET     Indicates that the network connection has been reset.           WSAECONNABORTED     Indicates that the connection has been aborted.           WSAECONNRESET     Indicates that the connection has been reset by the peer.           WSAENOBUFS     Indicates that there is no buffer space available.           WSAEISCONN     Indicates that the socket is already connected.           WSAENOTCONN     Indicates that the socket is not connected.           WSAESHUTDOWN     Indicates that data cannot be sent after the socket has been     shutdown.           WSAETOOMANYREFS     Indicates that there are too many references.           WSAETIMEDOUT     Indicates that the connection has timed out.           WSAECONNREFUSED     Indicates that the connection has been refused.           WSAELOOP     Indicates that a name cannot be translated.           WSAENAMETOOLONG     Indicates that a name was too long.           WSAEHOSTDOWN     Indicates that a network host is down.           WSAEHOSTUNREACH     Indicates that there is no route to a network host.           WSAENOTEMPTY     Indicates that the directory is not empty.           WSAEPROCLIM     Indicates that there are too many processes.           WSAEUSERS     Indicates that the user quota has been exceeded.           WSAEDQUOT     Indicates that the disk quota has been exceeded.           WSAESTALE     Indicates a stale file handle reference.           WSAEREMOTE     Indicates that the item is remote.           WSASYSNOTREADY     Indicates that the network subsystem is not ready.           WSAVERNOTSUPPORTED     Indicates that the winsock.dll version is out of     range.           WSANOTINITIALISED     Indicates that successful WSAStartup has not yet been performed.           WSAEDISCON     Indicates that a graceful shutdown is in progress.           WSAENOMORE     Indicates that there are no more results.           WSAECANCELLED     Indicates that an operation has been canceled.           WSAEINVALIDPROCTABLE     Indicates that the procedure call table is invalid.           WSAEINVALIDPROVIDER     Indicates an invalid service provider.           WSAEPROVIDERFAILEDINIT     Indicates that the service provider failed to initialized.           WSASYSCALLFAILURE     Indicates a system call failure.           WSASERVICE_NOT_FOUND     Indicates that a service was not found.           WSATYPE_NOT_FOUND     Indicates that a class type was not found.           WSA_E_NO_MORE     Indicates that there are no more results.           WSA_E_CANCELLED     Indicates that the call was canceled.           WSAEREFUSED     Indicates that a database query was refused."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dlopen_constants","title":"dlopen constants","description":"If available on the operating system, the following constants are exported in os.constants.dlopen. See dlopen(3) for detailed information.         Constant     Description           RTLD_LAZY     Perform lazy binding. Node.js sets this flag by default.           RTLD_NOW     Resolve all undefined symbols in the library before dlopen(3)     returns.           RTLD_GLOBAL     Symbols defined by the library will be made available for symbol     resolution of subsequently loaded libraries.           RTLD_LOCAL     The converse of RTLD_GLOBAL. This is the default behavior     if neither flag is specified.           RTLD_DEEPBIND     Make a self-contained library use its own symbols in preference to     symbols from previously loaded libraries."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_priority_constants","title":"Priority constants","description":"The following process scheduling constants are exported by os.constants.priority.         Constant     Description           PRIORITY_LOW     The lowest process scheduling priority. This corresponds to     IDLE_PRIORITY_CLASS on Windows, and a nice value of     19 on all other platforms.           PRIORITY_BELOW_NORMAL     The process scheduling priority above PRIORITY_LOW and     below PRIORITY_NORMAL. This corresponds to     BELOW_NORMAL_PRIORITY_CLASS on Windows, and a nice value of     10 on all other platforms.           PRIORITY_NORMAL     The default process scheduling priority. This corresponds to     NORMAL_PRIORITY_CLASS on Windows, and a nice value of     0 on all other platforms.           PRIORITY_ABOVE_NORMAL     The process scheduling priority above PRIORITY_NORMAL and     below PRIORITY_HIGH. This corresponds to     ABOVE_NORMAL_PRIORITY_CLASS on Windows, and a nice value of     -7 on all other platforms.           PRIORITY_HIGH     The process scheduling priority above PRIORITY_ABOVE_NORMAL     and below PRIORITY_HIGHEST. This corresponds to     HIGH_PRIORITY_CLASS on Windows, and a nice value of     -14 on all other platforms.           PRIORITY_HIGHEST     The highest process scheduling priority. This corresponds to     REALTIME_PRIORITY_CLASS on Windows, and a nice value of     -20 on all other platforms."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_libuv_constants","title":"libuv constants","description":"Constant     Description           UV_UDP_REUSEADDR"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path","title":"Path","description":"Source Code: lib\/path.js The path module provides utilities for working with file and directory paths. It can be accessed using: const path = require('path');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_basename_path_ext","title":"`path.basename(path[, ext])`","description":"The path.basename() method returns the last portion of a path, similar to the Unix basename command. Trailing directory separators are ignored, see path.sep. path.basename('\/foo\/bar\/baz\/asdf\/quux.html'); \/\/ Returns: 'quux.html'  path.basename('\/foo\/bar\/baz\/asdf\/quux.html', '.html'); \/\/ Returns: 'quux'  Although Windows usually treats file names, including file extensions, in a case-insensitive manner, this function does not. For example, C:\\\\foo.html and C:\\\\foo.HTML refer to the same file, but basename treats the extension as a case-sensitive string: path.win32.basename('C:\\\\foo.html', '.html'); \/\/ Returns: 'foo'  path.win32.basename('C:\\\\foo.HTML', '.html'); \/\/ Returns: 'foo.HTML'  A TypeError is thrown if path is not a string or if ext is given and is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_dirname_path","title":"`path.dirname(path)`","description":"The path.dirname() method returns the directory name of a path, similar to the Unix dirname command. Trailing directory separators are ignored, see path.sep. path.dirname('\/foo\/bar\/baz\/asdf\/quux'); \/\/ Returns: '\/foo\/bar\/baz\/asdf'  A TypeError is thrown if path is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_extname_path","title":"`path.extname(path)`","description":"The path.extname() method returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than the first character of the basename of path (see path.basename()) , an empty string is returned. path.extname('index.html'); \/\/ Returns: '.html'  path.extname('index.coffee.md'); \/\/ Returns: '.md'  path.extname('index.'); \/\/ Returns: '.'  path.extname('index'); \/\/ Returns: ''  path.extname('.index'); \/\/ Returns: ''  path.extname('.index.md'); \/\/ Returns: '.md'  A TypeError is thrown if path is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_format_pathobject","title":"`path.format(pathObject)`","description":"The path.format() method returns a path string from an object. This is the opposite of path.parse(). When providing properties to the pathObject remember that there are combinations where one property has priority over another:  pathObject.root is ignored if pathObject.dir is provided pathObject.ext and pathObject.name are ignored if pathObject.base exists  For example, on POSIX: \/\/ If `dir`, `root` and `base` are provided, \/\/ `${dir}${path.sep}${base}` \/\/ will be returned. `root` is ignored. path.format({   root: '\/ignored',   dir: '\/home\/user\/dir',   base: 'file.txt' }); \/\/ Returns: '\/home\/user\/dir\/file.txt'  \/\/ `root` will be used if `dir` is not specified. \/\/ If only `root` is provided or `dir` is equal to `root` then the \/\/ platform separator will not be included. `ext` will be ignored. path.format({   root: '\/',   base: 'file.txt',   ext: 'ignored' }); \/\/ Returns: '\/file.txt'  \/\/ `name` + `ext` will be used if `base` is not specified. path.format({   root: '\/',   name: 'file',   ext: '.txt' }); \/\/ Returns: '\/file.txt'  On Windows: path.format({   dir: 'C:\\\\path\\\\dir',   base: 'file.txt' }); \/\/ Returns: 'C:\\\\path\\\\dir\\\\file.txt'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_isabsolute_path","title":"`path.isAbsolute(path)`","description":"The path.isAbsolute() method determines if path is an absolute path. If the given path is a zero-length string, false will be returned. For example, on POSIX: path.isAbsolute('\/foo\/bar'); \/\/ true path.isAbsolute('\/baz\/..');  \/\/ true path.isAbsolute('qux\/');     \/\/ false path.isAbsolute('.');        \/\/ false  On Windows: path.isAbsolute('\/\/server');    \/\/ true path.isAbsolute('\\\\\\\\server');  \/\/ true path.isAbsolute('C:\/foo\/..');   \/\/ true path.isAbsolute('C:\\\\foo\\\\..'); \/\/ true path.isAbsolute('bar\\\\baz');    \/\/ false path.isAbsolute('bar\/baz');     \/\/ false path.isAbsolute('.');           \/\/ false  A TypeError is thrown if path is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_join_paths","title":"`path.join([...paths])`","description":"The path.join() method joins all given path segments together using the platform-specific separator as a delimiter, then normalizes the resulting path. Zero-length path segments are ignored. If the joined path string is a zero-length string then '.' will be returned, representing the current working directory. path.join('\/foo', 'bar', 'baz\/asdf', 'quux', '..'); \/\/ Returns: '\/foo\/bar\/baz\/asdf'  path.join('foo', {}, 'bar'); \/\/ Throws 'TypeError: Path must be a string. Received {}'  A TypeError is thrown if any of the path segments is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_normalize_path","title":"`path.normalize(path)`","description":"The path.normalize() method normalizes the given path, resolving '..' and '.' segments. When multiple, sequential path segment separation characters are found (e.g. \/ on POSIX and either \\ or \/ on Windows), they are replaced by a single instance of the platform-specific path segment separator (\/ on POSIX and \\ on Windows). Trailing separators are preserved. If the path is a zero-length string, '.' is returned, representing the current working directory. For example, on POSIX: path.normalize('\/foo\/bar\/\/baz\/asdf\/quux\/..'); \/\/ Returns: '\/foo\/bar\/baz\/asdf'  On Windows: path.normalize('C:\\\\temp\\\\\\\\foo\\\\bar\\\\..\\\\'); \/\/ Returns: 'C:\\\\temp\\\\foo\\\\'  Since Windows recognizes multiple path separators, both separators will be replaced by instances of the Windows preferred separator (\\): path.win32.normalize('C:\/\/\/\/temp\\\\\\\\\/\\\\\/\\\\\/foo\/bar'); \/\/ Returns: 'C:\\\\temp\\\\foo\\\\bar'  A TypeError is thrown if path is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_parse_path","title":"`path.parse(path)`","description":"The path.parse() method returns an object whose properties represent significant elements of the path. Trailing directory separators are ignored, see path.sep. The returned object will have the following properties:  dir <string> root <string> base <string> name <string> ext <string>  For example, on POSIX: path.parse('\/home\/user\/dir\/file.txt'); \/\/ Returns: \/\/ { root: '\/', \/\/   dir: '\/home\/user\/dir', \/\/   base: 'file.txt', \/\/   ext: '.txt', \/\/   name: 'file' }  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502          dir        \u2502    base    \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 root \u2502              \u2502 name \u2502 ext \u2502 \"  \/    home\/user\/dir \/ file  .txt \" \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 (All spaces in the \"\" line should be ignored. They are purely for formatting.)  On Windows: path.parse('C:\\\\path\\\\dir\\\\file.txt'); \/\/ Returns: \/\/ { root: 'C:\\\\', \/\/   dir: 'C:\\\\path\\\\dir', \/\/   base: 'file.txt', \/\/   ext: '.txt', \/\/   name: 'file' }  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502          dir        \u2502    base    \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 root \u2502              \u2502 name \u2502 ext \u2502 \" C:\\      path\\dir   \\ file  .txt \" \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 (All spaces in the \"\" line should be ignored. They are purely for formatting.)  A TypeError is thrown if path is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_relative_from_to","title":"`path.relative(from, to)`","description":"The path.relative() method returns the relative path from from to to based on the current working directory. If from and to each resolve to the same path (after calling path.resolve() on each), a zero-length string is returned. If a zero-length string is passed as from or to, the current working directory will be used instead of the zero-length strings. For example, on POSIX: path.relative('\/data\/orandea\/test\/aaa', '\/data\/orandea\/impl\/bbb'); \/\/ Returns: '..\/..\/impl\/bbb'  On Windows: path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb'); \/\/ Returns: '..\\\\..\\\\impl\\\\bbb'  A TypeError is thrown if either from or to is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_resolve_paths","title":"`path.resolve([...paths])`","description":"The path.resolve() method resolves a sequence of paths or path segments into an absolute path. The given sequence of paths is processed from right to left, with each subsequent path prepended until an absolute path is constructed. For instance, given the sequence of path segments: \/foo, \/bar, baz, calling path.resolve('\/foo', '\/bar', 'baz') would return \/bar\/baz because 'baz' is not an absolute path but '\/bar' + '\/' + 'baz' is. If, after processing all given path segments, an absolute path has not yet been generated, the current working directory is used. The resulting path is normalized and trailing slashes are removed unless the path is resolved to the root directory. Zero-length path segments are ignored. If no path segments are passed, path.resolve() will return the absolute path of the current working directory. path.resolve('\/foo\/bar', '.\/baz'); \/\/ Returns: '\/foo\/bar\/baz'  path.resolve('\/foo\/bar', '\/tmp\/file\/'); \/\/ Returns: '\/tmp\/file'  path.resolve('wwwroot', 'static_files\/png\/', '..\/gif\/image.gif'); \/\/ If the current working directory is \/home\/myself\/node, \/\/ this returns '\/home\/myself\/node\/wwwroot\/static_files\/gif\/image.gif'  A TypeError is thrown if any of the arguments is not a string."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_path_tonamespacedpath_path","title":"`path.toNamespacedPath(path)`","description":"On Windows systems only, returns an equivalent namespace-prefixed path for the given path. If path is not a string, path will be returned without modifications. This method is meaningful only on Windows systems. On POSIX systems, the method is non-operational and always returns path without modifications."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_windows_vs_posix","title":"Windows vs. POSIX","description":"The default operation of the path module varies based on the operating system on which a Node.js application is running. Specifically, when running on a Windows operating system, the path module will assume that Windows-style paths are being used. So using path.basename() might yield different results on POSIX and Windows: On POSIX: path.basename('C:\\\\temp\\\\myfile.html'); \/\/ Returns: 'C:\\\\temp\\\\myfile.html'  On Windows: path.basename('C:\\\\temp\\\\myfile.html'); \/\/ Returns: 'myfile.html'  To achieve consistent results when working with Windows file paths on any operating system, use path.win32: On POSIX and Windows: path.win32.basename('C:\\\\temp\\\\myfile.html'); \/\/ Returns: 'myfile.html'  To achieve consistent results when working with POSIX file paths on any operating system, use path.posix: On POSIX and Windows: path.posix.basename('\/tmp\/myfile.html'); \/\/ Returns: 'myfile.html'  On Windows Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example, path.resolve('C:\\\\') can potentially return a different result than path.resolve('C:'). For more information, see this MSDN page."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_performance_measurement_apis","title":"Performance measurement APIs","description":"Source Code: lib\/perf_hooks.js This module provides an implementation of a subset of the W3C Web Performance APIs as well as additional APIs for Node.js-specific performance measurements. Node.js supports the following Web Performance APIs:  High Resolution Time Performance Timeline User Timing  const { PerformanceObserver, performance } = require('perf_hooks');  const obs = new PerformanceObserver((items) => {   console.log(items.getEntries()[0].duration);   performance.clearMarks(); }); obs.observe({ entryTypes: ['measure'] }); performance.measure('Start to Now');  performance.mark('A'); doSomeLongRunningProcess(() => {   performance.measure('A to Now', 'A');    performance.mark('B');   performance.measure('A to B', 'A', 'B'); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_perf_hooks_monitoreventloopdelay_options","title":"`perf_hooks.monitorEventLoopDelay([options])`","description":"This property is an extension by Node.js. It is not available in Web browsers. Creates a Histogram object that samples and reports the event loop delay over time. The delays will be reported in nanoseconds. Using a timer to detect approximate event loop delay works because the execution of timers is tied specifically to the lifecycle of the libuv event loop. That is, a delay in the loop will cause a delay in the execution of the timer, and those delays are specifically what this API is intended to detect. const { monitorEventLoopDelay } = require('perf_hooks'); const h = monitorEventLoopDelay({ resolution: 20 }); h.enable(); \/\/ Do something. h.disable(); console.log(h.min); console.log(h.max); console.log(h.mean); console.log(h.stddev); console.log(h.percentiles); console.log(h.percentile(50)); console.log(h.percentile(99));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_measuring_the_duration_of_async_operations","title":"Measuring the duration of async operations","description":"The following example uses the Async Hooks and Performance APIs to measure the actual duration of a Timeout operation (including the amount of time it took to execute the callback). 'use strict'; const async_hooks = require('async_hooks'); const {   performance,   PerformanceObserver } = require('perf_hooks');  const set = new Set(); const hook = async_hooks.createHook({   init(id, type) {     if (type === 'Timeout') {       performance.mark(`Timeout-${id}-Init`);       set.add(id);     }   },   destroy(id) {     if (set.has(id)) {       set.delete(id);       performance.mark(`Timeout-${id}-Destroy`);       performance.measure(`Timeout-${id}`,                           `Timeout-${id}-Init`,                           `Timeout-${id}-Destroy`);     }   } }); hook.enable();  const obs = new PerformanceObserver((list, observer) => {   console.log(list.getEntries()[0]);   performance.clearMarks();   observer.disconnect(); }); obs.observe({ entryTypes: ['measure'], buffered: true });  setTimeout(() => {}, 1000);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_measuring_how_long_it_takes_to_load_dependencies","title":"Measuring how long it takes to load dependencies","description":"The following example measures the duration of require() operations to load dependencies:  'use strict'; const {   performance,   PerformanceObserver } = require('perf_hooks'); const mod = require('module');  \/\/ Monkey patch the require function mod.Module.prototype.require =   performance.timerify(mod.Module.prototype.require); require = performance.timerify(require);  \/\/ Activate the observer const obs = new PerformanceObserver((list) => {   const entries = list.getEntries();   entries.forEach((entry) => {     console.log(`require('${entry[0]}')`, entry.duration);   });   obs.disconnect(); }); obs.observe({ entryTypes: ['function'], buffered: true });  require('some-module');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode","title":"Punycode","description":"Source Code: lib\/punycode.js The version of the punycode module bundled in Node.js is being deprecated. In a future major version of Node.js this module will be removed. Users currently depending on the punycode module should switch to using the userland-provided Punycode.js module instead. The punycode module is a bundled version of the Punycode.js module. It can be accessed using: const punycode = require('punycode');  Punycode is a character encoding scheme defined by RFC 3492 that is primarily intended for use in Internationalized Domain Names. Because host names in URLs are limited to ASCII characters only, Domain Names that contain non-ASCII characters must be converted into ASCII using the Punycode scheme. For instance, the Japanese character that translates into the English word, 'example' is '\u4f8b'. The Internationalized Domain Name, '\u4f8b.com' (equivalent to 'example.com') is represented by Punycode as the ASCII string 'xn--fsq.com'. The punycode module provides a simple implementation of the Punycode standard. The punycode module is a third-party dependency used by Node.js and made available to developers as a convenience. Fixes or other modifications to the module must be directed to the Punycode.js project."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_decode_string","title":"`punycode.decode(string)`","description":"The punycode.decode() method converts a Punycode string of ASCII-only characters to the equivalent string of Unicode codepoints. punycode.decode('maana-pta'); \/\/ 'ma\u00f1ana' punycode.decode('--dqo34k'); \/\/ '\u2603-\u2318'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_encode_string","title":"`punycode.encode(string)`","description":"The punycode.encode() method converts a string of Unicode codepoints to a Punycode string of ASCII-only characters. punycode.encode('ma\u00f1ana'); \/\/ 'maana-pta' punycode.encode('\u2603-\u2318'); \/\/ '--dqo34k'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_toascii_domain","title":"`punycode.toASCII(domain)`","description":"The punycode.toASCII() method converts a Unicode string representing an Internationalized Domain Name to Punycode. Only the non-ASCII parts of the domain name will be converted. Calling punycode.toASCII() on a string that already only contains ASCII characters will have no effect. \/\/ encode domain names punycode.toASCII('ma\u00f1ana.com');  \/\/ 'xn--maana-pta.com' punycode.toASCII('\u2603-\u2318.com');   \/\/ 'xn----dqo34k.com' punycode.toASCII('example.com'); \/\/ 'example.com'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_punycode_tounicode_domain","title":"`punycode.toUnicode(domain)`","description":"The punycode.toUnicode() method converts a string representing a domain name containing Punycode encoded characters into Unicode. Only the Punycode encoded parts of the domain name are be converted. \/\/ decode domain names punycode.toUnicode('xn--maana-pta.com'); \/\/ 'ma\u00f1ana.com' punycode.toUnicode('xn----dqo34k.com');  \/\/ '\u2603-\u2318.com' punycode.toUnicode('example.com');       \/\/ 'example.com'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_query_string","title":"Query string","description":"Source Code: lib\/querystring.js The querystring module provides utilities for parsing and formatting URL query strings. It can be accessed using: const querystring = require('querystring');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_decode","title":"`querystring.decode()`","description":"The querystring.decode() function is an alias for querystring.parse()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_encode","title":"`querystring.encode()`","description":"The querystring.encode() function is an alias for querystring.stringify()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_escape_str","title":"`querystring.escape(str)`","description":"The querystring.escape() method performs URL percent-encoding on the given str in a manner that is optimized for the specific requirements of URL query strings. The querystring.escape() method is used by querystring.stringify() and is generally not expected to be used directly. It is exported primarily to allow application code to provide a replacement percent-encoding implementation if necessary by assigning querystring.escape to an alternative function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_parse_str_sep_eq_options","title":"`querystring.parse(str[, sep[, eq[, options]]])`","description":"The querystring.parse() method parses a URL query string (str) into a collection of key and value pairs. For example, the query string 'foo=bar&abc=xyz&abc=123' is parsed into:  {   foo: 'bar',   abc: ['xyz', '123'] }  The object returned by the querystring.parse() method does not prototypically inherit from the JavaScript Object. This means that typical Object methods such as obj.toString(), obj.hasOwnProperty(), and others are not defined and will not work. By default, percent-encoded characters within the query string will be assumed to use UTF-8 encoding. If an alternative character encoding is used, then an alternative decodeURIComponent option will need to be specified: \/\/ Assuming gbkDecodeURIComponent function already exists...  querystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,                   { decodeURIComponent: gbkDecodeURIComponent });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_stringify_obj_sep_eq_options","title":"`querystring.stringify(obj[, sep[, eq[, options]]])`","description":"The querystring.stringify() method produces a URL query string from a given obj by iterating through the object's \"own properties\". It serializes the following types of values passed in obj: <string> | <number> | <boolean> | <string[]> | <number[]> | <boolean[]> Any other input values will be coerced to empty strings. querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' }); \/\/ Returns 'foo=bar&baz=qux&baz=quux&corge='  querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':'); \/\/ Returns 'foo:bar;baz:qux'  By default, characters requiring percent-encoding within the query string will be encoded as UTF-8. If an alternative encoding is required, then an alternative encodeURIComponent option will need to be specified: \/\/ Assuming gbkEncodeURIComponent function already exists,  querystring.stringify({ w: '\u4e2d\u6587', foo: 'bar' }, null, null,                       { encodeURIComponent: gbkEncodeURIComponent });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_querystring_unescape_str","title":"`querystring.unescape(str)`","description":"The querystring.unescape() method performs decoding of URL percent-encoded characters on the given str. The querystring.unescape() method is used by querystring.parse() and is generally not expected to be used directly. It is exported primarily to allow application code to provide a replacement decoding implementation if necessary by assigning querystring.unescape to an alternative function. By default, the querystring.unescape() method will attempt to use the JavaScript built-in decodeURIComponent() method to decode. If that fails, a safer equivalent that does not throw on malformed URLs will be used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quic","title":"QUIC","description":"The net module provides an implementation of the QUIC protocol. To access it, the Node.js binary must be compiled using the --experimental-quic configuration flag. const { createQuicSocket } = require('net');  Example 'use strict';  const key = getTLSKeySomehow(); const cert = getTLSCertSomehow();  const { createQuicSocket } = require('net');  \/\/ Create the QUIC UDP IPv4 socket bound to local IP port 1234 const socket = createQuicSocket({ endpoint: { port: 1234 } });  socket.on('session', async (session) => {   \/\/ A new server side session has been created!    \/\/ The peer opened a new stream!   session.on('stream', (stream) => {     \/\/ Let's say hello     stream.end('Hello World');      \/\/ Let's see what the peer has to say...     stream.setEncoding('utf8');     stream.on('data', console.log);     stream.on('end', () => console.log('stream ended'));   });    const uni = await session.openStream({ halfOpen: true });   uni.write('hi ');   uni.end('from the server!'); });  \/\/ Tell the socket to operate as a server using the given \/\/ key and certificate to secure new connections, using \/\/ the fictional 'hello' application protocol. (async function() {   await socket.listen({ key, cert, alpn: 'hello' });   console.log('The socket is listening for sessions!'); })();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quic_basics","title":"QUIC basics","description":"QUIC is a UDP-based network transport protocol that includes built-in security via TLS 1.3, flow control, error correction, connection migration, multiplexing, and more. Within the Node.js implementation of the QUIC protocol, there are three main components: the QuicSocket, the QuicSession and the QuicStream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quicsocket","title":"QuicSocket","description":"A QuicSocket encapsulates a binding to one or more local UDP ports. It is used to send data to, and receive data from, remote endpoints. Once created, a QuicSocket is associated with a local network address and IP port and can act as both a QUIC client and server simultaneously. User code at the JavaScript level interacts with the QuicSocket object to:  Query or modified the properties of the local UDP binding; Create client QuicSession instances; Wait for server QuicSession instances; or Query activity statistics  Unlike the net.Socket and tls.TLSSocket, a QuicSocket instance cannot be directly used by user code at the JavaScript level to send or receive data over the network."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_client_and_server_quicsessions","title":"Client and server QuicSessions","description":"A QuicSession represents a logical connection between two QUIC endpoints (a client and a server). In the JavaScript API, each is represented by the QuicClientSession and QuicServerSession specializations. At any given time, a QuicSession exists is one of four possible states:  Initial - Entered as soon as the QuicSession is created. Handshake - Entered as soon as the TLS 1.3 handshake between the client and server begins. The handshake is always initiated by the client. Ready - Entered as soon as the TLS 1.3 handshake completes. Once the QuicSession enters the Ready state, it may be used to exchange application data using QuicStream instances. Closed - Entered as soon as the QuicSession connection has been terminated.  New instances of QuicClientSession are created using the connect() function on a QuicSocket as in the example below: const { createQuicSocket } = require('net');  \/\/ Create a QuicSocket associated with localhost and port 1234 const socket = createQuicSocket({ endpoint: { port: 1234 } });  (async function() {   const client = await socket.connect({     address: 'example.com',     port: 4567,     alpn: 'foo'   }); })();  As soon as the QuicClientSession is created, the address provided in the connect options will be resolved to an IP address (if necessary), and the TLS 1.3 handshake will begin. The QuicClientSession cannot be used to exchange application data until after the 'secure' event has been emitted by the QuicClientSession object, signaling the completion of the TLS 1.3 handshake. client.on('secure', () => {   \/\/ The QuicClientSession can now be used for application data });  New instances of QuicServerSession are created internally by the QuicSocket if it has been configured to listen for new connections using the listen() method. const { createQuicSocket } = require('net');  const key = getTLSKeySomehow(); const cert = getTLSCertSomehow();  const socket = createQuicSocket();  socket.on('session', (session) => {   session.on('secure', () => {     \/\/ The QuicServerSession can now be used for application data   }); });  (async function() {   await socket.listen({ key, cert, alpn: 'foo' }); })();  As with client QuicSession instances, the QuicServerSession cannot be used to exchange application data until the 'secure' event has been emitted."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quicsession_and_alpn","title":"QuicSession and ALPN","description":"QUIC uses the TLS 1.3 ALPN (\"Application-Layer Protocol Negotiation\") extension to identify the application level protocol that is using the QUIC connection. Every QuicSession instance has an ALPN identifier that must be specified in either the connect() or listen() options. ALPN identifiers that are known to Node.js (such as the ALPN identifier for HTTP\/3) will alter how the QuicSession and QuicStream objects operate internally, but the QUIC implementation for Node.js has been designed to allow any ALPN to be specified and used."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quicstream","title":"QuicStream","description":"Once a QuicSession transitions to the Ready state, QuicStream instances may be created and used to exchange application data. On a general level, all QuicStream instances are simply Node.js Duplex Streams that allow bidirectional data flow between the QUIC client and server. However, the application protocol negotiated for the QuicSession may alter the semantics and operation of a QuicStream associated with the session. Specifically, some features of the QuicStream (e.g. headers) are enabled only if the application protocol selected is known by Node.js to support those features. Once the QuicSession is ready, a QuicStream may be created by either the client or server, and may be unidirectional or bidirectional. The openStream() method is used to create a new QuicStream: \/\/ Create a new bidirectional stream async function createStreams(session) {   const stream1 = await session.openStream();    \/\/ Create a new unidirectional stream   const stream2 = await session.openStream({ halfOpen: true }); }  As suggested by the names, a bidirectional stream allows data to be sent on a stream in both directions, by both client and server, regardless of which peer opened the stream. A unidirectional stream can be written to only by the QuicSession that opened it. The 'stream' event is emitted by the QuicSession when a new QuicStream has been initiated by the connected peer: session.on('stream', (stream) => {   if (stream.bidirectional) {     stream.write('Hello World');     stream.end();   }   stream.on('data', console.log);   stream.on('end', () => {}); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quicstream_headers","title":"QuicStream headers","description":"Some QUIC application protocols (like HTTP\/3) use headers. There are four kinds of headers that the Node.js QUIC implementation is capable of handling dependent entirely on known application protocol support:  Informational Headers Initial Headers Trailing Headers Push Headers  These categories correlate exactly with the equivalent HTTP concepts:  Informational Headers: Any response headers transmitted within a block of headers using a 1xx status code. Initial Headers: HTTP request or response headers Trailing Headers: A block of headers that follow the body of a request or response. Push Promise Headers: A block of headers included in a promised push stream.  If headers are supported by the application protocol in use for a given QuicSession, the 'initialHeaders', 'informationalHeaders', and 'trailingHeaders' events will be emitted by the QuicStream object when headers are received; and the submitInformationalHeaders(), submitInitialHeaders(), and submitTrailingHeaders() methods can be used to send headers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quic_and_http_3","title":"QUIC and HTTP\/3","description":"HTTP\/3 is an application layer protocol that uses QUIC as the transport. TBD"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_quic_javascript_api","title":"QUIC JavaScript API","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_net_createquicsocket_options","title":"`net.createQuicSocket([options])`","description":"The net.createQuicSocket() function is used to create new QuicSocket instances associated with a local UDP address."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_additional_notes","title":"Additional notes","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_custom_dns_lookup_functions","title":"Custom DNS lookup functions","description":"By default, the QUIC implementation uses the dns module's promisified version of lookup() to resolve domains names into IP addresses. For most typical use cases, this will be sufficient. However, it is possible to pass a custom lookup function as an option in several places throughout the QUIC API:  net.createQuicSocket() quicsocket.addEndpoint() quicsocket.connect() quicsocket.listen()  The custom lookup function must return a Promise that is resolved once the lookup is complete. It will be invoked with two arguments:  address <string> | <undefined> The host name to resolve, or undefined if no host name was provided. family <number> One of 4 or 6, identifying either IPv4 or IPv6.  async function myCustomLookup(address, type) {   \/\/ TODO(@jasnell): Make this example more useful   return resolveTheAddressSomehow(address, type); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_online_certificate_status_protocol_ocsp","title":"Online Certificate Status Protocol (OCSP)","description":"The QUIC implementation supports use of OCSP during the TLS 1.3 handshake of a new QUIC session."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_requests","title":"Requests","description":"A QuicServerSession can receive and process OCSP requests by setting the ocspHandler option in the quicsocket.listen() function. The value of the ocspHandler is an async function that must return an object with the OCSP response and, optionally, a new <tls.SecureContext> to use during the handshake. The handler function will be invoked with two arguments:  type: <string> Will always be request for QuicServerSession. options: <Object>  servername <string> The SNI server name. context <tls.SecureContext> The SecureContext currently used.    async function ocspServerHandler(type, { servername, context }) {   \/\/ Process the request...   return { data: Buffer.from('The OCSP response') }; }  sock.listen({ ocspHandler: ocspServerHandler });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_responses","title":"Responses","description":"A QuicClientSession can receive and process OCSP responses by setting the ocspHandler option in the quicsocket.connect() function. The value of the ocspHandler is an async function with no expected return value. The handler function will be invoked with two arguments:  type: <string> Will always be response for QuicClientSession. options: <Object>  data: <Buffer> The OCSP response provided by the server    async function ocspClientHandler(type, { data }) {   console.log(data.toString()); }  sock.connect({ ocspHandler: ocspClientHandler });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_handling_client_hello","title":"Handling client hello","description":"When quicsocket.listen() is called, a <tls.SecureContext> is created and used by default for all new QuicServerSession instances. There are times, however, when the <tls.SecureContext> to be used for a QuicSession can only be determined once the client initiates a connection. This is accomplished using the clientHelloHandler option when calling quicsocket.listen(). The value of clientHelloHandler is an async function that is called at the start of a new QuicServerSession. It is invoked with three arguments:  alpn <string> The ALPN protocol identifier specified by the client. servername <string> The SNI server name specified by the client. ciphers <string[]> The array of TLS 1.3 ciphers specified by the client.  The clientHelloHandler can return a new <tls.SecureContext> object that will be used to continue the TLS handshake. If the function returns undefined, the default <tls.SecureContext> will be used. Returning any other value will cause an error to be thrown that will destroy the QuicServerSession instance. const server = createQuicSocket();  server.listen({   async clientHelloHandler(alpn, servername, ciphers) {     console.log(alpn);     console.log(servername);     console.log(ciphers);   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline","title":"Readline","description":"Source Code: lib\/readline.js The readline module provides an interface for reading data from a Readable stream (such as process.stdin) one line at a time. It can be accessed using: const readline = require('readline');  The following simple example illustrates the basic use of the readline module. const readline = require('readline');  const rl = readline.createInterface({   input: process.stdin,   output: process.stdout });  rl.question('What do you think of Node.js? ', (answer) => {   \/\/ TODO: Log the answer in a database   console.log(`Thank you for your valuable feedback: ${answer}`);    rl.close(); });  Once this code is invoked, the Node.js application will not terminate until the readline.Interface is closed because the interface waits for data to be received on the input stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline_clearline_stream_dir_callback","title":"`readline.clearLine(stream, dir[, callback])`","description":"The readline.clearLine() method clears current line of given TTY stream in a specified direction identified by dir."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline_clearscreendown_stream_callback","title":"`readline.clearScreenDown(stream[, callback])`","description":"The readline.clearScreenDown() method clears the given TTY stream from the current position of the cursor down."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline_createinterface_options","title":"`readline.createInterface(options)`","description":"The readline.createInterface() method creates a new readline.Interface instance. const readline = require('readline'); const rl = readline.createInterface({   input: process.stdin,   output: process.stdout });  Once the readline.Interface instance is created, the most common case is to listen for the 'line' event: rl.on('line', (line) => {   console.log(`Received: ${line}`); });  If terminal is true for this instance then the output stream will get the best compatibility if it defines an output.columns property and emits a 'resize' event on the output if or when the columns ever change (process.stdout does this automatically when it is a TTY)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_use_of_the_completer_function","title":"Use of the `completer` function","description":"The completer function takes the current line entered by the user as an argument, and returns an Array with 2 entries:  An Array with matching entries for the completion. The substring that was used for the matching.  For instance: [[substr1, substr2, ...], originalsubstring]. function completer(line) {   const completions = '.help .error .exit .quit .q'.split(' ');   const hits = completions.filter((c) => c.startsWith(line));   \/\/ Show all completions if none found   return [hits.length ? hits : completions, line]; }  The completer function can be called asynchronously if it accepts two arguments: function completer(linePartial, callback) {   callback(null, [['123'], linePartial]); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline_cursorto_stream_x_y_callback","title":"`readline.cursorTo(stream, x[, y][, callback])`","description":"The readline.cursorTo() method moves cursor to the specified position in a given TTY stream."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline_emitkeypressevents_stream_interface","title":"`readline.emitKeypressEvents(stream[, interface])`","description":"The readline.emitKeypressEvents() method causes the given Readable stream to begin emitting 'keypress' events corresponding to received input. Optionally, interface specifies a readline.Interface instance for which autocompletion is disabled when copy-pasted input is detected. If the stream is a TTY, then it must be in raw mode. This is automatically called by any readline instance on its input if the input is a terminal. Closing the readline instance does not stop the input from emitting 'keypress' events. readline.emitKeypressEvents(process.stdin); if (process.stdin.isTTY)   process.stdin.setRawMode(true);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readline_movecursor_stream_dx_dy_callback","title":"`readline.moveCursor(stream, dx, dy[, callback])`","description":"The readline.moveCursor() method moves the cursor relative to its current position in a given TTY stream. Example: Tiny CLI The following example illustrates the use of readline.Interface class to implement a small command-line interface: const readline = require('readline'); const rl = readline.createInterface({   input: process.stdin,   output: process.stdout,   prompt: 'OHAI> ' });  rl.prompt();  rl.on('line', (line) => {   switch (line.trim()) {     case 'hello':       console.log('world!');       break;     default:       console.log(`Say what? I might have heard '${line.trim()}'`);       break;   }   rl.prompt(); }).on('close', () => {   console.log('Have a great day!');   process.exit(0); });  Example: Read file stream line-by-Line A common use case for readline is to consume an input file one line at a time. The easiest way to do so is leveraging the fs.ReadStream API as well as a for await...of loop: const fs = require('fs'); const readline = require('readline');  async function processLineByLine() {   const fileStream = fs.createReadStream('input.txt');    const rl = readline.createInterface({     input: fileStream,     crlfDelay: Infinity   });   \/\/ Note: we use the crlfDelay option to recognize all instances of CR LF   \/\/ ('\\r\\n') in input.txt as a single line break.    for await (const line of rl) {     \/\/ Each line in input.txt will be successively available here as `line`.     console.log(`Line from file: ${line}`);   } }  processLineByLine();  Alternatively, one could use the 'line' event: const fs = require('fs'); const readline = require('readline');  const rl = readline.createInterface({   input: fs.createReadStream('sample.txt'),   crlfDelay: Infinity });  rl.on('line', (line) => {   console.log(`Line from file: ${line}`); });  Currently, for await...of loop can be a bit slower. If async \/ await flow and speed are both essential, a mixed approach can be applied: const { once } = require('events'); const { createReadStream } = require('fs'); const { createInterface } = require('readline');  (async function processLineByLine() {   try {     const rl = createInterface({       input: createReadStream('big-file.txt'),       crlfDelay: Infinity     });      rl.on('line', (line) => {       \/\/ Process the line.     });      await once(rl, 'close');      console.log('File processed.');   } catch (err) {     console.error(err);   } })();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tty_keybindings","title":"TTY keybindings","description":"Keybindings     Description     Notes           Ctrl+Shift+Backspace     Delete line left     Doesn't work on Linux, Mac and Windows           Ctrl+Shift+Delete     Delete line right     Doesn't work on Mac           Ctrl+C     Emit SIGINT or close the readline instance                Ctrl+H     Delete left                Ctrl+D     Delete right or close the readline instance in case the current line is empty \/ EOF     Doesn't work on Windows           Ctrl+U     Delete from the current position to the line start                Ctrl+K     Delete from the current position to the end of line                Ctrl+A     Go to start of line                Ctrl+E     Go to to end of line                Ctrl+B     Back one character                Ctrl+F     Forward one character                Ctrl+L     Clear screen                Ctrl+N     Next history item                Ctrl+P     Previous history item                Ctrl+Z     Moves running process into background. Type     fg and press Enter     to return.     Doesn't work on Windows           Ctrl+W or Ctrl    +Backspace     Delete backward to a word boundary     Ctrl+Backspace Doesn't     work on Linux, Mac and Windows           Ctrl+Delete     Delete forward to a word boundary     Doesn't work on Mac           Ctrl+Left arrow or     Meta+B     Word left     Ctrl+Left arrow Doesn't work     on Mac           Ctrl+Right arrow or     Meta+F     Word right     Ctrl+Right arrow Doesn't work     on Mac           Meta+D or Meta    +Delete     Delete word right     Meta+Delete Doesn't work     on windows           Meta+Backspace     Delete word left     Doesn't work on Mac"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_repl","title":"REPL","description":"Source Code: lib\/repl.js The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications. It can be accessed using: const repl = require('repl');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_repl_start_options","title":"`repl.start([options])`","description":"The repl.start() method creates and starts a repl.REPLServer instance. If options is a string, then it specifies the input prompt: const repl = require('repl');  \/\/ a Unix style prompt repl.start('$ ');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_design_and_features","title":"Design and features","description":"The repl module exports the repl.REPLServer class. While running, instances of repl.REPLServer will accept individual lines of user input, evaluate those according to a user-defined evaluation function, then output the result. Input and output may be from stdin and stdout, respectively, or may be connected to any Node.js stream. Instances of repl.REPLServer support automatic completion of inputs, completion preview, simplistic Emacs-style line editing, multi-line inputs, ZSH-like reverse-i-search, ZSH-like substring-based history search, ANSI-styled output, saving and restoring current REPL session state, error recovery, and customizable evaluation functions. Terminals that do not support ANSI styles and Emacs-style line editing automatically fall back to a limited feature set."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_commands_and_special_keys","title":"Commands and special keys","description":"The following special commands are supported by all REPL instances:  .break: When in the process of inputting a multi-line expression, enter the .break command (or press Ctrl+C) to abort further input or processing of that expression. .clear: Resets the REPL context to an empty object and clears any multi-line expression being input. .exit: Close the I\/O stream, causing the REPL to exit. .help: Show this list of special commands. .save: Save the current REPL session to a file: > .save .\/file\/to\/save.js .load: Load a file into the current REPL session. > .load .\/file\/to\/load.js .editor: Enter editor mode (Ctrl+D to finish, Ctrl+C to cancel).  > .editor \/\/ Entering editor mode (^D to finish, ^C to cancel) function welcome(name) {   return `Hello ${name}!`; }  welcome('Node.js User');  \/\/ ^D 'Hello Node.js User!' >  The following key combinations in the REPL have these special effects:  Ctrl+C: When pressed once, has the same effect as the .break command. When pressed twice on a blank line, has the same effect as the .exit command. Ctrl+D: Has the same effect as the .exit command. Tab: When pressed on a blank line, displays global and local (scope) variables. When pressed while entering other input, displays relevant autocompletion options.  For key bindings related to the reverse-i-search, see reverse-i-search. For all other key bindings, see TTY keybindings."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_default_evaluation","title":"Default evaluation","description":"By default, all instances of repl.REPLServer use an evaluation function that evaluates JavaScript expressions and provides access to Node.js built-in modules. This default behavior can be overridden by passing in an alternative evaluation function when the repl.REPLServer instance is created."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_javascript_expressions","title":"JavaScript expressions","description":"The default evaluator supports direct evaluation of JavaScript expressions: > 1 + 1 2 > const m = 2 undefined > m + 1 3  Unless otherwise scoped within blocks or functions, variables declared either implicitly or using the const, let, or var keywords are declared at the global scope."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_global_and_local_scope","title":"Global and local scope","description":"The default evaluator provides access to any variables that exist in the global scope. It is possible to expose a variable to the REPL explicitly by assigning it to the context object associated with each REPLServer: const repl = require('repl'); const msg = 'message';  repl.start('> ').context.m = msg;  Properties in the context object appear as local within the REPL: $ node repl_test.js > m 'message'  Context properties are not read-only by default. To specify read-only globals, context properties must be defined using Object.defineProperty(): const repl = require('repl'); const msg = 'message';  const r = repl.start('> '); Object.defineProperty(r.context, 'm', {   configurable: false,   enumerable: true,   value: msg });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_accessing_core_node_js_modules","title":"Accessing core Node.js modules","description":"The default evaluator will automatically load Node.js core modules into the REPL environment when used. For instance, unless otherwise declared as a global or scoped variable, the input fs will be evaluated on-demand as global.fs = require('fs'). > fs.createReadStream('.\/some\/file');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_global_uncaught_exceptions","title":"Global uncaught exceptions","description":"The REPL uses the domain module to catch all uncaught exceptions for that REPL session. This use of the domain module in the REPL has these side effects:  Uncaught exceptions only emit the 'uncaughtException' event in the standalone REPL. Adding a listener for this event in a REPL within another Node.js program throws ERR_INVALID_REPL_INPUT. Trying to use process.setUncaughtExceptionCaptureCallback() throws an ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE error.  As standalone program: process.on('uncaughtException', () => console.log('Uncaught'));  throw new Error('foobar'); \/\/ Uncaught  When used in another application: process.on('uncaughtException', () => console.log('Uncaught')); \/\/ TypeError [ERR_INVALID_REPL_INPUT]: Listeners for `uncaughtException` \/\/ cannot be used in the REPL  throw new Error('foobar'); \/\/ Thrown: \/\/ Error: foobar"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_assignment_of_the__underscore_variable","title":"Assignment of the `_` (underscore) variable","description":"The default evaluator will, by default, assign the result of the most recently evaluated expression to the special variable _ (underscore). Explicitly setting _ to a value will disable this behavior. > [ 'a', 'b', 'c' ] [ 'a', 'b', 'c' ] > _.length 3 > _ += 1 Expression assignment to _ now disabled. 4 > 1 + 1 2 > _ 4  Similarly, _error will refer to the last seen error, if there was any. Explicitly setting _error to a value will disable this behavior. > throw new Error('foo'); Error: foo > _error.message 'foo'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_await_keyword","title":"`await` keyword","description":"With the --experimental-repl-await command-line option specified, experimental support for the await keyword is enabled. > await Promise.resolve(123) 123 > await Promise.reject(new Error('REPL await')) Error: REPL await     at repl:1:45 > const timeout = util.promisify(setTimeout); undefined > const old = Date.now(); await timeout(1000); console.log(Date.now() - old); 1002 undefined"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_reverse_i_search","title":"Reverse-i-search","description":"The REPL supports bi-directional reverse-i-search similar to ZSH. It is triggered with Ctrl+R to search backward and Ctrl+S to search forwards. Duplicated history entires will be skipped. Entries are accepted as soon as any key is pressed that doesn't correspond with the reverse search. Cancelling is possible by pressing Esc or Ctrl+C. Changing the direction immediately searches for the next entry in the expected direction from the current position on."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_custom_evaluation_functions","title":"Custom evaluation functions","description":"When a new repl.REPLServer is created, a custom evaluation function may be provided. This can be used, for instance, to implement fully customized REPL applications. The following illustrates a hypothetical example of a REPL that performs translation of text from one language to another: const repl = require('repl'); const { Translator } = require('translator');  const myTranslator = new Translator('en', 'fr');  function myEval(cmd, context, filename, callback) {   callback(null, myTranslator.translate(cmd)); }  repl.start({ prompt: '> ', eval: myEval });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_recoverable_errors","title":"Recoverable errors","description":"At the REPL prompt, pressing Enter sends the current line of input to the eval function. In order to support multi-line input, the eval function can return an instance of repl.Recoverable to the provided callback function: function myEval(cmd, context, filename, callback) {   let result;   try {     result = vm.runInThisContext(cmd);   } catch (e) {     if (isRecoverableError(e)) {       return callback(new repl.Recoverable(e));     }   }   callback(null, result); }  function isRecoverableError(error) {   if (error.name === 'SyntaxError') {     return \/^(Unexpected end of input|Unexpected token)\/.test(error.message);   }   return false; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_customizing_repl_output","title":"Customizing REPL output","description":"By default, repl.REPLServer instances format output using the util.inspect() method before writing the output to the provided Writable stream (process.stdout by default). The showProxy inspection option is set to true by default and the colors option is set to true depending on the REPL's useColors option. The useColors boolean option can be specified at construction to instruct the default writer to use ANSI style codes to colorize the output from the util.inspect() method. If the REPL is run as standalone program, it is also possible to change the REPL's inspection defaults from inside the REPL by using the inspect.replDefaults property which mirrors the defaultOptions from util.inspect(). > util.inspect.replDefaults.compact = false; false > [1] [   1 ] >  To fully customize the output of a repl.REPLServer instance pass in a new function for the writer option on construction. The following example, for instance, simply converts any input text to upper case: const repl = require('repl');  const r = repl.start({ prompt: '> ', eval: myEval, writer: myWriter });  function myEval(cmd, context, filename, callback) {   callback(null, cmd); }  function myWriter(output) {   return output.toUpperCase(); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_node_js_repl","title":"The Node.js REPL","description":"Node.js itself uses the repl module to provide its own interactive interface for executing JavaScript. This can be used by executing the Node.js binary without passing any arguments (or by passing the -i argument): $ node > const a = [1, 2, 3]; undefined > a [ 1, 2, 3 ] > a.forEach((v) => { ...   console.log(v); ...   }); 1 2 3"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_environment_variable_options","title":"Environment variable options","description":"Various behaviors of the Node.js REPL can be customized using the following environment variables:  NODE_REPL_HISTORY: When a valid path is given, persistent REPL history will be saved to the specified file rather than .node_repl_history in the user's home directory. Setting this value to '' (an empty string) will disable persistent REPL history. Whitespace will be trimmed from the value. On Windows platforms environment variables with empty values are invalid so set this variable to one or more spaces to disable persistent REPL history. NODE_REPL_HISTORY_SIZE: Controls how many lines of history will be persisted if history is available. Must be a positive number. Default: 1000. NODE_REPL_MODE: May be either 'sloppy' or 'strict'. Default: 'sloppy', which will allow non-strict mode code to be run."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_persistent_history","title":"Persistent history","description":"By default, the Node.js REPL will persist history between node REPL sessions by saving inputs to a .node_repl_history file located in the user's home directory. This can be disabled by setting the environment variable NODE_REPL_HISTORY=''."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_using_the_node_js_repl_with_advanced_line_editors","title":"Using the Node.js REPL with advanced line-editors","description":"For advanced line-editors, start Node.js with the environment variable NODE_NO_READLINE=1. This will start the main and debugger REPL in canonical terminal settings, which will allow use with rlwrap. For example, the following can be added to a .bashrc file: alias node=\"env NODE_NO_READLINE=1 rlwrap node\""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_starting_multiple_repl_instances_against_a_single_running_instance","title":"Starting multiple REPL instances against a single running instance","description":"It is possible to create and run multiple REPL instances against a single running instance of Node.js that share a single global object but have separate I\/O interfaces. The following example, for instance, provides separate REPLs on stdin, a Unix socket, and a TCP socket: const net = require('net'); const repl = require('repl'); let connections = 0;  repl.start({   prompt: 'Node.js via stdin> ',   input: process.stdin,   output: process.stdout });  net.createServer((socket) => {   connections += 1;   repl.start({     prompt: 'Node.js via Unix socket> ',     input: socket,     output: socket   }).on('exit', () => {     socket.end();   }); }).listen('\/tmp\/node-repl-sock');  net.createServer((socket) => {   connections += 1;   repl.start({     prompt: 'Node.js via TCP socket> ',     input: socket,     output: socket   }).on('exit', () => {     socket.end();   }); }).listen(5001);  Running this application from the command line will start a REPL on stdin. Other REPL clients may connect through the Unix socket or TCP socket. telnet, for instance, is useful for connecting to TCP sockets, while socat can be used to connect to both Unix and TCP sockets. By starting a REPL from a Unix socket-based server instead of stdin, it is possible to connect to a long-running Node.js process without restarting it. For an example of running a \"full-featured\" (terminal) REPL over a net.Server and net.Socket instance, see: https:\/\/gist.github.com\/TooTallNate\/2209310. For an example of running a REPL instance over curl(1), see: https:\/\/gist.github.com\/TooTallNate\/2053342."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream","title":"Stream","description":"Source Code: lib\/stream.js A stream is an abstract interface for working with streaming data in Node.js. The stream module provides an API for implementing the stream interface. There are many stream objects provided by Node.js. For instance, a request to an HTTP server and process.stdout are both stream instances. Streams can be readable, writable, or both. All streams are instances of EventEmitter. To access the stream module: const stream = require('stream');  The stream module is useful for creating new types of stream instances. It is usually not necessary to use the stream module to consume streams."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_finished_stream_options_callback","title":"`stream.finished(stream[, options], callback)`","description":"A function to get notified when a stream is no longer readable, writable or has experienced an error or a premature close event. const { finished } = require('stream');  const rs = fs.createReadStream('archive.tar');  finished(rs, (err) => {   if (err) {     console.error('Stream failed.', err);   } else {     console.log('Stream is done reading.');   } });  rs.resume(); \/\/ Drain the stream.  Especially useful in error handling scenarios where a stream is destroyed prematurely (like an aborted HTTP request), and will not emit 'end' or 'finish'. The finished API provides promise version: const { finished } = require('stream\/promises');  const rs = fs.createReadStream('archive.tar');  async function run() {   await finished(rs);   console.log('Stream is done reading.'); }  run().catch(console.error); rs.resume(); \/\/ Drain the stream.  stream.finished() leaves dangling event listeners (in particular 'error', 'end', 'finish' and 'close') after callback has been invoked. The reason for this is so that unexpected 'error' events (due to incorrect stream implementations) do not cause unexpected crashes. If this is unwanted behavior then the returned cleanup function needs to be invoked in the callback: const cleanup = finished(rs, (err) => {   cleanup();   \/\/ ... });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_pipeline_source_transforms_destination_callback","title":"`stream.pipeline(source[, ...transforms], destination, callback)`","description":"A module method to pipe between streams and generators forwarding errors and properly cleaning up and provide a callback when the pipeline is complete. const { pipeline } = require('stream'); const fs = require('fs'); const zlib = require('zlib');  \/\/ Use the pipeline API to easily pipe a series of streams \/\/ together and get notified when the pipeline is fully done.  \/\/ A pipeline to gzip a potentially huge tar file efficiently:  pipeline(   fs.createReadStream('archive.tar'),   zlib.createGzip(),   fs.createWriteStream('archive.tar.gz'),   (err) => {     if (err) {       console.error('Pipeline failed.', err);     } else {       console.log('Pipeline succeeded.');     }   } );  The pipeline API provides promise version: const { pipeline } = require('stream\/promises');  async function run() {   await pipeline(     fs.createReadStream('archive.tar'),     zlib.createGzip(),     fs.createWriteStream('archive.tar.gz')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  The pipeline API also supports async generators: const { pipeline } = require('stream\/promises'); const fs = require('fs');  async function run() {   await pipeline(     fs.createReadStream('lowercase.txt'),     async function* (source) {       source.setEncoding('utf8');  \/\/ Work with strings rather than `Buffer`s.       for await (const chunk of source) {         yield chunk.toUpperCase();       }     },     fs.createWriteStream('uppercase.txt')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  stream.pipeline() will call stream.destroy(err) on all streams except:  Readable streams which have emitted 'end' or 'close'. Writable streams which have emitted 'finish' or 'close'.  stream.pipeline() leaves dangling event listeners on the streams after the callback has been invoked. In the case of reuse of streams after failure, this can cause event listener leaks and swallowed errors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_pipeline_streams_callback","title":"`stream.pipeline(streams, callback)`","description":"A module method to pipe between streams and generators forwarding errors and properly cleaning up and provide a callback when the pipeline is complete. const { pipeline } = require('stream'); const fs = require('fs'); const zlib = require('zlib');  \/\/ Use the pipeline API to easily pipe a series of streams \/\/ together and get notified when the pipeline is fully done.  \/\/ A pipeline to gzip a potentially huge tar file efficiently:  pipeline(   fs.createReadStream('archive.tar'),   zlib.createGzip(),   fs.createWriteStream('archive.tar.gz'),   (err) => {     if (err) {       console.error('Pipeline failed.', err);     } else {       console.log('Pipeline succeeded.');     }   } );  The pipeline API provides promise version: const { pipeline } = require('stream\/promises');  async function run() {   await pipeline(     fs.createReadStream('archive.tar'),     zlib.createGzip(),     fs.createWriteStream('archive.tar.gz')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  The pipeline API also supports async generators: const { pipeline } = require('stream\/promises'); const fs = require('fs');  async function run() {   await pipeline(     fs.createReadStream('lowercase.txt'),     async function* (source) {       source.setEncoding('utf8');  \/\/ Work with strings rather than `Buffer`s.       for await (const chunk of source) {         yield chunk.toUpperCase();       }     },     fs.createWriteStream('uppercase.txt')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  stream.pipeline() will call stream.destroy(err) on all streams except:  Readable streams which have emitted 'end' or 'close'. Writable streams which have emitted 'finish' or 'close'.  stream.pipeline() leaves dangling event listeners on the streams after the callback has been invoked. In the case of reuse of streams after failure, this can cause event listener leaks and swallowed errors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_readable_from_iterable_options","title":"`stream.Readable.from(iterable, [options])`","description":"A utility method for creating readable streams out of iterators. const { Readable } = require('stream');  async function * generate() {   yield 'hello';   yield 'streams'; }  const readable = Readable.from(generate());  readable.on('data', (chunk) => {   console.log(chunk); });  Calling Readable.from(string) or Readable.from(buffer) will not have the strings or buffers be iterated to match the other streams semantics for performance reasons."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_read_0","title":"`readable.read(0)`","description":"There are some cases where it is necessary to trigger a refresh of the underlying readable stream mechanisms, without actually consuming any data. In such cases, it is possible to call readable.read(0), which will always return null. If the internal read buffer is below the highWaterMark, and the stream is not currently reading, then calling stream.read(0) will trigger a low-level stream._read() call. While most applications will almost never need to do this, there are situations within Node.js where this is done, particularly in the Readable stream class internals."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_push","title":"`readable.push('')`","description":"Use of readable.push('') is not recommended. Pushing a zero-byte string, Buffer or Uint8Array to a stream that is not in object mode has an interesting side effect. Because it is a call to readable.push(), the call will end the reading process. However, because the argument is an empty string, no data is added to the readable buffer so there is nothing for a user to consume."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_api_for_stream_consumers","title":"API for stream consumers","description":"Almost all Node.js applications, no matter how simple, use streams in some manner. The following is an example of using streams in a Node.js application that implements an HTTP server: const http = require('http');  const server = http.createServer((req, res) => {   \/\/ `req` is an http.IncomingMessage, which is a readable stream.   \/\/ `res` is an http.ServerResponse, which is a writable stream.    let body = '';   \/\/ Get the data as utf8 strings.   \/\/ If an encoding is not set, Buffer objects will be received.   req.setEncoding('utf8');    \/\/ Readable streams emit 'data' events once a listener is added.   req.on('data', (chunk) => {     body += chunk;   });    \/\/ The 'end' event indicates that the entire body has been received.   req.on('end', () => {     try {       const data = JSON.parse(body);       \/\/ Write back something interesting to the user:       res.write(typeof data);       res.end();     } catch (er) {       \/\/ uh oh! bad json!       res.statusCode = 400;       return res.end(`error: ${er.message}`);     }   }); });  server.listen(1337);  \/\/ $ curl localhost:1337 -d \"{}\" \/\/ object \/\/ $ curl localhost:1337 -d \"\\\"foo\\\"\" \/\/ string \/\/ $ curl localhost:1337 -d \"not json\" \/\/ error: Unexpected token o in JSON at position 1  Writable streams (such as res in the example) expose methods such as write() and end() that are used to write data onto the stream. Readable streams use the EventEmitter API for notifying application code when data is available to be read off the stream. That available data can be read from the stream in multiple ways. Both Writable and Readable streams use the EventEmitter API in various ways to communicate the current state of the stream. Duplex and Transform streams are both Writable and Readable. Applications that are either writing data to or consuming data from a stream are not required to implement the stream interfaces directly and will generally have no reason to call require('stream'). Developers wishing to implement new types of streams should refer to the section API for stream implementers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_finished_stream_options_callback","title":"`stream.finished(stream[, options], callback)`","description":"A function to get notified when a stream is no longer readable, writable or has experienced an error or a premature close event. const { finished } = require('stream');  const rs = fs.createReadStream('archive.tar');  finished(rs, (err) => {   if (err) {     console.error('Stream failed.', err);   } else {     console.log('Stream is done reading.');   } });  rs.resume(); \/\/ Drain the stream.  Especially useful in error handling scenarios where a stream is destroyed prematurely (like an aborted HTTP request), and will not emit 'end' or 'finish'. The finished API provides promise version: const { finished } = require('stream\/promises');  const rs = fs.createReadStream('archive.tar');  async function run() {   await finished(rs);   console.log('Stream is done reading.'); }  run().catch(console.error); rs.resume(); \/\/ Drain the stream.  stream.finished() leaves dangling event listeners (in particular 'error', 'end', 'finish' and 'close') after callback has been invoked. The reason for this is so that unexpected 'error' events (due to incorrect stream implementations) do not cause unexpected crashes. If this is unwanted behavior then the returned cleanup function needs to be invoked in the callback: const cleanup = finished(rs, (err) => {   cleanup();   \/\/ ... });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_pipeline_source_transforms_destination_callback","title":"`stream.pipeline(source[, ...transforms], destination, callback)`","description":"A module method to pipe between streams and generators forwarding errors and properly cleaning up and provide a callback when the pipeline is complete. const { pipeline } = require('stream'); const fs = require('fs'); const zlib = require('zlib');  \/\/ Use the pipeline API to easily pipe a series of streams \/\/ together and get notified when the pipeline is fully done.  \/\/ A pipeline to gzip a potentially huge tar file efficiently:  pipeline(   fs.createReadStream('archive.tar'),   zlib.createGzip(),   fs.createWriteStream('archive.tar.gz'),   (err) => {     if (err) {       console.error('Pipeline failed.', err);     } else {       console.log('Pipeline succeeded.');     }   } );  The pipeline API provides promise version: const { pipeline } = require('stream\/promises');  async function run() {   await pipeline(     fs.createReadStream('archive.tar'),     zlib.createGzip(),     fs.createWriteStream('archive.tar.gz')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  The pipeline API also supports async generators: const { pipeline } = require('stream\/promises'); const fs = require('fs');  async function run() {   await pipeline(     fs.createReadStream('lowercase.txt'),     async function* (source) {       source.setEncoding('utf8');  \/\/ Work with strings rather than `Buffer`s.       for await (const chunk of source) {         yield chunk.toUpperCase();       }     },     fs.createWriteStream('uppercase.txt')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  stream.pipeline() will call stream.destroy(err) on all streams except:  Readable streams which have emitted 'end' or 'close'. Writable streams which have emitted 'finish' or 'close'.  stream.pipeline() leaves dangling event listeners on the streams after the callback has been invoked. In the case of reuse of streams after failure, this can cause event listener leaks and swallowed errors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_pipeline_streams_callback","title":"`stream.pipeline(streams, callback)`","description":"A module method to pipe between streams and generators forwarding errors and properly cleaning up and provide a callback when the pipeline is complete. const { pipeline } = require('stream'); const fs = require('fs'); const zlib = require('zlib');  \/\/ Use the pipeline API to easily pipe a series of streams \/\/ together and get notified when the pipeline is fully done.  \/\/ A pipeline to gzip a potentially huge tar file efficiently:  pipeline(   fs.createReadStream('archive.tar'),   zlib.createGzip(),   fs.createWriteStream('archive.tar.gz'),   (err) => {     if (err) {       console.error('Pipeline failed.', err);     } else {       console.log('Pipeline succeeded.');     }   } );  The pipeline API provides promise version: const { pipeline } = require('stream\/promises');  async function run() {   await pipeline(     fs.createReadStream('archive.tar'),     zlib.createGzip(),     fs.createWriteStream('archive.tar.gz')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  The pipeline API also supports async generators: const { pipeline } = require('stream\/promises'); const fs = require('fs');  async function run() {   await pipeline(     fs.createReadStream('lowercase.txt'),     async function* (source) {       source.setEncoding('utf8');  \/\/ Work with strings rather than `Buffer`s.       for await (const chunk of source) {         yield chunk.toUpperCase();       }     },     fs.createWriteStream('uppercase.txt')   );   console.log('Pipeline succeeded.'); }  run().catch(console.error);  stream.pipeline() will call stream.destroy(err) on all streams except:  Readable streams which have emitted 'end' or 'close'. Writable streams which have emitted 'finish' or 'close'.  stream.pipeline() leaves dangling event listeners on the streams after the callback has been invoked. In the case of reuse of streams after failure, this can cause event listener leaks and swallowed errors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_stream_readable_from_iterable_options","title":"`stream.Readable.from(iterable, [options])`","description":"A utility method for creating readable streams out of iterators. const { Readable } = require('stream');  async function * generate() {   yield 'hello';   yield 'streams'; }  const readable = Readable.from(generate());  readable.on('data', (chunk) => {   console.log(chunk); });  Calling Readable.from(string) or Readable.from(buffer) will not have the strings or buffers be iterated to match the other streams semantics for performance reasons."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_writable_streams","title":"Writable streams","description":"Writable streams are an abstraction for a destination to which data is written. Examples of Writable streams include:  HTTP requests, on the client HTTP responses, on the server fs write streams zlib streams crypto streams TCP sockets child process stdin process.stdout, process.stderr  Some of these examples are actually Duplex streams that implement the Writable interface. All Writable streams implement the interface defined by the stream.Writable class. While specific instances of Writable streams may differ in various ways, all Writable streams follow the same fundamental usage pattern as illustrated in the example below: const myStream = getWritableStreamSomehow(); myStream.write('some data'); myStream.write('some more data'); myStream.end('done writing data');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_streams","title":"Readable streams","description":"Readable streams are an abstraction for a source from which data is consumed. Examples of Readable streams include:  HTTP responses, on the client HTTP requests, on the server fs read streams zlib streams crypto streams TCP sockets child process stdout and stderr process.stdin  All Readable streams implement the interface defined by the stream.Readable class."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_two_reading_modes","title":"Two reading modes","description":"Readable streams effectively operate in one of two modes: flowing and paused. These modes are separate from object mode. A Readable stream can be in object mode or not, regardless of whether it is in flowing mode or paused mode.   In flowing mode, data is read from the underlying system automatically and provided to an application as quickly as possible using events via the EventEmitter interface.   In paused mode, the stream.read() method must be called explicitly to read chunks of data from the stream.   All Readable streams begin in paused mode but can be switched to flowing mode in one of the following ways:  Adding a 'data' event handler. Calling the stream.resume() method. Calling the stream.pipe() method to send the data to a Writable.  The Readable can switch back to paused mode using one of the following:  If there are no pipe destinations, by calling the stream.pause() method. If there are pipe destinations, by removing all pipe destinations. Multiple pipe destinations may be removed by calling the stream.unpipe() method.  The important concept to remember is that a Readable will not generate data until a mechanism for either consuming or ignoring that data is provided. If the consuming mechanism is disabled or taken away, the Readable will attempt to stop generating the data. For backward compatibility reasons, removing 'data' event handlers will not automatically pause the stream. Also, if there are piped destinations, then calling stream.pause() will not guarantee that the stream will remain paused once those destinations drain and ask for more data. If a Readable is switched into flowing mode and there are no consumers available to handle the data, that data will be lost. This can occur, for instance, when the readable.resume() method is called without a listener attached to the 'data' event, or when a 'data' event handler is removed from the stream. Adding a 'readable' event handler automatically makes the stream stop flowing, and the data has to be consumed via readable.read(). If the 'readable' event handler is removed, then the stream will start flowing again if there is a 'data' event handler."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_three_states","title":"Three states","description":"The \"two modes\" of operation for a Readable stream are a simplified abstraction for the more complicated internal state management that is happening within the Readable stream implementation. Specifically, at any given point in time, every Readable is in one of three possible states:  readable.readableFlowing === null readable.readableFlowing === false readable.readableFlowing === true  When readable.readableFlowing is null, no mechanism for consuming the stream's data is provided. Therefore, the stream will not generate data. While in this state, attaching a listener for the 'data' event, calling the readable.pipe() method, or calling the readable.resume() method will switch readable.readableFlowing to true, causing the Readable to begin actively emitting events as data is generated. Calling readable.pause(), readable.unpipe(), or receiving backpressure will cause the readable.readableFlowing to be set as false, temporarily halting the flowing of events but not halting the generation of data. While in this state, attaching a listener for the 'data' event will not switch readable.readableFlowing to true. const { PassThrough, Writable } = require('stream'); const pass = new PassThrough(); const writable = new Writable();  pass.pipe(writable); pass.unpipe(writable); \/\/ readableFlowing is now false.  pass.on('data', (chunk) => { console.log(chunk.toString()); }); pass.write('ok');  \/\/ Will not emit 'data'. pass.resume();     \/\/ Must be called to make stream emit 'data'.  While readable.readableFlowing is false, data may be accumulating within the stream's internal buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_choose_one_api_style","title":"Choose one API style","description":"The Readable stream API evolved across multiple Node.js versions and provides multiple methods of consuming stream data. In general, developers should choose one of the methods of consuming data and should never use multiple methods to consume data from a single stream. Specifically, using a combination of on('data'), on('readable'), pipe(), or async iterators could lead to unintuitive behavior. Use of the readable.pipe() method is recommended for most users as it has been implemented to provide the easiest way of consuming stream data. Developers that require more fine-grained control over the transfer and generation of data can use the EventEmitter and readable.on('readable')\/readable.read() or the readable.pause()\/readable.resume() APIs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_duplex_and_transform_streams","title":"Duplex and transform streams","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_api_for_stream_implementers","title":"API for stream implementers","description":"The stream module API has been designed to make it possible to easily implement streams using JavaScript's prototypal inheritance model. First, a stream developer would declare a new JavaScript class that extends one of the four basic stream classes (stream.Writable, stream.Readable, stream.Duplex, or stream.Transform), making sure they call the appropriate parent class constructor:  const { Writable } = require('stream');  class MyWritable extends Writable {   constructor({ highWaterMark, ...options }) {     super({ highWaterMark });     \/\/ ...   } }  When extending streams, keep in mind what options the user can and should provide before forwarding these to the base constructor. For example, if the implementation makes assumptions in regard to the autoDestroy and emitClose options, do not allow the user to override these. Be explicit about what options are forwarded instead of implicitly forwarding all options. The new stream class must then implement one or more specific methods, depending on the type of stream being created, as detailed in the chart below:    Use-case Class Method(s) to implement     Reading only Readable _read()   Writing only Writable _write(), _writev(), _final()   Reading and writing Duplex _read(), _write(), _writev(), _final()   Operate on written data, then read the result Transform _transform(), _flush(), _final()    The implementation code for a stream should never call the \"public\" methods of a stream that are intended for use by consumers (as described in the API for stream consumers section). Doing so may lead to adverse side effects in application code consuming the stream. Avoid overriding public methods such as write(), end(), cork(), uncork(), read() and destroy(), or emitting internal events such as 'error', 'data', 'end', 'finish' and 'close' through .emit(). Doing so can break current and future stream invariants leading to behavior and\/or compatibility issues with other streams, stream utilities, and user expectations."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_simplified_construction","title":"Simplified construction","description":"For many simple cases, it is possible to create a stream without relying on inheritance. This can be accomplished by directly creating instances of the stream.Writable, stream.Readable, stream.Duplex or stream.Transform objects and passing appropriate methods as constructor options. const { Writable } = require('stream');  const myWritable = new Writable({   construct(callback) {     \/\/ Initialize state and load resources...   },   write(chunk, encoding, callback) {     \/\/ ...   },   destroy() {     \/\/ Free resources...   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implementing_a_writable_stream","title":"Implementing a writable stream","description":"The stream.Writable class is extended to implement a Writable stream. Custom Writable streams must call the new stream.Writable([options]) constructor and implement the writable._write() and\/or writable._writev() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_writable_construct_callback","title":"`writable._construct(callback)`","description":"The _construct() method MUST NOT be called directly. It may be implemented by child classes, and if so, will be called by the internal Writable class methods only. This optional function will be called in a tick after the stream constructor has returned, delaying any _write(), _final() and _destroy() calls until callback is called. This is useful to initialize state or asynchronously initialize resources before the stream can be used. const { Writable } = require('stream'); const fs = require('fs');  class WriteStream extends Writable {   constructor(filename) {     super();     this.filename = filename;     this.fd = fd;   }   _construct(callback) {     fs.open(this.filename, (fd, err) => {       if (err) {         callback(err);       } else {         this.fd = fd;         callback();       }     });   }   _write(chunk, encoding, callback) {     fs.write(this.fd, chunk, callback);   }   _destroy(err, callback) {     if (this.fd) {       fs.close(this.fd, (er) => callback(er || err));     } else {       callback(err);     }   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_writable_write_chunk_encoding_callback","title":"`writable._write(chunk, encoding, callback)`","description":"All Writable stream implementations must provide a writable._write() and\/or writable._writev() method to send data to the underlying resource. Transform streams provide their own implementation of the writable._write(). This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal Writable class methods only. The callback function must be called synchronously inside of writable._write() or asynchronously (i.e. different tick) to signal either that the write completed successfully or failed with an error. The first argument passed to the callback must be the Error object if the call failed or null if the write succeeded. All calls to writable.write() that occur between the time writable._write() is called and the callback is called will cause the written data to be buffered. When the callback is invoked, the stream might emit a 'drain' event. If a stream implementation is capable of processing multiple chunks of data at once, the writable._writev() method should be implemented. If the decodeStrings property is explicitly set to false in the constructor options, then chunk will remain the same object that is passed to .write(), and may be a string rather than a Buffer. This is to support implementations that have an optimized handling for certain string data encodings. In that case, the encoding argument will indicate the character encoding of the string. Otherwise, the encoding argument can be safely ignored. The writable._write() method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_writable_writev_chunks_callback","title":"`writable._writev(chunks, callback)`","description":"This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal Writable class methods only. The writable._writev() method may be implemented in addition or alternatively to writable._write() in stream implementations that are capable of processing multiple chunks of data at once. If implemented and if there is buffered data from previous writes, _writev() will be called instead of _write(). The writable._writev() method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_writable_destroy_err_callback","title":"`writable._destroy(err, callback)`","description":"The _destroy() method is called by writable.destroy(). It can be overridden by child classes but it must not be called directly."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_writable_final_callback","title":"`writable._final(callback)`","description":"The _final() method must not be called directly. It may be implemented by child classes, and if so, will be called by the internal Writable class methods only. This optional function will be called before the stream closes, delaying the 'finish' event until callback is called. This is useful to close resources or write buffered data before a stream ends."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_errors_while_writing","title":"Errors while writing","description":"Errors occurring during the processing of the writable._write(), writable._writev() and writable._final() methods must be propagated by invoking the callback and passing the error as the first argument. Throwing an Error from within these methods or manually emitting an 'error' event results in undefined behavior. If a Readable stream pipes into a Writable stream when Writable emits an error, the Readable stream will be unpiped. const { Writable } = require('stream');  const myWritable = new Writable({   write(chunk, encoding, callback) {     if (chunk.toString().indexOf('a') >= 0) {       callback(new Error('chunk is invalid'));     } else {       callback();     }   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_an_example_writable_stream","title":"An example writable stream","description":"The following illustrates a rather simplistic (and somewhat pointless) custom Writable stream implementation. While this specific Writable stream instance is not of any real particular usefulness, the example illustrates each of the required elements of a custom Writable stream instance: const { Writable } = require('stream');  class MyWritable extends Writable {   _write(chunk, encoding, callback) {     if (chunk.toString().indexOf('a') >= 0) {       callback(new Error('chunk is invalid'));     } else {       callback();     }   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_decoding_buffers_in_a_writable_stream","title":"Decoding buffers in a writable stream","description":"Decoding buffers is a common task, for instance, when using transformers whose input is a string. This is not a trivial process when using multi-byte characters encoding, such as UTF-8. The following example shows how to decode multi-byte strings using StringDecoder and Writable. const { Writable } = require('stream'); const { StringDecoder } = require('string_decoder');  class StringWritable extends Writable {   constructor(options) {     super(options);     this._decoder = new StringDecoder(options && options.defaultEncoding);     this.data = '';   }   _write(chunk, encoding, callback) {     if (encoding === 'buffer') {       chunk = this._decoder.write(chunk);     }     this.data += chunk;     callback();   }   _final(callback) {     this.data += this._decoder.end();     callback();   } }  const euro = [[0xE2, 0x82], [0xAC]].map(Buffer.from); const w = new StringWritable();  w.write('currency: '); w.write(euro[0]); w.end(euro[1]);  console.log(w.data); \/\/ currency: \u20ac"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implementing_a_readable_stream","title":"Implementing a readable stream","description":"The stream.Readable class is extended to implement a Readable stream. Custom Readable streams must call the new stream.Readable([options]) constructor and implement the readable._read() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_construct_callback","title":"`readable._construct(callback)`","description":"The _construct() method MUST NOT be called directly. It may be implemented by child classes, and if so, will be called by the internal Readable class methods only. This optional function will be scheduled in the next tick by the stream constructor, delaying any _read() and _destroy() calls until callback is called. This is useful to initialize state or asynchronously initialize resources before the stream can be used. const { Readable } = require('stream'); const fs = require('fs');  class ReadStream extends Readable {   constructor(filename) {     super();     this.filename = filename;     this.fd = null;   }   _construct(callback) {     fs.open(this.filename, (err, fd) => {       if (err) {         callback(err);       } else {         this.fd = fd;         callback();       }     });   }   _read(n) {     const buf = Buffer.alloc(n);     fs.read(this.fd, buf, 0, n, null, (err, bytesRead) => {       if (err) {         this.destroy(err);       } else {         this.push(bytesRead > 0 ? buf.slice(0, bytesRead) : null);       }     });   }   _destroy(err, callback) {     if (this.fd) {       fs.close(this.fd, (er) => callback(er || err));     } else {       callback(err);     }   } }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_read_size","title":"`readable._read(size)`","description":"This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal Readable class methods only. All Readable stream implementations must provide an implementation of the readable._read() method to fetch data from the underlying resource. When readable._read() is called, if data is available from the resource, the implementation should begin pushing that data into the read queue using the this.push(dataChunk) method. _read() should continue reading from the resource and pushing data until readable.push() returns false. Only when _read() is called again after it has stopped should it resume pushing additional data onto the queue. Once the readable._read() method has been called, it will not be called again until more data is pushed through the readable.push() method. Empty data such as empty buffers and strings will not cause readable._read() to be called. The size argument is advisory. For implementations where a \"read\" is a single operation that returns data can use the size argument to determine how much data to fetch. Other implementations may ignore this argument and simply provide data whenever it becomes available. There is no need to \"wait\" until size bytes are available before calling stream.push(chunk). The readable._read() method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_destroy_err_callback","title":"`readable._destroy(err, callback)`","description":"The _destroy() method is called by readable.destroy(). It can be overridden by child classes but it must not be called directly."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_push_chunk_encoding","title":"`readable.push(chunk[, encoding])`","description":"When chunk is a Buffer, Uint8Array or string, the chunk of data will be added to the internal queue for users of the stream to consume. Passing chunk as null signals the end of the stream (EOF), after which no more data can be written. When the Readable is operating in paused mode, the data added with readable.push() can be read out by calling the readable.read() method when the 'readable' event is emitted. When the Readable is operating in flowing mode, the data added with readable.push() will be delivered by emitting a 'data' event. The readable.push() method is designed to be as flexible as possible. For example, when wrapping a lower-level source that provides some form of pause\/resume mechanism, and a data callback, the low-level source can be wrapped by the custom Readable instance: \/\/ `_source` is an object with readStop() and readStart() methods, \/\/ and an `ondata` member that gets called when it has data, and \/\/ an `onend` member that gets called when the data is over.  class SourceWrapper extends Readable {   constructor(options) {     super(options);      this._source = getLowLevelSourceObject();      \/\/ Every time there's data, push it into the internal buffer.     this._source.ondata = (chunk) => {       \/\/ If push() returns false, then stop reading from source.       if (!this.push(chunk))         this._source.readStop();     };      \/\/ When the source ends, push the EOF-signaling `null` chunk.     this._source.onend = () => {       this.push(null);     };   }   \/\/ _read() will be called when the stream wants to pull more data in.   \/\/ The advisory size argument is ignored in this case.   _read(size) {     this._source.readStart();   } }  The readable.push() method is used to push the content into the internal buffer. It can be driven by the readable._read() method. For streams not operating in object mode, if the chunk parameter of readable.push() is undefined, it will be treated as empty string or buffer. See readable.push('') for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_errors_while_reading","title":"Errors while reading","description":"Errors occurring during processing of the readable._read() must be propagated through the readable.destroy(err) method. Throwing an Error from within readable._read() or manually emitting an 'error' event results in undefined behavior. const { Readable } = require('stream');  const myReadable = new Readable({   read(size) {     const err = checkSomeErrorCondition();     if (err) {       this.destroy(err);     } else {       \/\/ Do some work.     }   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implementing_a_duplex_stream","title":"Implementing a duplex stream","description":"A Duplex stream is one that implements both Readable and Writable, such as a TCP socket connection. Because JavaScript does not have support for multiple inheritance, the stream.Duplex class is extended to implement a Duplex stream (as opposed to extending the stream.Readable and stream.Writable classes). The stream.Duplex class prototypically inherits from stream.Readable and parasitically from stream.Writable, but instanceof will work properly for both base classes due to overriding Symbol.hasInstance on stream.Writable. Custom Duplex streams must call the new stream.Duplex([options]) constructor and implement both the readable._read() and writable._write() methods."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_an_example_duplex_stream","title":"An example duplex stream","description":"The following illustrates a simple example of a Duplex stream that wraps a hypothetical lower-level source object to which data can be written, and from which data can be read, albeit using an API that is not compatible with Node.js streams. The following illustrates a simple example of a Duplex stream that buffers incoming written data via the Writable interface that is read back out via the Readable interface. const { Duplex } = require('stream'); const kSource = Symbol('source');  class MyDuplex extends Duplex {   constructor(source, options) {     super(options);     this[kSource] = source;   }    _write(chunk, encoding, callback) {     \/\/ The underlying source only deals with strings.     if (Buffer.isBuffer(chunk))       chunk = chunk.toString();     this[kSource].writeSomeData(chunk);     callback();   }    _read(size) {     this[kSource].fetchSomeData(size, (data, encoding) => {       this.push(Buffer.from(data, encoding));     });   } }  The most important aspect of a Duplex stream is that the Readable and Writable sides operate independently of one another despite co-existing within a single object instance."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_object_mode_duplex_streams","title":"Object mode duplex streams","description":"For Duplex streams, objectMode can be set exclusively for either the Readable or Writable side using the readableObjectMode and writableObjectMode options respectively. In the following example, for instance, a new Transform stream (which is a type of Duplex stream) is created that has an object mode Writable side that accepts JavaScript numbers that are converted to hexadecimal strings on the Readable side. const { Transform } = require('stream');  \/\/ All Transform streams are also Duplex Streams. const myTransform = new Transform({   writableObjectMode: true,    transform(chunk, encoding, callback) {     \/\/ Coerce the chunk to a number if necessary.     chunk |= 0;      \/\/ Transform the chunk into something else.     const data = chunk.toString(16);      \/\/ Push the data onto the readable queue.     callback(null, '0'.repeat(data.length % 2) + data);   } });  myTransform.setEncoding('ascii'); myTransform.on('data', (chunk) => console.log(chunk));  myTransform.write(1); \/\/ Prints: 01 myTransform.write(10); \/\/ Prints: 0a myTransform.write(100); \/\/ Prints: 64"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_implementing_a_transform_stream","title":"Implementing a transform stream","description":"A Transform stream is a Duplex stream where the output is computed in some way from the input. Examples include zlib streams or crypto streams that compress, encrypt, or decrypt data. There is no requirement that the output be the same size as the input, the same number of chunks, or arrive at the same time. For example, a Hash stream will only ever have a single chunk of output which is provided when the input is ended. A zlib stream will produce output that is either much smaller or much larger than its input. The stream.Transform class is extended to implement a Transform stream. The stream.Transform class prototypically inherits from stream.Duplex and implements its own versions of the writable._write() and readable._read() methods. Custom Transform implementations must implement the transform._transform() method and may also implement the transform._flush() method. Care must be taken when using Transform streams in that data written to the stream can cause the Writable side of the stream to become paused if the output on the Readable side is not consumed."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_transform_flush_callback","title":"`transform._flush(callback)`","description":"This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal Readable class methods only. In some cases, a transform operation may need to emit an additional bit of data at the end of the stream. For example, a zlib compression stream will store an amount of internal state used to optimally compress the output. When the stream ends, however, that additional data needs to be flushed so that the compressed data will be complete. Custom Transform implementations may implement the transform._flush() method. This will be called when there is no more written data to be consumed, but before the 'end' event is emitted signaling the end of the Readable stream. Within the transform._flush() implementation, the transform.push() method may be called zero or more times, as appropriate. The callback function must be called when the flush operation is complete. The transform._flush() method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_transform_transform_chunk_encoding_callback","title":"`transform._transform(chunk, encoding, callback)`","description":"This function MUST NOT be called by application code directly. It should be implemented by child classes, and called by the internal Readable class methods only. All Transform stream implementations must provide a _transform() method to accept input and produce output. The transform._transform() implementation handles the bytes being written, computes an output, then passes that output off to the readable portion using the transform.push() method. The transform.push() method may be called zero or more times to generate output from a single input chunk, depending on how much is to be output as a result of the chunk. It is possible that no output is generated from any given chunk of input data. The callback function must be called only when the current chunk is completely consumed. The first argument passed to the callback must be an Error object if an error occurred while processing the input or null otherwise. If a second argument is passed to the callback, it will be forwarded on to the transform.push() method. In other words, the following are equivalent: transform.prototype._transform = function(data, encoding, callback) {   this.push(data);   callback(); };  transform.prototype._transform = function(data, encoding, callback) {   callback(null, data); };  The transform._transform() method is prefixed with an underscore because it is internal to the class that defines it, and should never be called directly by user programs. transform._transform() is never called in parallel; streams implement a queue mechanism, and to receive the next chunk, callback must be called, either synchronously or asynchronously."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_additional_notes","title":"Additional notes","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_read_0","title":"`readable.read(0)`","description":"There are some cases where it is necessary to trigger a refresh of the underlying readable stream mechanisms, without actually consuming any data. In such cases, it is possible to call readable.read(0), which will always return null. If the internal read buffer is below the highWaterMark, and the stream is not currently reading, then calling stream.read(0) will trigger a low-level stream._read() call. While most applications will almost never need to do this, there are situations within Node.js where this is done, particularly in the Readable stream class internals."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_readable_push","title":"`readable.push('')`","description":"Use of readable.push('') is not recommended. Pushing a zero-byte string, Buffer or Uint8Array to a stream that is not in object mode has an interesting side effect. Because it is a call to readable.push(), the call will end the reading process. However, because the argument is an empty string, no data is added to the readable buffer so there is nothing for a user to consume."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_streams_compatibility_with_async_generators_and_async_iterators","title":"Streams compatibility with async generators and async iterators","description":"With the support of async generators and iterators in JavaScript, async generators are effectively a first-class language-level stream construct at this point. Some common interop cases of using Node.js streams with async generators and async iterators are provided below."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_piping_to_writable_streams_from_async_iterators","title":"Piping to writable streams from async iterators","description":"When writing to a writable stream from an async iterator, ensure correct handling of backpressure and errors. stream.pipeline() abstracts away the handling of backpressure and backpressure-related errors: const fs = require('fs'); const { pipeline } = require('stream'); const { pipeline: pipelinePromise } = require('stream\/promises');  const writable = fs.createWriteStream('.\/file');  \/\/ Callback Pattern pipeline(iterator, writable, (err, value) => {   if (err) {     console.error(err);   } else {     console.log(value, 'value returned');   } });  \/\/ Promise Pattern pipelinePromise(iterator, writable)   .then((value) => {     console.log(value, 'value returned');   })   .catch(console.error);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_consuming_readable_streams_with_async_iterators","title":"Consuming readable streams with async iterators","description":"(async function() {   for await (const chunk of readable) {     console.log(chunk);   } })();  Async iterators register a permanent error handler on the stream to prevent any unhandled post-destroy errors."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_creating_readable_streams_with_async_generators","title":"Creating readable streams with async generators","description":"A Node.js readable stream can be created from an asynchronous generator using the Readable.from() utility method: const { Readable } = require('stream');  async function * generate() {   yield 'a';   yield 'b';   yield 'c'; }  const readable = Readable.from(generate());  readable.on('data', (chunk) => {   console.log(chunk); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_compatibility_with_older_node_js_versions","title":"Compatibility with older Node.js versions","description":"Prior to Node.js 0.10, the Readable stream interface was simpler, but also less powerful and less useful.  Rather than waiting for calls to the stream.read() method, 'data' events would begin emitting immediately. Applications that would need to perform some amount of work to decide how to handle data were required to store read data into buffers so the data would not be lost. The stream.pause() method was advisory, rather than guaranteed. This meant that it was still necessary to be prepared to receive 'data' events even when the stream was in a paused state.  In Node.js 0.10, the Readable class was added. For backward compatibility with older Node.js programs, Readable streams switch into \"flowing mode\" when a 'data' event handler is added, or when the stream.resume() method is called. The effect is that, even when not using the new stream.read() method and 'readable' event, it is no longer necessary to worry about losing 'data' chunks. While most applications will continue to function normally, this introduces an edge case in the following conditions:  No 'data' event listener is added. The stream.resume() method is never called. The stream is not piped to any writable destination.  For example, consider the following code: \/\/ WARNING!  BROKEN! net.createServer((socket) => {    \/\/ We add an 'end' listener, but never consume the data.   socket.on('end', () => {     \/\/ It will never get here.     socket.end('The message was received but was not processed.\\n');   });  }).listen(1337);  Prior to Node.js 0.10, the incoming message data would be simply discarded. However, in Node.js 0.10 and beyond, the socket remains paused forever. The workaround in this situation is to call the stream.resume() method to begin the flow of data: \/\/ Workaround. net.createServer((socket) => {   socket.on('end', () => {     socket.end('The message was received but was not processed.\\n');   });    \/\/ Start the flow of data, discarding it.   socket.resume(); }).listen(1337);  In addition to new Readable streams switching into flowing mode, pre-0.10 style streams can be wrapped in a Readable class using the readable.wrap() method."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_highwatermark_discrepancy_after_calling_readable_setencoding","title":"`highWaterMark` discrepancy after calling `readable.setEncoding()`","description":"The use of readable.setEncoding() will change the behavior of how the highWaterMark operates in non-object mode. Typically, the size of the current buffer is measured against the highWaterMark in bytes. However, after setEncoding() is called, the comparison function will begin to measure the buffer's size in characters. This is not a problem in common cases with latin1 or ascii. But it is advised to be mindful about this behavior when working with strings that could contain multi-byte characters."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_organization_of_this_document","title":"Organization of this document","description":"This document contains two primary sections and a third section for notes. The first section explains how to use existing streams within an application. The second section explains how to create new types of streams."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_types_of_streams","title":"Types of streams","description":"There are four fundamental stream types within Node.js:  Writable: streams to which data can be written (for example, fs.createWriteStream()). Readable: streams from which data can be read (for example, fs.createReadStream()). Duplex: streams that are both Readable and Writable (for example, net.Socket). Transform: Duplex streams that can modify or transform the data as it is written and read (for example, zlib.createDeflate()).  Additionally, this module includes the utility functions stream.pipeline(), stream.finished() and stream.Readable.from()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_buffering","title":"Buffering","description":"Both Writable and Readable streams will store data in an internal buffer that can be retrieved using writable.writableBuffer or readable.readableBuffer, respectively. The amount of data potentially buffered depends on the highWaterMark option passed into the stream's constructor. For normal streams, the highWaterMark option specifies a total number of bytes. For streams operating in object mode, the highWaterMark specifies a total number of objects. Data is buffered in Readable streams when the implementation calls stream.push(chunk). If the consumer of the Stream does not call stream.read(), the data will sit in the internal queue until it is consumed. Once the total size of the internal read buffer reaches the threshold specified by highWaterMark, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal readable._read() method that is used to fill the read buffer). Data is buffered in Writable streams when the writable.write(chunk) method is called repeatedly. While the total size of the internal write buffer is below the threshold set by highWaterMark, calls to writable.write() will return true. Once the size of the internal buffer reaches or exceeds the highWaterMark, false will be returned. A key goal of the stream API, particularly the stream.pipe() method, is to limit the buffering of data to acceptable levels such that sources and destinations of differing speeds will not overwhelm the available memory. The highWaterMark option is a threshold, not a limit: it dictates the amount of data that a stream buffers before it stops asking for more data. It does not enforce a strict memory limitation in general. Specific stream implementations may choose to enforce stricter limits but doing so is optional. Because Duplex and Transform streams are both Readable and Writable, each maintains two separate internal buffers used for reading and writing, allowing each side to operate independently of the other while maintaining an appropriate and efficient flow of data. For example, net.Socket instances are Duplex streams whose Readable side allows consumption of data received from the socket and whose Writable side allows writing data to the socket. Because data may be written to the socket at a faster or slower rate than data is received, each side should operate (and buffer) independently of the other."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_streams_promises_api","title":"Streams Promises API","description":"The stream\/promises API provides an alternative set of asynchronous utility functions for streams that return Promise objects rather than using callbacks. The API is accessible via require('stream\/promises') or require('stream').promises."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_object_mode","title":"Object mode","description":"All streams created by Node.js APIs operate exclusively on strings and Buffer (or Uint8Array) objects. It is possible, however, for stream implementations to work with other types of JavaScript values (with the exception of null, which serves a special purpose within streams). Such streams are considered to operate in \"object mode\". Stream instances are switched into object mode using the objectMode option when the stream is created. Attempting to switch an existing stream into object mode is not safe."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_string_decoder","title":"String decoder","description":"Source Code: lib\/string_decoder.js The string_decoder module provides an API for decoding Buffer objects into strings in a manner that preserves encoded multi-byte UTF-8 and UTF-16 characters. It can be accessed using: const { StringDecoder } = require('string_decoder');  The following example shows the basic use of the StringDecoder class. const { StringDecoder } = require('string_decoder'); const decoder = new StringDecoder('utf8');  const cent = Buffer.from([0xC2, 0xA2]); console.log(decoder.write(cent));  const euro = Buffer.from([0xE2, 0x82, 0xAC]); console.log(decoder.write(euro));  When a Buffer instance is written to the StringDecoder instance, an internal buffer is used to ensure that the decoded string does not contain any incomplete multibyte characters. These are held in the buffer until the next call to stringDecoder.write() or until stringDecoder.end() is called. In the following example, the three UTF-8 encoded bytes of the European Euro symbol (\u20ac) are written over three separate operations: const { StringDecoder } = require('string_decoder'); const decoder = new StringDecoder('utf8');  decoder.write(Buffer.from([0xE2])); decoder.write(Buffer.from([0x82])); console.log(decoder.end(Buffer.from([0xAC])));"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_timers","title":"Timers","description":"Source Code: lib\/timers.js The timer module exposes a global API for scheduling functions to be called at some future period of time. Because the timer functions are globals, there is no need to call require('timers') to use the API. The timer functions within Node.js implement a similar API as the timers API provided by Web Browsers but use a different internal implementation that is built around the Node.js Event Loop."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_scheduling_timers","title":"Scheduling timers","description":"A timer in Node.js is an internal construct that calls a given function after a certain period of time. When a timer's function is called varies depending on which method was used to create the timer and what other work the Node.js event loop is doing."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setimmediate_callback_args","title":"`setImmediate(callback[, ...args])`","description":"Schedules the \"immediate\" execution of the callback after I\/O events' callbacks. When multiple calls to setImmediate() are made, the callback functions are queued for execution in the order in which they are created. The entire callback queue is processed every event loop iteration. If an immediate timer is queued from inside an executing callback, that timer will not be triggered until the next event loop iteration. If callback is not a function, a TypeError will be thrown. This method has a custom variant for promises that is available using util.promisify(): const util = require('util'); const setImmediatePromise = util.promisify(setImmediate);  setImmediatePromise('foobar').then((value) => {   \/\/ value === 'foobar' (passing values is optional)   \/\/ This is executed after all I\/O callbacks. });  \/\/ Or with async function async function timerExample() {   console.log('Before I\/O callbacks');   await setImmediatePromise();   console.log('After I\/O callbacks'); } timerExample();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_setinterval_callback_delay_args","title":"`setInterval(callback[, delay[, ...args]])`","description":"Schedules repeated execution of callback every delay milliseconds. When delay is larger than 2147483647 or less than 1, the delay will be set to 1. Non-integer delays are truncated to an integer. If callback is not a function, a TypeError will be thrown."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_settimeout_callback_delay_args","title":"`setTimeout(callback[, delay[, ...args]])`","description":"Schedules execution of a one-time callback after delay milliseconds. The callback will likely not be invoked in precisely delay milliseconds. Node.js makes no guarantees about the exact timing of when callbacks will fire, nor of their ordering. The callback will be called as close as possible to the time specified. When delay is larger than 2147483647 or less than 1, the delay will be set to 1. Non-integer delays are truncated to an integer. If callback is not a function, a TypeError will be thrown. This method has a custom variant for promises that is available using util.promisify(): const util = require('util'); const setTimeoutPromise = util.promisify(setTimeout);  setTimeoutPromise(40, 'foobar').then((value) => {   \/\/ value === 'foobar' (passing values is optional)   \/\/ This is executed after about 40 milliseconds. });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cancelling_timers","title":"Cancelling timers","description":"The setImmediate(), setInterval(), and setTimeout() methods each return objects that represent the scheduled timers. These can be used to cancel the timer and prevent it from triggering. For the promisified variants of setImmediate() and setTimeout(), an AbortController may be used to cancel the timer. When canceled, the returned Promises will be rejected with an 'AbortError'. For setImmediate(): const util = require('util'); const setImmediatePromise = util.promisify(setImmediate);  const ac = new AbortController(); const signal = ac.signal;  setImmediatePromise('foobar', { signal })   .then(console.log)   .catch((err) => {     if (err.message === 'AbortError')       console.log('The immediate was aborted');   });  ac.abort();  For setTimeout(): const util = require('util'); const setTimeoutPromise = util.promisify(setTimeout);  const ac = new AbortController(); const signal = ac.signal;  setTimeoutPromise(1000, 'foobar', { signal })   .then(console.log)   .catch((err) => {     if (err.message === 'AbortError')       console.log('The timeout was aborted');   });  ac.abort();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearimmediate_immediate","title":"`clearImmediate(immediate)`","description":"Cancels an Immediate object created by setImmediate()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_clearinterval_timeout","title":"`clearInterval(timeout)`","description":"Cancels a Timeout object created by setInterval()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_cleartimeout_timeout","title":"`clearTimeout(timeout)`","description":"Cancels a Timeout object created by setTimeout()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_timers_promises_api","title":"Timers Promises API","description":"The timers\/promises API provides an alternative set of timer functions that return Promise objects. The API is accessible via require('timers\/promises'). const timersPromises = require('timers\/promises');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_timerspromises_settimeout_delay_value_options","title":"`timersPromises.setTimeout([delay[, value[, options]]])`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_timerspromises_setimmediate_value_options","title":"`timersPromises.setImmediate([value[, options]])`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_ssl","title":"TLS (SSL)","description":"Source Code: lib\/tls.js The tls module provides an implementation of the Transport Layer Security (TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL. The module can be accessed using: const tls = require('tls');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_checkserveridentity_hostname_cert","title":"`tls.checkServerIdentity(hostname, cert)`","description":"Verifies the certificate cert is issued to hostname. Returns <Error> object, populating it with reason, host, and cert on failure. On success, returns <undefined>. This function can be overwritten by providing alternative function as part of the options.checkServerIdentity option passed to tls.connect(). The overwriting function can call tls.checkServerIdentity() of course, to augment the checks done with additional verification. This function is only called if the certificate passed all other checks, such as being issued by trusted CA (options.ca)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_connect_options_callback","title":"`tls.connect(options[, callback])`","description":"The callback function, if specified, will be added as a listener for the 'secureConnect' event. tls.connect() returns a tls.TLSSocket object. Unlike the https API, tls.connect() does not enable the SNI (Server Name Indication) extension by default, which may cause some servers to return an incorrect certificate or reject the connection altogether. To enable SNI, set the servername option in addition to host. The following illustrates a client for the echo server example from tls.createServer(): \/\/ Assumes an echo server that is listening on port 8000. const tls = require('tls'); const fs = require('fs');  const options = {   \/\/ Necessary only if the server requires client certificate authentication.   key: fs.readFileSync('client-key.pem'),   cert: fs.readFileSync('client-cert.pem'),    \/\/ Necessary only if the server uses a self-signed certificate.   ca: [ fs.readFileSync('server-cert.pem') ],    \/\/ Necessary only if the server's cert isn't for \"localhost\".   checkServerIdentity: () => { return null; }, };  const socket = tls.connect(8000, options, () => {   console.log('client connected',               socket.authorized ? 'authorized' : 'unauthorized');   process.stdin.pipe(socket);   process.stdin.resume(); }); socket.setEncoding('utf8'); socket.on('data', (data) => {   console.log(data); }); socket.on('end', () => {   console.log('server ends connection'); });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_connect_path_options_callback","title":"`tls.connect(path[, options][, callback])`","description":"Same as tls.connect() except that path can be provided as an argument instead of an option. A path option, if specified, will take precedence over the path argument."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_connect_port_host_options_callback","title":"`tls.connect(port[, host][, options][, callback])`","description":"Same as tls.connect() except that port and host can be provided as arguments instead of options. A port or host option, if specified, will take precedence over any port or host argument."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_createsecurecontext_options","title":"`tls.createSecureContext([options])`","description":"tls.createServer() sets the default value of the honorCipherOrder option to true, other APIs that create secure contexts leave it unset. tls.createServer() uses a 128 bit truncated SHA1 hash value generated from process.argv as the default value of the sessionIdContext option, other APIs that create secure contexts have no default value. The tls.createSecureContext() method creates a SecureContext object. It is usable as an argument to several tls APIs, such as tls.createServer() and server.addContext(), but has no public methods. A key is required for ciphers that use certificates. Either key or pfx can be used to provide it. If the ca option is not given, then Node.js will default to using Mozilla's publicly trusted list of CAs."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options","title":"`tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])`","description":"Creates a new secure pair object with two streams, one of which reads and writes the encrypted data and the other of which reads and writes the cleartext data. Generally, the encrypted stream is piped to\/from an incoming encrypted data stream and the cleartext one is used as a replacement for the initial encrypted stream. tls.createSecurePair() returns a tls.SecurePair object with cleartext and encrypted stream properties. Using cleartext has the same API as tls.TLSSocket. The tls.createSecurePair() method is now deprecated in favor of tls.TLSSocket(). For example, the code: pair = tls.createSecurePair(\/* ... *\/); pair.encrypted.pipe(socket); socket.pipe(pair.encrypted);  can be replaced by: secureSocket = tls.TLSSocket(socket, options);  where secureSocket has the same API as pair.cleartext."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_createserver_options_secureconnectionlistener","title":"`tls.createServer([options][, secureConnectionListener])`","description":"Creates a new tls.Server. The secureConnectionListener, if provided, is automatically set as a listener for the 'secureConnection' event. The ticketKeys options is automatically shared between cluster module workers. The following illustrates a simple echo server: const tls = require('tls'); const fs = require('fs');  const options = {   key: fs.readFileSync('server-key.pem'),   cert: fs.readFileSync('server-cert.pem'),    \/\/ This is necessary only if using client certificate authentication.   requestCert: true,    \/\/ This is necessary only if the client uses a self-signed certificate.   ca: [ fs.readFileSync('client-cert.pem') ] };  const server = tls.createServer(options, (socket) => {   console.log('server connected',               socket.authorized ? 'authorized' : 'unauthorized');   socket.write('welcome!\\n');   socket.setEncoding('utf8');   socket.pipe(socket); }); server.listen(8000, () => {   console.log('server bound'); });  The server can be tested by connecting to it using the example client from tls.connect()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_getciphers","title":"`tls.getCiphers()`","description":"Returns an array with the names of the supported TLS ciphers. The names are lower-case for historical reasons, but must be uppercased to be used in the ciphers option of tls.createSecureContext(). Cipher names that start with 'tls_' are for TLSv1.3, all the others are for TLSv1.2 and below. console.log(tls.getCiphers()); \/\/ ['aes128-gcm-sha256', 'aes128-sha', ...]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tls_ssl_concepts","title":"TLS\/SSL concepts","description":"The TLS\/SSL is a public\/private key infrastructure (PKI). For most common cases, each client and server must have a private key. Private keys can be generated in multiple ways. The example below illustrates use of the OpenSSL command-line interface to generate a 2048-bit RSA private key: openssl genrsa -out ryans-key.pem 2048  With TLS\/SSL, all servers (and some clients) must have a certificate. Certificates are public keys that correspond to a private key, and that are digitally signed either by a Certificate Authority or by the owner of the private key (such certificates are referred to as \"self-signed\"). The first step to obtaining a certificate is to create a Certificate Signing Request (CSR) file. The OpenSSL command-line interface can be used to generate a CSR for a private key: openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem  Once the CSR file is generated, it can either be sent to a Certificate Authority for signing or used to generate a self-signed certificate. Creating a self-signed certificate using the OpenSSL command-line interface is illustrated in the example below: openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem  Once the certificate is generated, it can be used to generate a .pfx or .p12 file: openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem \\       -certfile ca-cert.pem -out ryans.pfx  Where:  in: is the signed certificate inkey: is the associated private key certfile: is a concatenation of all Certificate Authority (CA) certs into a single file, e.g. cat ca1-cert.pem ca2-cert.pem > ca-cert.pem"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_perfect_forward_secrecy","title":"Perfect forward secrecy","description":"The term forward secrecy or perfect forward secrecy describes a feature of key-agreement (i.e., key-exchange) methods. That is, the server and client keys are used to negotiate new temporary keys that are used specifically and only for the current communication session. Practically, this means that even if the server's private key is compromised, communication can only be decrypted by eavesdroppers if the attacker manages to obtain the key-pair specifically generated for the session. Perfect forward secrecy is achieved by randomly generating a key pair for key-agreement on every TLS\/SSL handshake (in contrast to using the same key for all sessions). Methods implementing this technique are called \"ephemeral\". Currently two methods are commonly used to achieve perfect forward secrecy (note the character \"E\" appended to the traditional abbreviations):  DHE: An ephemeral version of the Diffie-Hellman key-agreement protocol. ECDHE: An ephemeral version of the Elliptic Curve Diffie-Hellman key-agreement protocol.  Ephemeral methods may have some performance drawbacks, because key generation is expensive. To use perfect forward secrecy using DHE with the tls module, it is required to generate Diffie-Hellman parameters and specify them with the dhparam option to tls.createSecureContext(). The following illustrates the use of the OpenSSL command-line interface to generate such parameters: openssl dhparam -outform PEM -out dhparam.pem 2048  If using perfect forward secrecy using ECDHE, Diffie-Hellman parameters are not required and a default ECDHE curve will be used. The ecdhCurve property can be used when creating a TLS Server to specify the list of names of supported curves to use, see tls.createServer() for more info. Perfect forward secrecy was optional up to TLSv1.2, but it is not optional for TLSv1.3, because all TLSv1.3 cipher suites use ECDHE."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_alpn_and_sni","title":"ALPN and SNI","description":"ALPN (Application-Layer Protocol Negotiation Extension) and SNI (Server Name Indication) are TLS handshake extensions:  ALPN: Allows the use of one TLS server for multiple protocols (HTTP, HTTP\/2) SNI: Allows the use of one TLS server for multiple hostnames with different SSL certificates."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_pre_shared_keys","title":"Pre-shared keys","description":"TLS-PSK support is available as an alternative to normal certificate-based authentication. It uses a pre-shared key instead of certificates to authenticate a TLS connection, providing mutual authentication. TLS-PSK and public key infrastructure are not mutually exclusive. Clients and servers can accommodate both, choosing either of them during the normal cipher negotiation step. TLS-PSK is only a good choice where means exist to securely share a key with every connecting machine, so it does not replace PKI (Public Key Infrastructure) for the majority of TLS uses. The TLS-PSK implementation in OpenSSL has seen many security flaws in recent years, mostly because it is used only by a minority of applications. Please consider all alternative solutions before switching to PSK ciphers. Upon generating PSK it is of critical importance to use sufficient entropy as discussed in RFC 4086. Deriving a shared secret from a password or other low-entropy sources is not secure. PSK ciphers are disabled by default, and using TLS-PSK thus requires explicitly specifying a cipher suite with the ciphers option. The list of available ciphers can be retrieved via openssl ciphers -v 'PSK'. All TLS 1.3 ciphers are eligible for PSK but currently only those that use SHA256 digest are supported they can be retrieved via openssl ciphers -v -s -tls1_3 -psk. According to the RFC 4279, PSK identities up to 128 bytes in length and PSKs up to 64 bytes in length must be supported. As of OpenSSL 1.1.0 maximum identity size is 128 bytes, and maximum PSK length is 256 bytes. The current implementation doesn't support asynchronous PSK callbacks due to the limitations of the underlying OpenSSL API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_client_initiated_renegotiation_attack_mitigation","title":"Client-initiated renegotiation attack mitigation","description":"The TLS protocol allows clients to renegotiate certain aspects of the TLS session. Unfortunately, session renegotiation requires a disproportionate amount of server-side resources, making it a potential vector for denial-of-service attacks. To mitigate the risk, renegotiation is limited to three times every ten minutes. An 'error' event is emitted on the tls.TLSSocket instance when this threshold is exceeded. The limits are configurable:  tls.CLIENT_RENEG_LIMIT <number> Specifies the number of renegotiation requests. Default: 3. tls.CLIENT_RENEG_WINDOW <number> Specifies the time renegotiation window in seconds. Default: 600 (10 minutes).  The default renegotiation limits should not be modified without a full understanding of the implications and risks. TLSv1.3 does not support renegotiation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_session_resumption","title":"Session resumption","description":"Establishing a TLS session can be relatively slow. The process can be sped up by saving and later reusing the session state. There are several mechanisms to do so, discussed here from oldest to newest (and preferred)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_session_identifiers","title":"Session identifiers","description":"Servers generate a unique ID for new connections and send it to the client. Clients and servers save the session state. When reconnecting, clients send the ID of their saved session state and if the server also has the state for that ID, it can agree to use it. Otherwise, the server will create a new session. See RFC 2246 for more information, page 23 and 30. Resumption using session identifiers is supported by most web browsers when making HTTPS requests. For Node.js, clients wait for the 'session' event to get the session data, and provide the data to the session option of a subsequent tls.connect() to reuse the session. Servers must implement handlers for the 'newSession' and 'resumeSession' events to save and restore the session data using the session ID as the lookup key to reuse sessions. To reuse sessions across load balancers or cluster workers, servers must use a shared session cache (such as Redis) in their session handlers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_session_tickets","title":"Session tickets","description":"The servers encrypt the entire session state and send it to the client as a \"ticket\". When reconnecting, the state is sent to the server in the initial connection. This mechanism avoids the need for server-side session cache. If the server doesn't use the ticket, for any reason (failure to decrypt it, it's too old, etc.), it will create a new session and send a new ticket. See RFC 5077 for more information. Resumption using session tickets is becoming commonly supported by many web browsers when making HTTPS requests. For Node.js, clients use the same APIs for resumption with session identifiers as for resumption with session tickets. For debugging, if tls.TLSSocket.getTLSTicket() returns a value, the session data contains a ticket, otherwise it contains client-side session state. With TLSv1.3, be aware that multiple tickets may be sent by the server, resulting in multiple 'session' events, see 'session' for more information. Single process servers need no specific implementation to use session tickets. To use session tickets across server restarts or load balancers, servers must all have the same ticket keys. There are three 16-byte keys internally, but the tls API exposes them as a single 48-byte buffer for convenience. Its possible to get the ticket keys by calling server.getTicketKeys() on one server instance and then distribute them, but it is more reasonable to securely generate 48 bytes of secure random data and set them with the ticketKeys option of tls.createServer(). The keys should be regularly regenerated and server's keys can be reset with server.setTicketKeys(). Session ticket keys are cryptographic keys, and they must be stored securely. With TLS 1.2 and below, if they are compromised all sessions that used tickets encrypted with them can be decrypted. They should not be stored on disk, and they should be regenerated regularly. If clients advertise support for tickets, the server will send them. The server can disable tickets by supplying require('constants').SSL_OP_NO_TICKET in secureOptions. Both session identifiers and session tickets timeout, causing the server to create new sessions. The timeout can be configured with the sessionTimeout option of tls.createServer(). For all the mechanisms, when resumption fails, servers will create new sessions. Since failing to resume the session does not cause TLS\/HTTPS connection failures, it is easy to not notice unnecessarily poor TLS performance. The OpenSSL CLI can be used to verify that servers are resuming sessions. Use the -reconnect option to openssl s_client, for example: $ openssl s_client -connect localhost:443 -reconnect  Read through the debug output. The first connection should say \"New\", for example: New, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256  Subsequent connections should say \"Reused\", for example: Reused, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_modifying_the_default_tls_cipher_suite","title":"Modifying the default TLS cipher suite","description":"Node.js is built with a default suite of enabled and disabled TLS ciphers. This default cipher list can be configured when building Node.js to allow distributions to provide their own default list. The following command can be used to show the default cipher suite: node -p crypto.constants.defaultCoreCipherList | tr ':' '\\n' TLS_AES_256_GCM_SHA384 TLS_CHACHA20_POLY1305_SHA256 TLS_AES_128_GCM_SHA256 ECDHE-RSA-AES128-GCM-SHA256 ECDHE-ECDSA-AES128-GCM-SHA256 ECDHE-RSA-AES256-GCM-SHA384 ECDHE-ECDSA-AES256-GCM-SHA384 DHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-SHA256 DHE-RSA-AES128-SHA256 ECDHE-RSA-AES256-SHA384 DHE-RSA-AES256-SHA384 ECDHE-RSA-AES256-SHA256 DHE-RSA-AES256-SHA256 HIGH !aNULL !eNULL !EXPORT !DES !RC4 !MD5 !PSK !SRP !CAMELLIA  This default can be replaced entirely using the --tls-cipher-list command-line switch (directly, or via the NODE_OPTIONS environment variable). For instance, the following makes ECDHE-RSA-AES128-GCM-SHA256:!RC4 the default TLS cipher suite: node --tls-cipher-list='ECDHE-RSA-AES128-GCM-SHA256:!RC4' server.js  export NODE_OPTIONS=--tls-cipher-list='ECDHE-RSA-AES128-GCM-SHA256:!RC4' node server.js  The default can also be replaced on a per client or server basis using the ciphers option from tls.createSecureContext(), which is also available in tls.createServer(), tls.connect(), and when creating new tls.TLSSockets. The ciphers list can contain a mixture of TLSv1.3 cipher suite names, the ones that start with 'TLS_', and specifications for TLSv1.2 and below cipher suites. The TLSv1.2 ciphers support a legacy specification format, consult the OpenSSL cipher list format documentation for details, but those specifications do not apply to TLSv1.3 ciphers. The TLSv1.3 suites can only be enabled by including their full name in the cipher list. They cannot, for example, be enabled or disabled by using the legacy TLSv1.2 'EECDH' or '!EECDH' specification. Despite the relative order of TLSv1.3 and TLSv1.2 cipher suites, the TLSv1.3 protocol is significantly more secure than TLSv1.2, and will always be chosen over TLSv1.2 if the handshake indicates it is supported, and if any TLSv1.3 cipher suites are enabled. The default cipher suite included within Node.js has been carefully selected to reflect current security best practices and risk mitigation. Changing the default cipher suite can have a significant impact on the security of an application. The --tls-cipher-list switch and ciphers option should by used only if absolutely necessary. The default cipher suite prefers GCM ciphers for Chrome's 'modern cryptography' setting and also prefers ECDHE and DHE ciphers for perfect forward secrecy, while offering some backward compatibility. 128 bit AES is preferred over 192 and 256 bit AES in light of specific attacks affecting larger AES key sizes. Old clients that rely on insecure and deprecated RC4 or DES-based ciphers (like Internet Explorer 6) cannot complete the handshaking process with the default configuration. If these clients must be supported, the TLS recommendations may offer a compatible cipher suite. For more details on the format, see the OpenSSL cipher list format documentation. There are only 5 TLSv1.3 cipher suites:  'TLS_AES_256_GCM_SHA384' 'TLS_CHACHA20_POLY1305_SHA256' 'TLS_AES_128_GCM_SHA256' 'TLS_AES_128_CCM_SHA256' 'TLS_AES_128_CCM_8_SHA256'  The first 3 are enabled by default. The last 2 CCM-based suites are supported by TLSv1.3 because they may be more performant on constrained systems, but they are not enabled by default since they offer less security."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_events","title":"Trace events","description":"Source Code: lib\/trace_events.js The trace_events module provides a mechanism to centralize tracing information generated by V8, Node.js core, and userspace code. Tracing can be enabled with the --trace-event-categories command-line flag or by using the trace_events module. The --trace-event-categories flag accepts a list of comma-separated category names. The available categories are:  node: An empty placeholder. node.async_hooks: Enables capture of detailed async_hooks trace data. The async_hooks events have a unique asyncId and a special triggerId triggerAsyncId property. node.bootstrap: Enables capture of Node.js bootstrap milestones. node.console: Enables capture of console.time() and console.count() output. node.dns.native: Enables capture of trace data for DNS queries. node.environment: Enables capture of Node.js Environment milestones. node.fs.sync: Enables capture of trace data for file system sync methods. node.perf: Enables capture of Performance API measurements.  node.perf.usertiming: Enables capture of only Performance API User Timing measures and marks. node.perf.timerify: Enables capture of only Performance API timerify measurements.   node.promises.rejections: Enables capture of trace data tracking the number of unhandled Promise rejections and handled-after-rejections. node.vm.script: Enables capture of trace data for the vm module's runInNewContext(), runInContext(), and runInThisContext() methods. v8: The V8 events are GC, compiling, and execution related.  By default the node, node.async_hooks, and v8 categories are enabled. node --trace-event-categories v8,node,node.async_hooks server.js  Prior versions of Node.js required the use of the --trace-events-enabled flag to enable trace events. This requirement has been removed. However, the --trace-events-enabled flag may still be used and will enable the node, node.async_hooks, and v8 trace event categories by default. node --trace-events-enabled  # is equivalent to  node --trace-event-categories v8,node,node.async_hooks  Alternatively, trace events may be enabled using the trace_events module: const trace_events = require('trace_events'); const tracing = trace_events.createTracing({ categories: ['node.perf'] }); tracing.enable();  \/\/ Enable trace event capture for the 'node.perf' category  \/\/ do work  tracing.disable();  \/\/ Disable trace event capture for the 'node.perf' category  Running Node.js with tracing enabled will produce log files that can be opened in the chrome:\/\/tracing tab of Chrome. The logging file is by default called node_trace.${rotation}.log, where ${rotation} is an incrementing log-rotation id. The filepath pattern can be specified with --trace-event-file-pattern that accepts a template string that supports ${rotation} and ${pid}: node --trace-event-categories v8 --trace-event-file-pattern '${pid}-${rotation}.log' server.js  The tracing system uses the same time source as the one used by process.hrtime(). However the trace-event timestamps are expressed in microseconds, unlike process.hrtime() which returns nanoseconds. The features from this module are not available in Worker threads."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_trace_events_module","title":"The `trace_events` module","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_events_createtracing_options","title":"`trace_events.createTracing(options)`","description":"Creates and returns a Tracing object for the given set of categories. const trace_events = require('trace_events'); const categories = ['node.perf', 'node.async_hooks']; const tracing = trace_events.createTracing({ categories }); tracing.enable(); \/\/ do stuff tracing.disable();"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_trace_events_getenabledcategories","title":"`trace_events.getEnabledCategories()`","description":"Returns a comma-separated list of all currently-enabled trace event categories. The current set of enabled trace event categories is determined by the union of all currently-enabled Tracing objects and any categories enabled using the --trace-event-categories flag. Given the file test.js below, the command node --trace-event-categories node.perf test.js will print 'node.async_hooks,node.perf' to the console. const trace_events = require('trace_events'); const t1 = trace_events.createTracing({ categories: ['node.async_hooks'] }); const t2 = trace_events.createTracing({ categories: ['node.perf'] }); const t3 = trace_events.createTracing({ categories: ['v8'] });  t1.enable(); t2.enable();  console.log(trace_events.getEnabledCategories());"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tracing_object","title":"`Tracing` object","description":"The Tracing object is used to enable or disable tracing for sets of categories. Instances are created using the trace_events.createTracing() method. When created, the Tracing object is disabled. Calling the tracing.enable() method adds the categories to the set of enabled trace event categories. Calling tracing.disable() will remove the categories from the set of enabled trace event categories."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tracing_disable","title":"`tracing.disable()`","description":"Disables this Tracing object. Only trace event categories not covered by other enabled Tracing objects and not specified by the --trace-event-categories flag will be disabled. const trace_events = require('trace_events'); const t1 = trace_events.createTracing({ categories: ['node', 'v8'] }); const t2 = trace_events.createTracing({ categories: ['node.perf', 'node'] }); t1.enable(); t2.enable();  \/\/ Prints 'node,node.perf,v8' console.log(trace_events.getEnabledCategories());  t2.disable(); \/\/ Will only disable emission of the 'node.perf' category  \/\/ Prints 'node,v8' console.log(trace_events.getEnabledCategories());"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tracing_enable","title":"`tracing.enable()`","description":"Enables this Tracing object for the set of categories covered by the Tracing object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tty","title":"TTY","description":"Source Code: lib\/tty.js The tty module provides the tty.ReadStream and tty.WriteStream classes. In most cases, it will not be necessary or possible to use this module directly. However, it can be accessed using: const tty = require('tty');  When Node.js detects that it is being run with a text terminal (\"TTY\") attached, process.stdin will, by default, be initialized as an instance of tty.ReadStream and both process.stdout and process.stderr will, by default be instances of tty.WriteStream. The preferred method of determining whether Node.js is being run within a TTY context is to check that the value of the process.stdout.isTTY property is true: $ node -p -e \"Boolean(process.stdout.isTTY)\" true $ node -p -e \"Boolean(process.stdout.isTTY)\" | cat false  In most cases, there should be little to no reason for an application to manually create instances of the tty.ReadStream and tty.WriteStream classes."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_tty_isatty_fd","title":"`tty.isatty(fd)`","description":"The tty.isatty() method returns true if the given fd is associated with a TTY and false if it is not, including whenever fd is not a non-negative integer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_udp_datagram_sockets","title":"UDP\/datagram sockets","description":"Source Code: lib\/dgram.js The dgram module provides an implementation of UDP datagram sockets. const dgram = require('dgram'); const server = dgram.createSocket('udp4');  server.on('error', (err) => {   console.log(`server error:\\n${err.stack}`);   server.close(); });  server.on('message', (msg, rinfo) => {   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`); });  server.on('listening', () => {   const address = server.address();   console.log(`server listening ${address.address}:${address.port}`); });  server.bind(41234); \/\/ Prints: server listening 0.0.0.0:41234"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dgram_module_functions","title":"`dgram` module functions","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dgram_createsocket_options_callback","title":"`dgram.createSocket(options[, callback])`","description":"Creates a dgram.Socket object. Once the socket is created, calling socket.bind() will instruct the socket to begin listening for datagram messages. When address and port are not passed to socket.bind() the method will bind the socket to the \"all interfaces\" address on a random port (it does the right thing for both udp4 and udp6 sockets). The bound address and port can be retrieved using socket.address().address and socket.address().port."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_dgram_createsocket_type_callback","title":"`dgram.createSocket(type[, callback])`","description":"Creates a dgram.Socket object of the specified type. Once the socket is created, calling socket.bind() will instruct the socket to begin listening for datagram messages. When address and port are not passed to socket.bind() the method will bind the socket to the \"all interfaces\" address on a random port (it does the right thing for both udp4 and udp6 sockets). The bound address and port can be retrieved using socket.address().address and socket.address().port."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url","title":"URL","description":"Source Code: lib\/url.js The url module provides utilities for URL resolution and parsing. It can be accessed using: const url = require('url');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_strings_and_url_objects","title":"URL strings and URL objects","description":"A URL string is a structured string containing multiple meaningful components. When parsed, a URL object is returned containing properties for each of these components. The url module provides two APIs for working with URLs: a legacy API that is Node.js specific, and a newer API that implements the same WHATWG URL Standard used by web browsers. A comparison between the WHATWG and Legacy APIs is provided below. Above the URL 'http:\/\/user:pass@sub.example.com:8080\/p\/a\/t\/h?query=string#hash', properties of an object returned by the legacy url.parse() are shown. Below it are properties of a WHATWG URL object. WHATWG URL's origin property includes protocol and host, but not username or password. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                                              href                                              \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 protocol \u2502  \u2502        auth         \u2502          host          \u2502           path            \u2502 hash  \u2502 \u2502          \u2502  \u2502                     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502 \u2502          \u2502  \u2502                     \u2502    hostname     \u2502 port \u2502 pathname \u2502     search     \u2502       \u2502 \u2502          \u2502  \u2502                     \u2502                 \u2502      \u2502          \u251c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502 \u2502          \u2502  \u2502                     \u2502                 \u2502      \u2502          \u2502 \u2502    query     \u2502       \u2502 \"  https:   \/\/    user   :   pass   @ sub.example.com : 8080   \/p\/a\/t\/h  ?  query=string   #hash \" \u2502          \u2502  \u2502          \u2502          \u2502    hostname     \u2502 port \u2502          \u2502                \u2502       \u2502 \u2502          \u2502  \u2502          \u2502          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u2502                \u2502       \u2502 \u2502 protocol \u2502  \u2502 username \u2502 password \u2502          host          \u2502          \u2502                \u2502       \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u2502                \u2502       \u2502 \u2502   origin    \u2502                     \u2502         origin         \u2502 pathname \u2502     search     \u2502 hash  \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502                                              href                                              \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (All spaces in the \"\" line should be ignored. They are purely for formatting.)  Parsing the URL string using the WHATWG API: const myURL =   new URL('https:\/\/user:pass@sub.example.com:8080\/p\/a\/t\/h?query=string#hash');  Parsing the URL string using the Legacy API: const url = require('url'); const myURL =   url.parse('https:\/\/user:pass@sub.example.com:8080\/p\/a\/t\/h?query=string#hash');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_the_whatwg_url_api","title":"The WHATWG URL API","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_domaintoascii_domain","title":"`url.domainToASCII(domain)`","description":"Returns the Punycode ASCII serialization of the domain. If domain is an invalid domain, the empty string is returned. It performs the inverse operation to url.domainToUnicode(). const url = require('url'); console.log(url.domainToASCII('espa\u00f1ol.com')); \/\/ Prints xn--espaol-zwa.com console.log(url.domainToASCII('\u4e2d\u6587.com')); \/\/ Prints xn--fiq228c.com console.log(url.domainToASCII('xn--i\u00f1valid.com')); \/\/ Prints an empty string"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_domaintounicode_domain","title":"`url.domainToUnicode(domain)`","description":"Returns the Unicode serialization of the domain. If domain is an invalid domain, the empty string is returned. It performs the inverse operation to url.domainToASCII(). const url = require('url'); console.log(url.domainToUnicode('xn--espaol-zwa.com')); \/\/ Prints espa\u00f1ol.com console.log(url.domainToUnicode('xn--fiq228c.com')); \/\/ Prints \u4e2d\u6587.com console.log(url.domainToUnicode('xn--i\u00f1valid.com')); \/\/ Prints an empty string"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_fileurltopath_url","title":"`url.fileURLToPath(url)`","description":"This function ensures the correct decodings of percent-encoded characters as well as ensuring a cross-platform valid absolute path string. new URL('file:\/\/\/C:\/path\/').pathname;    \/\/ Incorrect: \/C:\/path\/ fileURLToPath('file:\/\/\/C:\/path\/');       \/\/ Correct:   C:\\path\\ (Windows)  new URL('file:\/\/nas\/foo.txt').pathname;  \/\/ Incorrect: \/foo.txt fileURLToPath('file:\/\/nas\/foo.txt');     \/\/ Correct:   \\\\nas\\foo.txt (Windows)  new URL('file:\/\/\/\u4f60\u597d.txt').pathname;    \/\/ Incorrect: \/%E4%BD%A0%E5%A5%BD.txt fileURLToPath('file:\/\/\/\u4f60\u597d.txt');       \/\/ Correct:   \/\u4f60\u597d.txt (POSIX)  new URL('file:\/\/\/hello world').pathname; \/\/ Incorrect: \/hello%20world fileURLToPath('file:\/\/\/hello world');    \/\/ Correct:   \/hello world (POSIX)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_format_url_options","title":"`url.format(URL[, options])`","description":"Returns a customizable serialization of a URL String representation of a WHATWG URL object. The URL object has both a toString() method and href property that return string serializations of the URL. These are not, however, customizable in any way. The url.format(URL[, options]) method allows for basic customization of the output. const myURL = new URL('https:\/\/a:b@\u6e2c\u8a66?abc#foo');  console.log(myURL.href); \/\/ Prints https:\/\/a:b@xn--g6w251d\/?abc#foo  console.log(myURL.toString()); \/\/ Prints https:\/\/a:b@xn--g6w251d\/?abc#foo  console.log(url.format(myURL, { fragment: false, unicode: true, auth: false })); \/\/ Prints 'https:\/\/\u6e2c\u8a66\/?abc'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_pathtofileurl_path","title":"`url.pathToFileURL(path)`","description":"This function ensures that path is resolved absolutely, and that the URL control characters are correctly encoded when converting into a File URL. new URL(__filename);                \/\/ Incorrect: throws (POSIX) new URL(__filename);                \/\/ Incorrect: C:\\... (Windows) pathToFileURL(__filename);          \/\/ Correct:   file:\/\/\/... (POSIX) pathToFileURL(__filename);          \/\/ Correct:   file:\/\/\/C:\/... (Windows)  new URL('\/foo#1', 'file:');         \/\/ Incorrect: file:\/\/\/foo#1 pathToFileURL('\/foo#1');            \/\/ Correct:   file:\/\/\/foo%231 (POSIX)  new URL('\/some\/path%.c', 'file:'); \/\/ Incorrect: file:\/\/\/some\/path%.c pathToFileURL('\/some\/path%.c');    \/\/ Correct:   file:\/\/\/some\/path%25.c (POSIX)"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_legacy_url_api","title":"Legacy URL API","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_format_urlobject","title":"`url.format(urlObject)`","description":"The url.format() method returns a formatted URL string derived from urlObject. url.format({   protocol: 'https',   hostname: 'example.com',   pathname: '\/some\/path',   query: {     page: 1,     format: 'json'   } });  \/\/ => 'https:\/\/example.com\/some\/path?page=1&format=json'  If urlObject is not an object or a string, url.format() will throw a TypeError. The formatting process operates as follows:  A new empty string result is created. If urlObject.protocol is a string, it is appended as-is to result. Otherwise, if urlObject.protocol is not undefined and is not a string, an Error is thrown. For all string values of urlObject.protocol that do not end with an ASCII colon (:) character, the literal string : will be appended to result. If either of the following conditions is true, then the literal string \/\/ will be appended to result:  urlObject.slashes property is true; urlObject.protocol begins with http, https, ftp, gopher, or file;   If the value of the urlObject.auth property is truthy, and either urlObject.host or urlObject.hostname are not undefined, the value of urlObject.auth will be coerced into a string and appended to result followed by the literal string @. If the urlObject.host property is undefined then:  If the urlObject.hostname is a string, it is appended to result. Otherwise, if urlObject.hostname is not undefined and is not a string, an Error is thrown. If the urlObject.port property value is truthy, and urlObject.hostname is not undefined:  The literal string : is appended to result, and The value of urlObject.port is coerced to a string and appended to result.     Otherwise, if the urlObject.host property value is truthy, the value of urlObject.host is coerced to a string and appended to result. If the urlObject.pathname property is a string that is not an empty string:  If the urlObject.pathname does not start with an ASCII forward slash (\/), then the literal string '\/' is appended to result. The value of urlObject.pathname is appended to result.   Otherwise, if urlObject.pathname is not undefined and is not a string, an Error is thrown. If the urlObject.search property is undefined and if the urlObject.query property is an Object, the literal string ? is appended to result followed by the output of calling the querystring module's stringify() method passing the value of urlObject.query. Otherwise, if urlObject.search is a string:  If the value of urlObject.search does not start with the ASCII question mark (?) character, the literal string ? is appended to result. The value of urlObject.search is appended to result.   Otherwise, if urlObject.search is not undefined and is not a string, an Error is thrown. If the urlObject.hash property is a string:  If the value of urlObject.hash does not start with the ASCII hash (#) character, the literal string # is appended to result. The value of urlObject.hash is appended to result.   Otherwise, if the urlObject.hash property is not undefined and is not a string, an Error is thrown. result is returned."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_parse_urlstring_parsequerystring_slashesdenotehost","title":"`url.parse(urlString[, parseQueryString[, slashesDenoteHost]])`","description":"The url.parse() method takes a URL string, parses it, and returns a URL object. A TypeError is thrown if urlString is not a string. A URIError is thrown if the auth property is present but cannot be decoded. Use of the legacy url.parse() method is discouraged. Users should use the WHATWG URL API. Because the url.parse() method uses a lenient, non-standard algorithm for parsing URL strings, security issues can be introduced. Specifically, issues with host name spoofing and incorrect handling of usernames and passwords have been identified."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_url_resolve_from_to","title":"`url.resolve(from, to)`","description":"The url.resolve() method resolves a target URL relative to a base URL in a manner similar to that of a Web browser resolving an anchor tag HREF. const url = require('url'); url.resolve('\/one\/two\/three', 'four');         \/\/ '\/one\/two\/four' url.resolve('http:\/\/example.com\/', '\/one');    \/\/ 'http:\/\/example.com\/one' url.resolve('http:\/\/example.com\/one', '\/two'); \/\/ 'http:\/\/example.com\/two'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_legacy_urlobject","title":"Legacy `urlObject`","description":"The legacy urlObject (require('url').Url) is created and returned by the url.parse() function."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_percent_encoding_in_urls","title":"Percent-encoding in URLs","description":"URLs are permitted to only contain a certain range of characters. Any character falling outside of that range must be encoded. How such characters are encoded, and which characters to encode depends entirely on where the character is located within the structure of the URL."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_legacy_api","title":"Legacy API","description":"Within the Legacy API, spaces (' ') and the following characters will be automatically escaped in the properties of URL objects: < > \" ` \\r \\n \\t { } | \\ ^ '  For example, the ASCII space character (' ') is encoded as %20. The ASCII forward slash (\/) character is encoded as %3C."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_whatwg_api","title":"WHATWG API","description":"The WHATWG URL Standard uses a more selective and fine grained approach to selecting encoded characters than that used by the Legacy API. The WHATWG algorithm defines four \"percent-encode sets\" that describe ranges of characters that must be percent-encoded:   The C0 control percent-encode set includes code points in range U+0000 to U+001F (inclusive) and all code points greater than U+007E.   The fragment percent-encode set includes the C0 control percent-encode set and code points U+0020, U+0022, U+003C, U+003E, and U+0060.   The path percent-encode set includes the C0 control percent-encode set and code points U+0020, U+0022, U+0023, U+003C, U+003E, U+003F, U+0060, U+007B, and U+007D.   The userinfo encode set includes the path percent-encode set and code points U+002F, U+003A, U+003B, U+003D, U+0040, U+005B, U+005C, U+005D, U+005E, and U+007C.   The userinfo percent-encode set is used exclusively for username and passwords encoded within the URL. The path percent-encode set is used for the path of most URLs. The fragment percent-encode set is used for URL fragments. The C0 control percent-encode set is used for host and path under certain specific conditions, in addition to all other cases. When non-ASCII characters appear within a host name, the host name is encoded using the Punycode algorithm. Note, however, that a host name may contain both Punycode encoded and percent-encoded characters: const myURL = new URL('https:\/\/%CF%80.example.com\/foo'); console.log(myURL.href); \/\/ Prints https:\/\/xn--1xa.example.com\/foo console.log(myURL.origin); \/\/ Prints https:\/\/xn--1xa.example.com"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util","title":"Util","description":"Source Code: lib\/util.js The util module supports the needs of Node.js internal APIs. Many of the utilities are useful for application and module developers as well. To access it: const util = require('util');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_callbackify_original","title":"`util.callbackify(original)`","description":"Takes an async function (or a function that returns a Promise) and returns a function following the error-first callback style, i.e. taking an (err, value) => ... callback as the last argument. In the callback, the first argument will be the rejection reason (or null if the Promise resolved), and the second argument will be the resolved value. const util = require('util');  async function fn() {   return 'hello world'; } const callbackFunction = util.callbackify(fn);  callbackFunction((err, ret) => {   if (err) throw err;   console.log(ret); });  Will print: hello world  The callback is executed asynchronously, and will have a limited stack trace. If the callback throws, the process will emit an 'uncaughtException' event, and if not handled will exit. Since null has a special meaning as the first argument to a callback, if a wrapped function rejects a Promise with a falsy value as a reason, the value is wrapped in an Error with the original value stored in a field named reason. function fn() {   return Promise.reject(null); } const callbackFunction = util.callbackify(fn);  callbackFunction((err, ret) => {   \/\/ When the Promise was rejected with `null` it is wrapped with an Error and   \/\/ the original value is stored in `reason`.   err && err.hasOwnProperty('reason') && err.reason === null;  \/\/ true });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_debuglog_section_callback","title":"`util.debuglog(section[, callback])`","description":"The util.debuglog() method is used to create a function that conditionally writes debug messages to stderr based on the existence of the NODE_DEBUG environment variable. If the section name appears within the value of that environment variable, then the returned function operates similar to console.error(). If not, then the returned function is a no-op. const util = require('util'); const debuglog = util.debuglog('foo');  debuglog('hello from foo [%d]', 123);  If this program is run with NODE_DEBUG=foo in the environment, then it will output something like: FOO 3245: hello from foo [123]  where 3245 is the process id. If it is not run with that environment variable set, then it will not print anything. The section supports wildcard also: const util = require('util'); const debuglog = util.debuglog('foo-bar');  debuglog('hi there, it\\'s foo-bar [%d]', 2333);  if it is run with NODE_DEBUG=foo* in the environment, then it will output something like: FOO-BAR 3257: hi there, it's foo-bar [2333]  Multiple comma-separated section names may be specified in the NODE_DEBUG environment variable: NODE_DEBUG=fs,net,tls. The optional callback argument can be used to replace the logging function with a different function that doesn't have any initialization or unnecessary wrapping. const util = require('util'); let debuglog = util.debuglog('internals', (debug) => {   \/\/ Replace with a logging function that optimizes out   \/\/ testing if the section is enabled   debuglog = debug; });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_debuglog_enabled","title":"`debuglog().enabled`","description":"<boolean>  The util.debuglog().enabled getter is used to create a test that can be used in conditionals based on the existence of the NODE_DEBUG environment variable. If the section name appears within the value of that environment variable, then the returned value will be true. If not, then the returned value will be false. const util = require('util'); const enabled = util.debuglog('foo').enabled; if (enabled) {   console.log('hello from foo [%d]', 123); }  If this program is run with NODE_DEBUG=foo in the environment, then it will output something like: hello from foo [123]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_debug_section","title":"`util.debug(section)`","description":"Alias for util.debuglog. Usage allows for readability of that doesn't imply logging when only using util.debuglog().enabled."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_deprecate_fn_msg_code","title":"`util.deprecate(fn, msg[, code])`","description":"The util.deprecate() method wraps fn (which may be a function or class) in such a way that it is marked as deprecated. const util = require('util');  exports.obsoleteFunction = util.deprecate(() => {   \/\/ Do something here. }, 'obsoleteFunction() is deprecated. Use newShinyFunction() instead.');  When called, util.deprecate() will return a function that will emit a DeprecationWarning using the 'warning' event. The warning will be emitted and printed to stderr the first time the returned function is called. After the warning is emitted, the wrapped function is called without emitting a warning. If the same optional code is supplied in multiple calls to util.deprecate(), the warning will be emitted only once for that code. const util = require('util');  const fn1 = util.deprecate(someFunction, someMessage, 'DEP0001'); const fn2 = util.deprecate(someOtherFunction, someOtherMessage, 'DEP0001'); fn1(); \/\/ Emits a deprecation warning with code DEP0001 fn2(); \/\/ Does not emit a deprecation warning because it has the same code  If either the --no-deprecation or --no-warnings command-line flags are used, or if the process.noDeprecation property is set to true prior to the first deprecation warning, the util.deprecate() method does nothing. If the --trace-deprecation or --trace-warnings command-line flags are set, or the process.traceDeprecation property is set to true, a warning and a stack trace are printed to stderr the first time the deprecated function is called. If the --throw-deprecation command-line flag is set, or the process.throwDeprecation property is set to true, then an exception will be thrown when the deprecated function is called. The --throw-deprecation command-line flag and process.throwDeprecation property take precedence over --trace-deprecation and process.traceDeprecation."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_format_format_args","title":"`util.format(format[, ...args])`","description":"The util.format() method returns a formatted string using the first argument as a printf-like format string which can contain zero or more format specifiers. Each specifier is replaced with the converted value from the corresponding argument. Supported specifiers are:  %s: String will be used to convert all values except BigInt, Object and -0. BigInt values will be represented with an n and Objects that have no user defined toString function are inspected using util.inspect() with options { depth: 0, colors: false, compact: 3 }. %d: Number will be used to convert all values except BigInt and Symbol. %i: parseInt(value, 10) is used for all values except BigInt and Symbol. %f: parseFloat(value) is used for all values expect Symbol. %j: JSON. Replaced with the string '[Circular]' if the argument contains circular references. %o: Object. A string representation of an object with generic JavaScript object formatting. Similar to util.inspect() with options { showHidden: true, showProxy: true }. This will show the full object including non-enumerable properties and proxies. %O: Object. A string representation of an object with generic JavaScript object formatting. Similar to util.inspect() without options. This will show the full object not including non-enumerable properties and proxies. %c: CSS. This specifier is ignored and will skip any CSS passed in. %%: single percent sign ('%'). This does not consume an argument. Returns: <string> The formatted string  If a specifier does not have a corresponding argument, it is not replaced: util.format('%s:%s', 'foo'); \/\/ Returns: 'foo:%s'  Values that are not part of the format string are formatted using util.inspect() if their type is not string. If there are more arguments passed to the util.format() method than the number of specifiers, the extra arguments are concatenated to the returned string, separated by spaces: util.format('%s:%s', 'foo', 'bar', 'baz'); \/\/ Returns: 'foo:bar baz'  If the first argument does not contain a valid format specifier, util.format() returns a string that is the concatenation of all arguments separated by spaces: util.format(1, 2, 3); \/\/ Returns: '1 2 3'  If only one argument is passed to util.format(), it is returned as it is without any formatting: util.format('%% %s'); \/\/ Returns: '%% %s'  util.format() is a synchronous method that is intended as a debugging tool. Some input values can have a significant performance overhead that can block the event loop. Use this function with care and never in a hot code path."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_formatwithoptions_inspectoptions_format_args","title":"`util.formatWithOptions(inspectOptions, format[, ...args])`","description":"This function is identical to util.format(), except in that it takes an inspectOptions argument which specifies options that are passed along to util.inspect(). util.formatWithOptions({ colors: true }, 'See object %O', { foo: 42 }); \/\/ Returns 'See object { foo: 42 }', where `42` is colored as a number \/\/ when printed to a terminal."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_getsystemerrorname_err","title":"`util.getSystemErrorName(err)`","description":"Returns the string name for a numeric error code that comes from a Node.js API. The mapping between error codes and error names is platform-dependent. See Common System Errors for the names of common errors. fs.access('file\/that\/does\/not\/exist', (err) => {   const name = util.getSystemErrorName(err.errno);   console.error(name);  \/\/ ENOENT });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_inherits_constructor_superconstructor","title":"`util.inherits(constructor, superConstructor)`","description":"Usage of util.inherits() is discouraged. Please use the ES6 class and extends keywords to get language level inheritance support. Also note that the two styles are semantically incompatible. Inherit the prototype methods from one constructor into another. The prototype of constructor will be set to a new object created from superConstructor. This mainly adds some input validation on top of Object.setPrototypeOf(constructor.prototype, superConstructor.prototype). As an additional convenience, superConstructor will be accessible through the constructor.super_ property. const util = require('util'); const EventEmitter = require('events');  function MyStream() {   EventEmitter.call(this); }  util.inherits(MyStream, EventEmitter);  MyStream.prototype.write = function(data) {   this.emit('data', data); };  const stream = new MyStream();  console.log(stream instanceof EventEmitter); \/\/ true console.log(MyStream.super_ === EventEmitter); \/\/ true  stream.on('data', (data) => {   console.log(`Received data: \"${data}\"`); }); stream.write('It works!'); \/\/ Received data: \"It works!\"  ES6 example using class and extends: const EventEmitter = require('events');  class MyStream extends EventEmitter {   write(data) {     this.emit('data', data);   } }  const stream = new MyStream();  stream.on('data', (data) => {   console.log(`Received data: \"${data}\"`); }); stream.write('With ES6');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_inspect_object_options","title":"`util.inspect(object[, options])`","description":"The util.inspect() method returns a string representation of object that is intended for debugging. The output of util.inspect may change at any time and should not be depended upon programmatically. Additional options may be passed that alter the result. util.inspect() will use the constructor's name and\/or @@toStringTag to make an identifiable tag for an inspected value. class Foo {   get [Symbol.toStringTag]() {     return 'bar';   } }  class Bar {}  const baz = Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } });  util.inspect(new Foo()); \/\/ 'Foo [bar] {}' util.inspect(new Bar()); \/\/ 'Bar {}' util.inspect(baz);       \/\/ '[foo] {}'  Circular references point to their anchor by using a reference index: const { inspect } = require('util');  const obj = {}; obj.a = [obj]; obj.b = {}; obj.b.inner = obj.b; obj.b.obj = obj;  console.log(inspect(obj)); \/\/ <ref *1> { \/\/   a: [ [Circular *1] ], \/\/   b: <ref *2> { inner: [Circular *2], obj: [Circular *1] } \/\/ }  The following example inspects all properties of the util object: const util = require('util');  console.log(util.inspect(util, { showHidden: true, depth: null }));  The following example highlights the effect of the compact option: const util = require('util');  const o = {   a: [1, 2, [[     'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do ' +       'eiusmod tempor incididunt ut labore et dolore magna aliqua.',     'test',     'foo']], 4],   b: new Map([['za', 1], ['zb', 'test']]) }; console.log(util.inspect(o, { compact: true, depth: 5, breakLength: 80 }));  \/\/ { a: \/\/   [ 1, \/\/     2, \/\/     [ [ 'Lorem ipsum dolor sit amet, consectetur [...]', \/\/ A long line \/\/           'test', \/\/           'foo' ] ], \/\/     4 ], \/\/   b: Map(2) { 'za' => 1, 'zb' => 'test' } }  \/\/ Setting `compact` to false changes the output to be more reader friendly. console.log(util.inspect(o, { compact: false, depth: 5, breakLength: 80 }));  \/\/ { \/\/   a: [ \/\/     1, \/\/     2, \/\/     [ \/\/       [ \/\/         'Lorem ipsum dolor sit amet, consectetur ' + \/\/           'adipiscing elit, sed do eiusmod tempor ' + \/\/           'incididunt ut labore et dolore magna ' + \/\/           'aliqua., \/\/         'test', \/\/         'foo' \/\/       ] \/\/     ], \/\/     4 \/\/   ], \/\/   b: Map(2) { \/\/     'za' => 1, \/\/     'zb' => 'test' \/\/   } \/\/ }  \/\/ Setting `breakLength` to e.g. 150 will print the \"Lorem ipsum\" text in a \/\/ single line. \/\/ Reducing the `breakLength` will split the \"Lorem ipsum\" text in smaller \/\/ chunks.  The showHidden option allows WeakMap and WeakSet entries to be inspected. If there are more entries than maxArrayLength, there is no guarantee which entries are displayed. That means retrieving the same WeakSet entries twice may result in different output. Furthermore, entries with no remaining strong references may be garbage collected at any time. const { inspect } = require('util');  const obj = { a: 1 }; const obj2 = { b: 2 }; const weakSet = new WeakSet([obj, obj2]);  console.log(inspect(weakSet, { showHidden: true })); \/\/ WeakSet { { a: 1 }, { b: 2 } }  The sorted option ensures that an object's property insertion order does not impact the result of util.inspect(). const { inspect } = require('util'); const assert = require('assert');  const o1 = {   b: [2, 3, 1],   a: '`a` comes before `b`',   c: new Set([2, 3, 1]) }; console.log(inspect(o1, { sorted: true })); \/\/ { a: '`a` comes before `b`', b: [ 2, 3, 1 ], c: Set(3) { 1, 2, 3 } } console.log(inspect(o1, { sorted: (a, b) => b.localeCompare(a) })); \/\/ { c: Set(3) { 3, 2, 1 }, b: [ 2, 3, 1 ], a: '`a` comes before `b`' }  const o2 = {   c: new Set([2, 1, 3]),   a: '`a` comes before `b`',   b: [2, 3, 1] }; assert.strict.equal(   inspect(o1, { sorted: true }),   inspect(o2, { sorted: true }) );  util.inspect() is a synchronous method intended for debugging. Its maximum output length is approximately 128 MB. Inputs that result in longer output will be truncated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_inspect_object_showhidden_depth_colors","title":"`util.inspect(object[, showHidden[, depth[, colors]]])`","description":"The util.inspect() method returns a string representation of object that is intended for debugging. The output of util.inspect may change at any time and should not be depended upon programmatically. Additional options may be passed that alter the result. util.inspect() will use the constructor's name and\/or @@toStringTag to make an identifiable tag for an inspected value. class Foo {   get [Symbol.toStringTag]() {     return 'bar';   } }  class Bar {}  const baz = Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } });  util.inspect(new Foo()); \/\/ 'Foo [bar] {}' util.inspect(new Bar()); \/\/ 'Bar {}' util.inspect(baz);       \/\/ '[foo] {}'  Circular references point to their anchor by using a reference index: const { inspect } = require('util');  const obj = {}; obj.a = [obj]; obj.b = {}; obj.b.inner = obj.b; obj.b.obj = obj;  console.log(inspect(obj)); \/\/ <ref *1> { \/\/   a: [ [Circular *1] ], \/\/   b: <ref *2> { inner: [Circular *2], obj: [Circular *1] } \/\/ }  The following example inspects all properties of the util object: const util = require('util');  console.log(util.inspect(util, { showHidden: true, depth: null }));  The following example highlights the effect of the compact option: const util = require('util');  const o = {   a: [1, 2, [[     'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do ' +       'eiusmod tempor incididunt ut labore et dolore magna aliqua.',     'test',     'foo']], 4],   b: new Map([['za', 1], ['zb', 'test']]) }; console.log(util.inspect(o, { compact: true, depth: 5, breakLength: 80 }));  \/\/ { a: \/\/   [ 1, \/\/     2, \/\/     [ [ 'Lorem ipsum dolor sit amet, consectetur [...]', \/\/ A long line \/\/           'test', \/\/           'foo' ] ], \/\/     4 ], \/\/   b: Map(2) { 'za' => 1, 'zb' => 'test' } }  \/\/ Setting `compact` to false changes the output to be more reader friendly. console.log(util.inspect(o, { compact: false, depth: 5, breakLength: 80 }));  \/\/ { \/\/   a: [ \/\/     1, \/\/     2, \/\/     [ \/\/       [ \/\/         'Lorem ipsum dolor sit amet, consectetur ' + \/\/           'adipiscing elit, sed do eiusmod tempor ' + \/\/           'incididunt ut labore et dolore magna ' + \/\/           'aliqua., \/\/         'test', \/\/         'foo' \/\/       ] \/\/     ], \/\/     4 \/\/   ], \/\/   b: Map(2) { \/\/     'za' => 1, \/\/     'zb' => 'test' \/\/   } \/\/ }  \/\/ Setting `breakLength` to e.g. 150 will print the \"Lorem ipsum\" text in a \/\/ single line. \/\/ Reducing the `breakLength` will split the \"Lorem ipsum\" text in smaller \/\/ chunks.  The showHidden option allows WeakMap and WeakSet entries to be inspected. If there are more entries than maxArrayLength, there is no guarantee which entries are displayed. That means retrieving the same WeakSet entries twice may result in different output. Furthermore, entries with no remaining strong references may be garbage collected at any time. const { inspect } = require('util');  const obj = { a: 1 }; const obj2 = { b: 2 }; const weakSet = new WeakSet([obj, obj2]);  console.log(inspect(weakSet, { showHidden: true })); \/\/ WeakSet { { a: 1 }, { b: 2 } }  The sorted option ensures that an object's property insertion order does not impact the result of util.inspect(). const { inspect } = require('util'); const assert = require('assert');  const o1 = {   b: [2, 3, 1],   a: '`a` comes before `b`',   c: new Set([2, 3, 1]) }; console.log(inspect(o1, { sorted: true })); \/\/ { a: '`a` comes before `b`', b: [ 2, 3, 1 ], c: Set(3) { 1, 2, 3 } } console.log(inspect(o1, { sorted: (a, b) => b.localeCompare(a) })); \/\/ { c: Set(3) { 3, 2, 1 }, b: [ 2, 3, 1 ], a: '`a` comes before `b`' }  const o2 = {   c: new Set([2, 1, 3]),   a: '`a` comes before `b`',   b: [2, 3, 1] }; assert.strict.equal(   inspect(o1, { sorted: true }),   inspect(o2, { sorted: true }) );  util.inspect() is a synchronous method intended for debugging. Its maximum output length is approximately 128 MB. Inputs that result in longer output will be truncated."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_customizing_util_inspect_colors","title":"Customizing `util.inspect` colors","description":"Color output (if enabled) of util.inspect is customizable globally via the util.inspect.styles and util.inspect.colors properties. util.inspect.styles is a map associating a style name to a color from util.inspect.colors. The default styles and associated colors are:  bigint: yellow boolean: yellow date: magenta module: underline name: (no styling) null: bold number: yellow regexp: red special: cyan (e.g., Proxies) string: green symbol: green undefined: grey  Color styling uses ANSI control codes that may not be supported on all terminals. To verify color support use tty.hasColors(). Predefined control codes are listed below (grouped as \"Modifiers\", \"Foreground colors\", and \"Background colors\")."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_modifiers","title":"Modifiers","description":"Modifier support varies throughout different terminals. They will mostly be ignored, if not supported.  reset - Resets all (color) modifiers to their defaults bold - Make text bold italic - Make text italic underline - Make text underlined strikethrough - Puts a horizontal line through the center of the text (Alias: strikeThrough, crossedout, crossedOut) hidden - Prints the text, but makes it invisible (Alias: conceal) dim - Decreased color intensity (Alias: faint) overlined - Make text overlined blink - Hides and shows the text in an interval inverse - Swap foreground and background colors (Alias: swapcolors, swapColors) doubleunderline - Make text double underlined (Alias: doubleUnderline) framed - Draw a frame around the text"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_foreground_colors","title":"Foreground colors","description":"black red green yellow blue magenta cyan white gray (alias: grey, blackBright) redBright greenBright yellowBright blueBright magentaBright cyanBright whiteBright"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_background_colors","title":"Background colors","description":"bgBlack bgRed bgGreen bgYellow bgBlue bgMagenta bgCyan bgWhite bgGray (alias: bgGrey, bgBlackBright) bgRedBright bgGreenBright bgYellowBright bgBlueBright bgMagentaBright bgCyanBright bgWhiteBright"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_custom_inspection_functions_on_objects","title":"Custom inspection functions on objects","description":"Objects may also define their own [util.inspect.custom](depth, opts) function, which util.inspect() will invoke and use the result of when inspecting the object: const util = require('util');  class Box {   constructor(value) {     this.value = value;   }    [util.inspect.custom](depth, options) {     if (depth < 0) {       return options.stylize('[Box]', 'special');     }      const newOptions = Object.assign({}, options, {       depth: options.depth === null ? null : options.depth - 1     });      \/\/ Five space padding because that's the size of \"Box< \".     const padding = ' '.repeat(5);     const inner = util.inspect(this.value, newOptions)                       .replace(\/\\n\/g, `\\n${padding}`);     return `${options.stylize('Box', 'special')}< ${inner} >`;   } }  const box = new Box(true);  util.inspect(box); \/\/ Returns: \"Box< true >\"  Custom [util.inspect.custom](depth, opts) functions typically return a string but may return a value of any type that will be formatted accordingly by util.inspect(). const util = require('util');  const obj = { foo: 'this will not show up in the inspect() output' }; obj[util.inspect.custom] = (depth) => {   return { bar: 'baz' }; };  util.inspect(obj); \/\/ Returns: \"{ bar: 'baz' }\""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isdeepstrictequal_val1_val2","title":"`util.isDeepStrictEqual(val1, val2)`","description":"Returns true if there is deep strict equality between val1 and val2. Otherwise, returns false. See assert.deepStrictEqual() for more information about deep strict equality."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_promisify_original","title":"`util.promisify(original)`","description":"Takes a function following the common error-first callback style, i.e. taking an (err, value) => ... callback as the last argument, and returns a version that returns promises. const util = require('util'); const fs = require('fs');  const stat = util.promisify(fs.stat); stat('.').then((stats) => {   \/\/ Do something with `stats` }).catch((error) => {   \/\/ Handle the error. });  Or, equivalently using async functions: const util = require('util'); const fs = require('fs');  const stat = util.promisify(fs.stat);  async function callStat() {   const stats = await stat('.');   console.log(`This directory is owned by ${stats.uid}`); }  If there is an original[util.promisify.custom] property present, promisify will return its value, see Custom promisified functions. promisify() assumes that original is a function taking a callback as its final argument in all cases. If original is not a function, promisify() will throw an error. If original is a function but its last argument is not an error-first callback, it will still be passed an error-first callback as its last argument. Using promisify() on class methods or other methods that use this may not work as expected unless handled specially: const util = require('util');  class Foo {   constructor() {     this.a = 42;   }    bar(callback) {     callback(null, this.a);   } }  const foo = new Foo();  const naiveBar = util.promisify(foo.bar); \/\/ TypeError: Cannot read property 'a' of undefined \/\/ naiveBar().then(a => console.log(a));  naiveBar.call(foo).then((a) => console.log(a)); \/\/ '42'  const bindBar = naiveBar.bind(foo); bindBar().then((a) => console.log(a)); \/\/ '42'"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_custom_promisified_functions","title":"Custom promisified functions","description":"Using the util.promisify.custom symbol one can override the return value of util.promisify(): const util = require('util');  function doSomething(foo, callback) {   \/\/ ... }  doSomething[util.promisify.custom] = (foo) => {   return getPromiseSomehow(); };  const promisified = util.promisify(doSomething); console.log(promisified === doSomething[util.promisify.custom]); \/\/ prints 'true'  This can be useful for cases where the original function does not follow the standard format of taking an error-first callback as the last argument. For example, with a function that takes in (foo, onSuccessCallback, onErrorCallback): doSomething[util.promisify.custom] = (foo) => {   return new Promise((resolve, reject) => {     doSomething(foo, resolve, reject);   }); };  If promisify.custom is defined but is not a function, promisify() will throw an error."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_deprecated_apis","title":"Deprecated APIs","description":"The following APIs are deprecated and should no longer be used. Existing applications and modules should be updated to find alternative approaches."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_extend_target_source","title":"`util._extend(target, source)`","description":"The util._extend() method was never intended to be used outside of internal Node.js modules. The community found and used it anyway. It is deprecated and should not be used in new code. JavaScript comes with very similar built-in functionality through Object.assign()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isarray_object","title":"`util.isArray(object)`","description":"Alias for Array.isArray(). Returns true if the given object is an Array. Otherwise, returns false. const util = require('util');  util.isArray([]); \/\/ Returns: true util.isArray(new Array()); \/\/ Returns: true util.isArray({}); \/\/ Returns: false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isboolean_object","title":"`util.isBoolean(object)`","description":"Returns true if the given object is a Boolean. Otherwise, returns false. const util = require('util');  util.isBoolean(1); \/\/ Returns: false util.isBoolean(0); \/\/ Returns: false util.isBoolean(false); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isbuffer_object","title":"`util.isBuffer(object)`","description":"Returns true if the given object is a Buffer. Otherwise, returns false. const util = require('util');  util.isBuffer({ length: 0 }); \/\/ Returns: false util.isBuffer([]); \/\/ Returns: false util.isBuffer(Buffer.from('hello world')); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isdate_object","title":"`util.isDate(object)`","description":"Returns true if the given object is a Date. Otherwise, returns false. const util = require('util');  util.isDate(new Date()); \/\/ Returns: true util.isDate(Date()); \/\/ false (without 'new' returns a String) util.isDate({}); \/\/ Returns: false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_iserror_object","title":"`util.isError(object)`","description":"Returns true if the given object is an Error. Otherwise, returns false. const util = require('util');  util.isError(new Error()); \/\/ Returns: true util.isError(new TypeError()); \/\/ Returns: true util.isError({ name: 'Error', message: 'an error occurred' }); \/\/ Returns: false  This method relies on Object.prototype.toString() behavior. It is possible to obtain an incorrect result when the object argument manipulates @@toStringTag. const util = require('util'); const obj = { name: 'Error', message: 'an error occurred' };  util.isError(obj); \/\/ Returns: false obj[Symbol.toStringTag] = 'Error'; util.isError(obj); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isfunction_object","title":"`util.isFunction(object)`","description":"Returns true if the given object is a Function. Otherwise, returns false. const util = require('util');  function Foo() {} const Bar = () => {};  util.isFunction({}); \/\/ Returns: false util.isFunction(Foo); \/\/ Returns: true util.isFunction(Bar); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isnull_object","title":"`util.isNull(object)`","description":"Returns true if the given object is strictly null. Otherwise, returns false. const util = require('util');  util.isNull(0); \/\/ Returns: false util.isNull(undefined); \/\/ Returns: false util.isNull(null); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isnullorundefined_object","title":"`util.isNullOrUndefined(object)`","description":"Returns true if the given object is null or undefined. Otherwise, returns false. const util = require('util');  util.isNullOrUndefined(0); \/\/ Returns: false util.isNullOrUndefined(undefined); \/\/ Returns: true util.isNullOrUndefined(null); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isnumber_object","title":"`util.isNumber(object)`","description":"Returns true if the given object is a Number. Otherwise, returns false. const util = require('util');  util.isNumber(false); \/\/ Returns: false util.isNumber(Infinity); \/\/ Returns: true util.isNumber(0); \/\/ Returns: true util.isNumber(NaN); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isobject_object","title":"`util.isObject(object)`","description":"Returns true if the given object is strictly an Object and not a Function (even though functions are objects in JavaScript). Otherwise, returns false. const util = require('util');  util.isObject(5); \/\/ Returns: false util.isObject(null); \/\/ Returns: false util.isObject({}); \/\/ Returns: true util.isObject(() => {}); \/\/ Returns: false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isprimitive_object","title":"`util.isPrimitive(object)`","description":"Returns true if the given object is a primitive type. Otherwise, returns false. const util = require('util');  util.isPrimitive(5); \/\/ Returns: true util.isPrimitive('foo'); \/\/ Returns: true util.isPrimitive(false); \/\/ Returns: true util.isPrimitive(null); \/\/ Returns: true util.isPrimitive(undefined); \/\/ Returns: true util.isPrimitive({}); \/\/ Returns: false util.isPrimitive(() => {}); \/\/ Returns: false util.isPrimitive(\/^$\/); \/\/ Returns: false util.isPrimitive(new Date()); \/\/ Returns: false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isregexp_object","title":"`util.isRegExp(object)`","description":"Returns true if the given object is a RegExp. Otherwise, returns false. const util = require('util');  util.isRegExp(\/some regexp\/); \/\/ Returns: true util.isRegExp(new RegExp('another regexp')); \/\/ Returns: true util.isRegExp({}); \/\/ Returns: false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isstring_object","title":"`util.isString(object)`","description":"Returns true if the given object is a string. Otherwise, returns false. const util = require('util');  util.isString(''); \/\/ Returns: true util.isString('foo'); \/\/ Returns: true util.isString(String('foo')); \/\/ Returns: true util.isString(5); \/\/ Returns: false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_issymbol_object","title":"`util.isSymbol(object)`","description":"Returns true if the given object is a Symbol. Otherwise, returns false. const util = require('util');  util.isSymbol(5); \/\/ Returns: false util.isSymbol('foo'); \/\/ Returns: false util.isSymbol(Symbol('foo')); \/\/ Returns: true"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_isundefined_object","title":"`util.isUndefined(object)`","description":"Returns true if the given object is undefined. Otherwise, returns false. const util = require('util');  const foo = undefined; util.isUndefined(5); \/\/ Returns: false util.isUndefined(foo); \/\/ Returns: true util.isUndefined(null); \/\/ Returns: false"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_util_log_string","title":"`util.log(string)`","description":"The util.log() method prints the given string to stdout with an included timestamp. const util = require('util');  util.log('Timestamped message.');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8","title":"V8","description":"Source Code: lib\/v8.js The v8 module exposes APIs that are specific to the version of V8 built into the Node.js binary. It can be accessed using: const v8 = require('v8');"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_cacheddataversiontag","title":"`v8.cachedDataVersionTag()`","description":"Returns an integer representing a version tag derived from the V8 version, command-line flags, and detected CPU features. This is useful for determining whether a vm.Script cachedData buffer is compatible with this instance of V8. console.log(v8.cachedDataVersionTag()); \/\/ 3947234607 \/\/ The value returned by v8.cachedDataVersionTag() is derived from the V8 \/\/ version, command-line flags, and detected CPU features. Test that the value \/\/ does indeed update when flags are toggled. v8.setFlagsFromString('--allow_natives_syntax'); console.log(v8.cachedDataVersionTag()); \/\/ 183726201"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_getheapcodestatistics","title":"`v8.getHeapCodeStatistics()`","description":"Returns an object with the following properties:  code_and_metadata_size <number> bytecode_and_metadata_size <number> external_script_source_size <number>   {   code_and_metadata_size: 212208,   bytecode_and_metadata_size: 161368,   external_script_source_size: 1410794 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_getheapsnapshot","title":"`v8.getHeapSnapshot()`","description":"Generates a snapshot of the current V8 heap and returns a Readable Stream that may be used to read the JSON serialized representation. This JSON stream format is intended to be used with tools such as Chrome DevTools. The JSON schema is undocumented and specific to the V8 engine. Therefore, the schema may change from one version of V8 to the next. \/\/ Print heap snapshot to the console const v8 = require('v8'); const stream = v8.getHeapSnapshot(); stream.pipe(process.stdout);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_getheapspacestatistics","title":"`v8.getHeapSpaceStatistics()`","description":"Returns statistics about the V8 heap spaces, i.e. the segments which make up the V8 heap. Neither the ordering of heap spaces, nor the availability of a heap space can be guaranteed as the statistics are provided via the V8 GetHeapSpaceStatistics function and may change from one V8 version to the next. The value returned is an array of objects containing the following properties:  space_name <string> space_size <number> space_used_size <number> space_available_size <number> physical_space_size <number>  [   {     \"space_name\": \"new_space\",     \"space_size\": 2063872,     \"space_used_size\": 951112,     \"space_available_size\": 80824,     \"physical_space_size\": 2063872   },   {     \"space_name\": \"old_space\",     \"space_size\": 3090560,     \"space_used_size\": 2493792,     \"space_available_size\": 0,     \"physical_space_size\": 3090560   },   {     \"space_name\": \"code_space\",     \"space_size\": 1260160,     \"space_used_size\": 644256,     \"space_available_size\": 960,     \"physical_space_size\": 1260160   },   {     \"space_name\": \"map_space\",     \"space_size\": 1094160,     \"space_used_size\": 201608,     \"space_available_size\": 0,     \"physical_space_size\": 1094160   },   {     \"space_name\": \"large_object_space\",     \"space_size\": 0,     \"space_used_size\": 0,     \"space_available_size\": 1490980608,     \"physical_space_size\": 0   } ]"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_getheapstatistics","title":"`v8.getHeapStatistics()`","description":"Returns an object with the following properties:  total_heap_size <number> total_heap_size_executable <number> total_physical_size <number> total_available_size <number> used_heap_size <number> heap_size_limit <number> malloced_memory <number> peak_malloced_memory <number> does_zap_garbage <number> number_of_native_contexts <number> number_of_detached_contexts <number>  does_zap_garbage is a 0\/1 boolean, which signifies whether the --zap_code_space option is enabled or not. This makes V8 overwrite heap garbage with a bit pattern. The RSS footprint (resident set size) gets bigger because it continuously touches all heap pages and that makes them less likely to get swapped out by the operating system. number_of_native_contexts The value of native_context is the number of the top-level contexts currently active. Increase of this number over time indicates a memory leak. number_of_detached_contexts The value of detached_context is the number of contexts that were detached and not yet garbage collected. This number being non-zero indicates a potential memory leak.  {   total_heap_size: 7326976,   total_heap_size_executable: 4194304,   total_physical_size: 7326976,   total_available_size: 1152656,   used_heap_size: 3476208,   heap_size_limit: 1535115264,   malloced_memory: 16384,   peak_malloced_memory: 1127496,   does_zap_garbage: 0,   number_of_native_contexts: 1,   number_of_detached_contexts: 0 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_setflagsfromstring_flags","title":"`v8.setFlagsFromString(flags)`","description":"The v8.setFlagsFromString() method can be used to programmatically set V8 command-line flags. This method should be used with care. Changing settings after the VM has started may result in unpredictable behavior, including crashes and data loss; or it may simply do nothing. The V8 options available for a version of Node.js may be determined by running node --v8-options. Usage: \/\/ Print GC events to stdout for one minute. const v8 = require('v8'); v8.setFlagsFromString('--trace_gc'); setTimeout(() => { v8.setFlagsFromString('--notrace_gc'); }, 60e3);"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_takecoverage","title":"`v8.takeCoverage()`","description":"The v8.takeCoverage() method allows the user to write the coverage started by NODE_V8_COVERAGE to disk on demand. This method can be invoked multiple times during the lifetime of the process, each time the execution counter will be reset and a new coverage report will be written to the directory specified by NODE_V8_COVERAGE. When the process is about to exit, one last coverage will still be written to disk, unless v8.stopCoverage() is invoked before the process exits."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_stopcoverage","title":"`v8.stopCoverage()`","description":"The v8.stopCoverage() method allows the user to stop the coverage collection started by NODE_V8_COVERAGE, so that V8 can release the execution count records and optimize code. This can be used in conjunction with v8.takeCoverage() if the user wants to collect the coverage on demand."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_writeheapsnapshot_filename","title":"`v8.writeHeapSnapshot([filename])`","description":"Generates a snapshot of the current V8 heap and writes it to a JSON file. This file is intended to be used with tools such as Chrome DevTools. The JSON schema is undocumented and specific to the V8 engine, and may change from one version of V8 to the next. A heap snapshot is specific to a single V8 isolate. When using worker threads, a heap snapshot generated from the main thread will not contain any information about the workers, and vice versa. const { writeHeapSnapshot } = require('v8'); const {   Worker,   isMainThread,   parentPort } = require('worker_threads');  if (isMainThread) {   const worker = new Worker(__filename);    worker.once('message', (filename) => {     console.log(`worker heapdump: ${filename}`);     \/\/ Now get a heapdump for the main thread.     console.log(`main thread heapdump: ${writeHeapSnapshot()}`);   });    \/\/ Tell the worker to create a heapdump.   worker.postMessage('heapdump'); } else {   parentPort.once('message', (message) => {     if (message === 'heapdump') {       \/\/ Generate a heapdump for the worker       \/\/ and return the filename to the parent.       parentPort.postMessage(writeHeapSnapshot());     }   }); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_serialization_api","title":"Serialization API","description":"The serialization API provides means of serializing JavaScript values in a way that is compatible with the HTML structured clone algorithm. The format is backward-compatible (i.e. safe to store to disk). Equal JavaScript values may result in different serialized output."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_serialize_value","title":"`v8.serialize(value)`","description":"Uses a DefaultSerializer to serialize value into a buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_v8_deserialize_buffer","title":"`v8.deserialize(buffer)`","description":"Uses a DefaultDeserializer with default options to read a JS value from a buffer."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_executing_javascript","title":"VM (executing JavaScript)","description":"Source Code: lib\/vm.js The vm module enables compiling and running code within V8 Virtual Machine contexts. The vm module is not a security mechanism. Do not use it to run untrusted code. JavaScript code can be compiled and run immediately or compiled, saved, and run later. A common use case is to run the code in a different V8 Context. This means invoked code has a different global object than the invoking code. One can provide the context by contextifying an object. The invoked code treats any property in the context like a global variable. Any changes to global variables caused by the invoked code are reflected in the context object. const vm = require('vm');  const x = 1;  const context = { x: 2 }; vm.createContext(context); \/\/ Contextify the object.  const code = 'x += 40; var y = 17;'; \/\/ `x` and `y` are global variables in the context. \/\/ Initially, x has the value 2 because that is the value of context.x. vm.runInContext(code, context);  console.log(context.x); \/\/ 42 console.log(context.y); \/\/ 17  console.log(x); \/\/ 1; y is not defined."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_measurememory_options","title":"`vm.measureMemory([options])`","description":"Measure the memory known to V8 and used by all contexts known to the current V8 isolate, or the main context.  options <Object> Optional.  mode <string> Either 'summary' or 'detailed'. In summary mode, only the memory measured for the main context will be returned. In detailed mode, the measure measured for all contexts known to the current V8 isolate will be returned. Default: 'summary' execution <string> Either 'default' or 'eager'. With default execution, the promise will not resolve until after the next scheduled garbage collection starts, which may take a while (or never if the program exits before the next GC). With eager execution, the GC will be started right away to measure the memory. Default: 'default'   Returns: <Promise> If the memory is successfully measured the promise will resolve with an object containing information about the memory usage.  The format of the object that the returned Promise may resolve with is specific to the V8 engine and may change from one version of V8 to the next. The returned result is different from the statistics returned by v8.getHeapSpaceStatistics() in that vm.measureMemory() measure the memory reachable by each V8 specific contexts in the current instance of the V8 engine, while the result of v8.getHeapSpaceStatistics() measure the memory occupied by each heap space in the current V8 instance. const vm = require('vm'); \/\/ Measure the memory used by the main context. vm.measureMemory({ mode: 'summary' })   \/\/ This is the same as vm.measureMemory()   .then((result) => {     \/\/ The current format is:     \/\/ {     \/\/   total: {     \/\/      jsMemoryEstimate: 2418479, jsMemoryRange: [ 2418479, 2745799 ]     \/\/    }     \/\/ }     console.log(result);   });  const context = vm.createContext({ a: 1 }); vm.measureMemory({ mode: 'detailed', execution: 'eager' })   .then((result) => {     \/\/ Reference the context here so that it won't be GC'ed     \/\/ until the measurement is complete.     console.log(context.a);     \/\/ {     \/\/   total: {     \/\/     jsMemoryEstimate: 2574732,     \/\/     jsMemoryRange: [ 2574732, 2904372 ]     \/\/   },     \/\/   current: {     \/\/     jsMemoryEstimate: 2438996,     \/\/     jsMemoryRange: [ 2438996, 2768636 ]     \/\/   },     \/\/   other: [     \/\/     {     \/\/       jsMemoryEstimate: 135736,     \/\/       jsMemoryRange: [ 135736, 465376 ]     \/\/     }     \/\/   ]     \/\/ }     console.log(result);   });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_compilefunction_code_params_options","title":"`vm.compileFunction(code[, params[, options]])`","description":"Compiles the given code into the provided context (if no context is supplied, the current context is used), and returns it wrapped inside a function with the given params."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_createcontext_contextobject_options","title":"`vm.createContext([contextObject[, options]])`","description":"If given a contextObject, the vm.createContext() method will prepare that object so that it can be used in calls to vm.runInContext() or script.runInContext(). Inside such scripts, the contextObject will be the global object, retaining all of its existing properties but also having the built-in objects and functions any standard global object has. Outside of scripts run by the vm module, global variables will remain unchanged. const vm = require('vm');  global.globalVar = 3;  const context = { globalVar: 1 }; vm.createContext(context);  vm.runInContext('globalVar *= 2;', context);  console.log(context); \/\/ Prints: { globalVar: 2 }  console.log(global.globalVar); \/\/ Prints: 3  If contextObject is omitted (or passed explicitly as undefined), a new, empty contextified object will be returned. The vm.createContext() method is primarily useful for creating a single context that can be used to run multiple scripts. For instance, if emulating a web browser, the method can be used to create a single context representing a window's global object, then run all <script> tags together within that context. The provided name and origin of the context are made visible through the Inspector API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_iscontext_object","title":"`vm.isContext(object)`","description":"Returns true if the given oject object has been contextified using vm.createContext()."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_runincontext_code_contextifiedobject_options","title":"`vm.runInContext(code, contextifiedObject[, options])`","description":"The vm.runInContext() method compiles code, runs it within the context of the contextifiedObject, then returns the result. Running code does not have access to the local scope. The contextifiedObject object must have been previously contextified using the vm.createContext() method. If options is a string, then it specifies the filename. The following example compiles and executes different scripts using a single contextified object: const vm = require('vm');  const contextObject = { globalVar: 1 }; vm.createContext(contextObject);  for (let i = 0; i < 10; ++i) {   vm.runInContext('globalVar *= 2;', contextObject); } console.log(contextObject); \/\/ Prints: { globalVar: 1024 }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_runinnewcontext_code_contextobject_options","title":"`vm.runInNewContext(code[, contextObject[, options]])`","description":"The vm.runInNewContext() first contextifies the given contextObject (or creates a new contextObject if passed as undefined), compiles the code, runs it within the created context, then returns the result. Running code does not have access to the local scope. If options is a string, then it specifies the filename. The following example compiles and executes code that increments a global variable and sets a new one. These globals are contained in the contextObject. const vm = require('vm');  const contextObject = {   animal: 'cat',   count: 2 };  vm.runInNewContext('count += 1; name = \"kitty\"', contextObject); console.log(contextObject); \/\/ Prints: { animal: 'cat', count: 3, name: 'kitty' }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_vm_runinthiscontext_code_options","title":"`vm.runInThisContext(code[, options])`","description":"vm.runInThisContext() compiles code, runs it within the context of the current global and returns the result. Running code does not have access to local scope, but does have access to the current global object. If options is a string, then it specifies the filename. The following example illustrates using both vm.runInThisContext() and the JavaScript eval() function to run the same code:  const vm = require('vm'); let localVar = 'initial value';  const vmResult = vm.runInThisContext('localVar = \"vm\";'); console.log(`vmResult: '${vmResult}', localVar: '${localVar}'`); \/\/ Prints: vmResult: 'vm', localVar: 'initial value'  const evalResult = eval('localVar = \"eval\";'); console.log(`evalResult: '${evalResult}', localVar: '${localVar}'`); \/\/ Prints: evalResult: 'eval', localVar: 'eval'  Because vm.runInThisContext() does not have access to the local scope, localVar is unchanged. In contrast, eval() does have access to the local scope, so the value localVar is changed. In this way vm.runInThisContext() is much like an indirect eval() call, e.g. (0,eval)('code'). Example: Running an HTTP server within a VM When using either script.runInThisContext() or vm.runInThisContext(), the code is executed within the current V8 global context. The code passed to this VM context will have its own isolated scope. In order to run a simple web server using the http module the code passed to the context must either call require('http') on its own, or have a reference to the http module passed to it. For instance: 'use strict'; const vm = require('vm');  const code = ` ((require) => {   const http = require('http');    http.createServer((request, response) => {     response.writeHead(200, { 'Content-Type': 'text\/plain' });     response.end('Hello World\\\\n');   }).listen(8124);    console.log('Server running at http:\/\/127.0.0.1:8124\/'); })`;  vm.runInThisContext(code)(require);  The require() in the above case shares the state with the context it is passed from. This may introduce risks when untrusted code is executed, e.g. altering objects in the context in unwanted ways."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_what_does_it_mean_to_contextify_an_object","title":"What does it mean to \"contextify\" an object?","description":"All JavaScript executed within Node.js runs within the scope of a \"context\". According to the V8 Embedder's Guide:  In V8, a context is an execution environment that allows separate, unrelated, JavaScript applications to run in a single instance of V8. You must explicitly specify the context in which you want any JavaScript code to be run.  When the method vm.createContext() is called, the contextObject argument (or a newly-created object if contextObject is undefined) is associated internally with a new instance of a V8 Context. This V8 Context provides the code run using the vm module's methods with an isolated global environment within which it can operate. The process of creating the V8 Context and associating it with the contextObject is what this document refers to as \"contextifying\" the object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_timeout_interactions_with_asynchronous_tasks_and_promises","title":"Timeout interactions with asynchronous tasks and Promises","description":"Promises and async functions can schedule tasks run by the JavaScript engine asynchronously. By default, these tasks are run after all JavaScript functions on the current stack are done executing. This allows escaping the functionality of the timeout and breakOnSigint options. For example, the following code executed by vm.runInNewContext() with a timeout of 5 milliseconds schedules an infinite loop to run after a promise resolves. The scheduled loop is never interrupted by the timeout: const vm = require('vm');  function loop() {   console.log('entering loop');   while (1) console.log(Date.now()); }  vm.runInNewContext(   'Promise.resolve().then(() => loop());',   { loop, console },   { timeout: 5 } ); \/\/ This is printed *before* 'entering loop' (!) console.log('done executing');  This can be addressed by passing microtaskMode: 'afterEvaluate' to the code that creates the Context: const vm = require('vm');  function loop() {   while (1) console.log(Date.now()); }  vm.runInNewContext(   'Promise.resolve().then(() => loop());',   { loop, console },   { timeout: 5, microtaskMode: 'afterEvaluate' } );  In this case, the microtask scheduled through promise.then() will be run before returning from vm.runInNewContext(), and will be interrupted by the timeout functionality. This applies only to code running in a vm.Context, so e.g. vm.runInThisContext() does not take this option. Promise callbacks are entered into the microtask queue of the context in which they were created. For example, if () => loop() is replaced with just loop in the above example, then loop will be pushed into the global microtask queue, because it is a function from the outer (main) context, and thus will also be able to escape the timeout. If asynchronous scheduling functions such as process.nextTick(), queueMicrotask(), setTimeout(), setImmediate(), etc. are made available inside a vm.Context, functions passed to them will be added to global queues, which are shared by all contexts. Therefore, callbacks passed to those functions are not controllable through the timeout either."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_webassembly_system_interface_wasi","title":"WebAssembly System Interface (WASI)","description":"Source Code: lib\/wasi.js The WASI API provides an implementation of the WebAssembly System Interface specification. WASI gives sandboxed WebAssembly applications access to the underlying operating system via a collection of POSIX-like functions. 'use strict'; const fs = require('fs'); const { WASI } = require('wasi'); const wasi = new WASI({   args: process.argv,   env: process.env,   preopens: {     '\/sandbox': '\/some\/real\/path\/that\/wasm\/can\/access'   } }); const importObject = { wasi_snapshot_preview1: wasi.wasiImport };  (async () => {   const wasm = await WebAssembly.compile(fs.readFileSync('.\/demo.wasm'));   const instance = await WebAssembly.instantiate(wasm, importObject);    wasi.start(instance); })();  To run the above example, create a new WebAssembly text format file named demo.wat: (module     ;; Import the required fd_write WASI function which will write the given io vectors to stdout     ;; The function signature for fd_write is:     ;; (File Descriptor, *iovs, iovs_len, nwritten) -> Returns number of bytes written     (import \"wasi_snapshot_preview1\" \"fd_write\" (func $fd_write (param i32 i32 i32 i32) (result i32)))      (memory 1)     (export \"memory\" (memory 0))      ;; Write 'hello world\\n' to memory at an offset of 8 bytes     ;; Note the trailing newline which is required for the text to appear     (data (i32.const 8) \"hello world\\n\")      (func $main (export \"_start\")         ;; Creating a new io vector within linear memory         (i32.store (i32.const 0) (i32.const 8))  ;; iov.iov_base - This is a pointer to the start of the 'hello world\\n' string         (i32.store (i32.const 4) (i32.const 12))  ;; iov.iov_len - The length of the 'hello world\\n' string          (call $fd_write             (i32.const 1) ;; file_descriptor - 1 for stdout             (i32.const 0) ;; *iovs - The pointer to the iov array, which is stored at memory location 0             (i32.const 1) ;; iovs_len - We're printing 1 string stored in an iov - so one.             (i32.const 20) ;; nwritten - A place in memory to store the number of bytes written         )         drop ;; Discard the number of bytes written from the top of the stack     ) )  Use wabt to compile .wat to .wasm $ wat2wasm demo.wat  The --experimental-wasi-unstable-preview1 CLI argument is needed for this example to run."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_web_crypto_api","title":"Web Crypto API","description":"Node.js provides an implementation of the standard Web Crypto API. Use require('crypto').webcrypto to access this module. const { subtle } = require('crypto').webcrypto;  (async function() {    const key = await subtle.generateKey({     name: 'hmac',     length: 123   }, true, ['sign', 'verify']);    const digest = await subtle.sign({     name: 'hmac'   }, key, 'I love cupcakes');  })();  Examples"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_generating_keys","title":"Generating keys","description":"The <SubtleCrypto> class can be used to generate symmetric (secret) keys or asymmetric key pairs (public key and private key)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_aes_keys","title":"AES keys","description":"const { subtle } = require('crypto').webcrypto;  async function generateAesKey(length = 256) {   const key = await subtle.generateKey({     name: 'AES-CBC',     length   }, true, ['encrypt', 'decrypt']);    return key; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_elliptic_curve_key_pairs","title":"Elliptic curve key pairs","description":"const { subtle } = require('crypto').webcrypto;  async function generateEcKey(namedCurve = 'P-521') {   const {     publicKey,     privateKey   } = await subtle.generateKey({     name: 'ECDSA',     namedCurve,   }, true, ['sign', 'verify']);    return { publicKey, privateKey }; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_hmac_keys","title":"HMAC keys","description":"const { subtle } = require('crypto').webcrypto;  async function generateHmacKey(hash = 'SHA-256') {   const key = await subtle.generateKey({     name: 'HMAC',     hash   }, true, ['sign', 'verify']);    return key; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_rsa_key_pairs","title":"RSA key pairs","description":"const { subtle } = require('crypto').webcrypto; const publicExponent = new Uint8Array([1, 0, 1]);  async function generateRsaKey(modulusLength = 2048, hash = 'SHA-256') {   const {     publicKey,     privateKey   } = await subtle.generateKey({     name: 'RSASSA-PKCS1-v1_5',     modulusLength,     publicExponent,     hash,   }, true, ['sign', 'verify']);    return { publicKey, privateKey }; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_encryption_and_decryption","title":"Encryption and decryption","description":"const { subtle, getRandomValues } = require('crypto').webcrypto;  async function aesEncrypt(plaintext) {   const ec = new TextEncoder();   const key = await generateAesKey();   const iv = getRandomValues(new Uint8Array(16));    const ciphertext = await subtle.encrypt({     name: 'AES-CBC',     iv,   }, key, ec.encode(plaintext));    return {     key,     iv,     ciphertext   }; }  async function aesDecrypt(ciphertext, key, iv) {   const dec = new TextDecoder();   const plaintext = await subtle.decrypt({     name: 'AES-CBC',     iv,   }, key, ciphertext);    return dec.decode(plaintext); }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_exporting_and_importing_keys","title":"Exporting and importing keys","description":"const { subtle } = require('crypto').webcrypto;  async function generateAndExportHmacKey(format = 'jwk', hash = 'SHA-512') {   const key = await subtle.generateKey({     name: 'HMAC',     hash   }, true, ['sign', 'verify']);    return subtle.exportKey(format, key); }  async function importHmacKey(keyData, format = 'jwk', hash = 'SHA-512') {   const key = await subtle.importKey(format, keyData, {     name: 'HMAC',     hash   }, true, ['sign', 'verify']);    return key; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_wrapping_and_unwrapping_keys","title":"Wrapping and unwrapping keys","description":"const { subtle } = require('crypto').webcrypto;  async function generateAndWrapHmacKey(format = 'jwk', hash = 'SHA-512') {   const [     key,     wrappingKey   ] = await Promise.all([     subtle.generateKey({       name: 'HMAC', hash     }, true, ['sign', 'verify']),     subtle.generateKey({       name: 'AES-KW',       length: 256     }, true, ['wrapKey', 'unwrapKey'])   ]);    const wrappedKey = await subtle.wrapKey(format, key, wrappingKey, 'AES-KW');    return wrappedKey; }  async function unwrapHmacKey(   wrappedKey,   wrappingKey,   format = 'jwk',   hash = 'SHA-512') {    const key = await subtle.unwrapKey(     format,     wrappedKey,     unwrappingKey,     'AES-KW',     { name: 'HMAC', hash },     true,     ['sign', 'verify']);    return key; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_sign_and_verify","title":"Sign and verify","description":"const { subtle } = require('crypto').webcrypto;  async function sign(key, data) {   const ec = new TextEncoder();   const signature =     await subtle.sign('RSASSA-PKCS1-v1_5', key, ec.encode(data));   return signature; }  async function verify(key, signature, data) {   const ec = new TextEncoder();   const verified =     await subtle.verify(       'RSASSA-PKCS1-v1_5',       key,       signature,       ec.encode(data));   return verified; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_deriving_bits_and_keys","title":"Deriving bits and keys","description":"const { subtle } = require('crypto').webcrypto;  async function pbkdf2(pass, salt, iterations = 1000, length = 256) {   const ec = new TextEncoder();   const key = await subtle.importKey(     'raw',     ec.encode(pass),     'PBKDF2',     false,     ['deriveBits']);   const bits = await subtle.deriveBits({     name: 'PBKDF2',     hash: 'SHA-512',     salt: ec.encode(salt),     iterations   }, key, length);   return bits; }  async function pbkdf2Key(pass, salt, iterations = 1000, length = 256) {   const ec = new TextEncoder();   const keyMaterial = await subtle.importKey(     'raw',     ec.encode(pass),     'PBKDF2',     false,     ['deriveBits']);   const key = await subtle.deriveKey({     name: 'PBKDF2',     hash: 'SHA-512',     salt: ec.encode(salt),     iterations   }, keyMaterial, {     name: 'AES-GCM',     length: 256   }, true, ['encrypt', 'decrypt']);   return key; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_digest","title":"Digest","description":"const { subtle } = require('crypto').webcrypto;  async function digest(data, algorithm = 'SHA-512') {   const ec = new TextEncoder();   const digest = await subtle.digest(algorithm, ec.encode(data));   return digest; }"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_algorithm_matrix","title":"Algorithm Matrix","description":"The table details the algorithms supported by the Node.js Web Crypto API implementation and the APIs supported for each:    Algorithm generateKey exportKey importKey encrypt decrypt wrapKey unwrapKey deriveBits deriveKey sign verify digest     'RSASSA-PKCS1-v1_5' \u2714 \u2714 \u2714       \u2714 \u2714    'RSA-PSS' \u2714 \u2714 \u2714       \u2714 \u2714    'RSA-OAEP' \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 \u2714        'ECDSA' \u2714 \u2714 \u2714       \u2714 \u2714    'ECDH' \u2714 \u2714 \u2714     \u2714 \u2714      'AES-CTR' \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 \u2714        'AES-CBC' \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 \u2714        'AES-GCM' \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 \u2714        'AES-KW' \u2714 \u2714 \u2714   \u2714 \u2714        'HMAC' \u2714 \u2714 \u2714       \u2714 \u2714    'HKDF'  \u2714 \u2714     \u2714 \u2714      'PBKDF2'  \u2714 \u2714     \u2714 \u2714      'SHA-1'            \u2714   'SHA-256'            \u2714   'SHA-384'            \u2714   'SHA-512'            \u2714   'NODE-DSA'1 \u2714 \u2714 \u2714       \u2714 \u2714    'NODE-DH'1 \u2714 \u2714 \u2714     \u2714 \u2714       1 Node.js-specific extension"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_algorithm_parameters","title":"Algorithm Parameters","description":"The algorithm parameter objects define the methods and parameters used by the various <SubtleCrypto> methods. While described here as \"classes\", they are simple JavaScript dictionary objects."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_js_specific_extensions","title":"Node.js-specific extensions","description":"The Node.js Web Crypto API extends various aspects of the Web Crypto API. These extensions are consistently identified by prepending names with the node. prefix. For instance, the node.keyObject key format can be used with the subtle.exportKey() and subtle.importKey() methods to convert between a WebCrypto <CryptoKey> object and a Node.js <KeyObject>. Care should be taken when using Node.js-specific extensions as they are not supported by other WebCrypto implementations and reduce the portability of code to other environments."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_dh_algorithm","title":"`NODE-DH` Algorithm","description":"The NODE-DH algorithm is the common implementation of Diffie-Hellman key agreement."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_dsa_algorithm","title":"`NODE-DSA` Algorithm","description":"The NODE-DSA algorithm is the common implementation of the DSA digital signature algorithm."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_node_scrypt_algorithm","title":"`NODE-SCRYPT` Algorithm","description":"The NODE-SCRYPT algorithm is the common implementation of the scrypt key derivation algorithm."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_worker_threads","title":"Worker threads","description":"Source Code: lib\/worker_threads.js The worker_threads module enables the use of threads that execute JavaScript in parallel. To access it: const worker = require('worker_threads');  Workers (threads) are useful for performing CPU-intensive JavaScript operations. They will not help much with I\/O-intensive work. Node.js\u2019s built-in asynchronous I\/O operations are more efficient than Workers can be. Unlike child_process or cluster, worker_threads can share memory. They do so by transferring ArrayBuffer instances or sharing SharedArrayBuffer instances. const {   Worker, isMainThread, parentPort, workerData } = require('worker_threads');  if (isMainThread) {   module.exports = function parseJSAsync(script) {     return new Promise((resolve, reject) => {       const worker = new Worker(__filename, {         workerData: script       });       worker.on('message', resolve);       worker.on('error', reject);       worker.on('exit', (code) => {         if (code !== 0)           reject(new Error(`Worker stopped with exit code ${code}`));       });     });   }; } else {   const { parse } = require('some-js-parsing-library');   const script = workerData;   parentPort.postMessage(parse(script)); }  The above example spawns a Worker thread for each parse() call. In actual practice, use a pool of Workers instead for these kinds of tasks. Otherwise, the overhead of creating Workers would likely exceed their benefit. When implementing a worker pool, use the AsyncResource API to inform diagnostic tools (e.g. in order to provide asynchronous stack traces) about the correlation between tasks and their outcomes. See \"Using AsyncResource for a Worker thread pool\" in the async_hooks documentation for an example implementation. Worker threads inherit non-process-specific options by default. Refer to Worker constructor options to know how to customize worker thread options, specifically argv and execArgv options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_worker_markasuntransferable_object","title":"`worker.markAsUntransferable(object)`","description":"Mark an object as not transferable. If object occurs in the transfer list of a port.postMessage() call, it will be ignored. In particular, this makes sense for objects that can be cloned, rather than transferred, and which are used by other objects on the sending side. For example, Node.js marks the ArrayBuffers it uses for its Buffer pool with this. This operation cannot be undone. const { MessageChannel, markAsUntransferable } = require('worker_threads');  const pooledBuffer = new ArrayBuffer(8); const typedArray1 = new Uint8Array(pooledBuffer); const typedArray2 = new Float64Array(pooledBuffer);  markAsUntransferable(pooledBuffer);  const { port1 } = new MessageChannel(); port1.postMessage(typedArray1, [ typedArray1.buffer ]);  \/\/ The following line prints the contents of typedArray1 -- it still owns \/\/ its memory and has been cloned, not transferred. Without \/\/ `markAsUntransferable()`, this would print an empty Uint8Array. \/\/ typedArray2 is intact as well. console.log(typedArray1); console.log(typedArray2);  There is no equivalent to this API in browsers."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_worker_movemessageporttocontext_port_contextifiedsandbox","title":"`worker.moveMessagePortToContext(port, contextifiedSandbox)`","description":"Transfer a MessagePort to a different vm Context. The original port object will be rendered unusable, and the returned MessagePort instance will take its place. The returned MessagePort will be an object in the target context, and will inherit from its global Object class. Objects passed to the port.onmessage() listener will also be created in the target context and inherit from its global Object class. However, the created MessagePort will no longer inherit from EventTarget, and only port.onmessage() can be used to receive events using it."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_worker_receivemessageonport_port","title":"`worker.receiveMessageOnPort(port)`","description":"Receive a single message from a given MessagePort. If no message is available, undefined is returned, otherwise an object with a single message property that contains the message payload, corresponding to the oldest message in the MessagePort\u2019s queue. const { MessageChannel, receiveMessageOnPort } = require('worker_threads'); const { port1, port2 } = new MessageChannel(); port1.postMessage({ hello: 'world' });  console.log(receiveMessageOnPort(port2)); \/\/ Prints: { message: { hello: 'world' } } console.log(receiveMessageOnPort(port2)); \/\/ Prints: undefined  When this function is used, no 'message' event will be emitted and the onmessage listener will not be invoked."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib","title":"Zlib","description":"Source Code: lib\/zlib.js The zlib module provides compression functionality implemented using Gzip, Deflate\/Inflate, and Brotli. To access it: const zlib = require('zlib');  Compression and decompression are built around the Node.js Streams API. Compressing or decompressing a stream (such as a file) can be accomplished by piping the source stream through a zlib Transform stream into a destination stream: const { createGzip } = require('zlib'); const { pipeline } = require('stream'); const {   createReadStream,   createWriteStream } = require('fs');  const gzip = createGzip(); const source = createReadStream('input.txt'); const destination = createWriteStream('input.txt.gz');  pipeline(source, gzip, destination, (err) => {   if (err) {     console.error('An error occurred:', err);     process.exitCode = 1;   } });  \/\/ Or, Promisified  const { promisify } = require('util'); const pipe = promisify(pipeline);  async function do_gzip(input, output) {   const gzip = createGzip();   const source = createReadStream(input);   const destination = createWriteStream(output);   await pipe(source, gzip, destination); }  do_gzip('input.txt', 'input.txt.gz')   .catch((err) => {     console.error('An error occurred:', err);     process.exitCode = 1;   });  It is also possible to compress or decompress data in a single step: const { deflate, unzip } = require('zlib');  const input = '.................................'; deflate(input, (err, buffer) => {   if (err) {     console.error('An error occurred:', err);     process.exitCode = 1;   }   console.log(buffer.toString('base64')); });  const buffer = Buffer.from('eJzT0yMAAGTvBe8=', 'base64'); unzip(buffer, (err, buffer) => {   if (err) {     console.error('An error occurred:', err);     process.exitCode = 1;   }   console.log(buffer.toString()); });  \/\/ Or, Promisified  const { promisify } = require('util'); const do_unzip = promisify(unzip);  do_unzip(buffer)   .then((buf) => console.log(buf.toString()))   .catch((err) => {     console.error('An error occurred:', err);     process.exitCode = 1;   });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createbrotlicompress_options","title":"`zlib.createBrotliCompress([options])`","description":"Creates and returns a new BrotliCompress object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createbrotlidecompress_options","title":"`zlib.createBrotliDecompress([options])`","description":"Creates and returns a new BrotliDecompress object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createdeflate_options","title":"`zlib.createDeflate([options])`","description":"Creates and returns a new Deflate object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createdeflateraw_options","title":"`zlib.createDeflateRaw([options])`","description":"Creates and returns a new DeflateRaw object. An upgrade of zlib from 1.2.8 to 1.2.11 changed behavior when windowBits is set to 8 for raw deflate streams. zlib would automatically set windowBits to 9 if was initially set to 8. Newer versions of zlib will throw an exception, so Node.js restored the original behavior of upgrading a value of 8 to 9, since passing windowBits = 9 to zlib actually results in a compressed stream that effectively uses an 8-bit window only."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_creategunzip_options","title":"`zlib.createGunzip([options])`","description":"Creates and returns a new Gunzip object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_creategzip_options","title":"`zlib.createGzip([options])`","description":"Creates and returns a new Gzip object. See example."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createinflate_options","title":"`zlib.createInflate([options])`","description":"Creates and returns a new Inflate object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createinflateraw_options","title":"`zlib.createInflateRaw([options])`","description":"Creates and returns a new InflateRaw object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_createunzip_options","title":"`zlib.createUnzip([options])`","description":"Creates and returns a new Unzip object."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlicompress_buffer_options_callback","title":"`zlib.brotliCompress(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlicompresssync_buffer_options","title":"`zlib.brotliCompressSync(buffer[, options])`","description":"Compress a chunk of data with BrotliCompress."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlidecompress_buffer_options_callback","title":"`zlib.brotliDecompress(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlidecompresssync_buffer_options","title":"`zlib.brotliDecompressSync(buffer[, options])`","description":"Decompress a chunk of data with BrotliDecompress."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflate_buffer_options_callback","title":"`zlib.deflate(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflatesync_buffer_options","title":"`zlib.deflateSync(buffer[, options])`","description":"Compress a chunk of data with Deflate."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflateraw_buffer_options_callback","title":"`zlib.deflateRaw(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflaterawsync_buffer_options","title":"`zlib.deflateRawSync(buffer[, options])`","description":"Compress a chunk of data with DeflateRaw."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gunzip_buffer_options_callback","title":"`zlib.gunzip(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gunzipsync_buffer_options","title":"`zlib.gunzipSync(buffer[, options])`","description":"Decompress a chunk of data with Gunzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gzip_buffer_options_callback","title":"`zlib.gzip(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gzipsync_buffer_options","title":"`zlib.gzipSync(buffer[, options])`","description":"Compress a chunk of data with Gzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflate_buffer_options_callback","title":"`zlib.inflate(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflatesync_buffer_options","title":"`zlib.inflateSync(buffer[, options])`","description":"Decompress a chunk of data with Inflate."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflateraw_buffer_options_callback","title":"`zlib.inflateRaw(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflaterawsync_buffer_options","title":"`zlib.inflateRawSync(buffer[, options])`","description":"Decompress a chunk of data with InflateRaw."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_unzip_buffer_options_callback","title":"`zlib.unzip(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_unzipsync_buffer_options","title":"`zlib.unzipSync(buffer[, options])`","description":"Decompress a chunk of data with Unzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_memory_usage_tuning","title":"Memory usage tuning","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_for_zlib_based_streams","title":"For zlib-based streams","description":"From zlib\/zconf.h, modified for Node.js usage: The memory requirements for deflate are (in bytes):  (1 << (windowBits + 2)) + (1 << (memLevel + 9))  That is: 128K for windowBits = 15 + 128K for memLevel = 8 (default values) plus a few kilobytes for small objects. For example, to reduce the default memory requirements from 256K to 128K, the options should be set to: const options = { windowBits: 14, memLevel: 7 };  This will, however, generally degrade compression. The memory requirements for inflate are (in bytes) 1 << windowBits. That is, 32K for windowBits = 15 (default value) plus a few kilobytes for small objects. This is in addition to a single internal output slab buffer of size chunkSize, which defaults to 16K. The speed of zlib compression is affected most dramatically by the level setting. A higher level will result in better compression, but will take longer to complete. A lower level will result in less compression, but will be much faster. In general, greater memory usage options will mean that Node.js has to make fewer calls to zlib because it will be able to process more data on each write operation. So, this is another factor that affects the speed, at the cost of memory usage."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_for_brotli_based_streams","title":"For Brotli-based streams","description":"There are equivalents to the zlib options for Brotli-based streams, although these options have different ranges than the zlib ones:  zlib\u2019s level option matches Brotli\u2019s BROTLI_PARAM_QUALITY option. zlib\u2019s windowBits option matches Brotli\u2019s BROTLI_PARAM_LGWIN option.  See below for more details on Brotli-specific options."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_constants","title":"Constants","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_constants","title":"zlib constants","description":"All of the constants defined in zlib.h are also defined on require('zlib').constants. In the normal course of operations, it will not be necessary to use these constants. They are documented so that their presence is not surprising. This section is taken almost directly from the zlib documentation. Previously, the constants were available directly from require('zlib'), for instance zlib.Z_NO_FLUSH. Accessing the constants directly from the module is currently still possible but is deprecated. Allowed flush values.  zlib.constants.Z_NO_FLUSH zlib.constants.Z_PARTIAL_FLUSH zlib.constants.Z_SYNC_FLUSH zlib.constants.Z_FULL_FLUSH zlib.constants.Z_FINISH zlib.constants.Z_BLOCK zlib.constants.Z_TREES  Return codes for the compression\/decompression functions. Negative values are errors, positive values are used for special but normal events.  zlib.constants.Z_OK zlib.constants.Z_STREAM_END zlib.constants.Z_NEED_DICT zlib.constants.Z_ERRNO zlib.constants.Z_STREAM_ERROR zlib.constants.Z_DATA_ERROR zlib.constants.Z_MEM_ERROR zlib.constants.Z_BUF_ERROR zlib.constants.Z_VERSION_ERROR  Compression levels.  zlib.constants.Z_NO_COMPRESSION zlib.constants.Z_BEST_SPEED zlib.constants.Z_BEST_COMPRESSION zlib.constants.Z_DEFAULT_COMPRESSION  Compression strategy.  zlib.constants.Z_FILTERED zlib.constants.Z_HUFFMAN_ONLY zlib.constants.Z_RLE zlib.constants.Z_FIXED zlib.constants.Z_DEFAULT_STRATEGY"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_brotli_constants","title":"Brotli constants","description":"There are several options and other constants available for Brotli-based streams:"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_flush_operations","title":"Flush operations","description":"The following values are valid flush operations for Brotli-based streams:  zlib.constants.BROTLI_OPERATION_PROCESS (default for all operations) zlib.constants.BROTLI_OPERATION_FLUSH (default when calling .flush()) zlib.constants.BROTLI_OPERATION_FINISH (default for the last chunk) zlib.constants.BROTLI_OPERATION_EMIT_METADATA  This particular operation may be hard to use in a Node.js context, as the streaming layer makes it hard to know which data will end up in this frame. Also, there is currently no way to consume this data through the Node.js API."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_compressor_options","title":"Compressor options","description":"There are several options that can be set on Brotli encoders, affecting compression efficiency and speed. Both the keys and the values can be accessed as properties of the zlib.constants object. The most important options are:  BROTLI_PARAM_MODE  BROTLI_MODE_GENERIC (default) BROTLI_MODE_TEXT, adjusted for UTF-8 text BROTLI_MODE_FONT, adjusted for WOFF 2.0 fonts   BROTLI_PARAM_QUALITY  Ranges from BROTLI_MIN_QUALITY to BROTLI_MAX_QUALITY, with a default of BROTLI_DEFAULT_QUALITY.   BROTLI_PARAM_SIZE_HINT  Integer value representing the expected input size; defaults to 0 for an unknown input size.    The following flags can be set for advanced control over the compression algorithm and memory usage tuning:  BROTLI_PARAM_LGWIN  Ranges from BROTLI_MIN_WINDOW_BITS to BROTLI_MAX_WINDOW_BITS, with a default of BROTLI_DEFAULT_WINDOW, or up to BROTLI_LARGE_MAX_WINDOW_BITS if the BROTLI_PARAM_LARGE_WINDOW flag is set.   BROTLI_PARAM_LGBLOCK  Ranges from BROTLI_MIN_INPUT_BLOCK_BITS to BROTLI_MAX_INPUT_BLOCK_BITS.   BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING  Boolean flag that decreases compression ratio in favour of decompression speed.   BROTLI_PARAM_LARGE_WINDOW  Boolean flag enabling \u201cLarge Window Brotli\u201d mode (not compatible with the Brotli format as standardized in RFC 7932).   BROTLI_PARAM_NPOSTFIX  Ranges from 0 to BROTLI_MAX_NPOSTFIX.   BROTLI_PARAM_NDIRECT  Ranges from 0 to 15 << NPOSTFIX in steps of 1 << NPOSTFIX."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_decompressor_options","title":"Decompressor options","description":"These advanced options are available for controlling decompression:  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION  Boolean flag that affects internal memory allocation patterns.   BROTLI_DECODER_PARAM_LARGE_WINDOW  Boolean flag enabling \u201cLarge Window Brotli\u201d mode (not compatible with the Brotli format as standardized in RFC 7932)."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_options","title":"Class: `Options`","description":"Each zlib-based class takes an options object. No options are required. Some options are only relevant when compressing and are ignored by the decompression classes.  flush <integer> Default: zlib.constants.Z_NO_FLUSH finishFlush <integer> Default: zlib.constants.Z_FINISH chunkSize <integer> Default: 16 * 1024 windowBits <integer> level <integer> (compression only) memLevel <integer> (compression only) strategy <integer> (compression only) dictionary <Buffer> | <TypedArray> | <DataView> | <ArrayBuffer> (deflate\/inflate only, empty dictionary by default) info <boolean> (If true, returns an object with buffer and engine.) maxOutputLength <integer> Limits output size when using convenience methods. Default: buffer.kMaxLength  See the deflateInit2 and inflateInit2 documentation for more information."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_class_brotlioptions","title":"Class: `BrotliOptions`","description":"Each Brotli-based class takes an options object. All options are optional.  flush <integer> Default: zlib.constants.BROTLI_OPERATION_PROCESS finishFlush <integer> Default: zlib.constants.BROTLI_OPERATION_FINISH chunkSize <integer> Default: 16 * 1024 params <Object> Key-value object containing indexed Brotli parameters. maxOutputLength <integer> Limits output size when using convenience methods. Default: buffer.kMaxLength  For example: const stream = zlib.createBrotliCompress({   chunkSize: 32 * 1024,   params: {     [zlib.constants.BROTLI_PARAM_MODE]: zlib.constants.BROTLI_MODE_TEXT,     [zlib.constants.BROTLI_PARAM_QUALITY]: 4,     [zlib.constants.BROTLI_PARAM_SIZE_HINT]: fs.statSync(inputFile).size   } });"},{"url":"http:\/\/nodejs.org\/api\/all.html#all_convenience_methods","title":"Convenience methods","description":"All of these take a Buffer, TypedArray, DataView, ArrayBuffer or string as the first argument, an optional second argument to supply options to the zlib classes and will call the supplied callback with callback(error, result). Every method has a *Sync counterpart, which accept the same arguments, but without a callback."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlicompress_buffer_options_callback","title":"`zlib.brotliCompress(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlicompresssync_buffer_options","title":"`zlib.brotliCompressSync(buffer[, options])`","description":"Compress a chunk of data with BrotliCompress."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlidecompress_buffer_options_callback","title":"`zlib.brotliDecompress(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_brotlidecompresssync_buffer_options","title":"`zlib.brotliDecompressSync(buffer[, options])`","description":"Decompress a chunk of data with BrotliDecompress."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflate_buffer_options_callback","title":"`zlib.deflate(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflatesync_buffer_options","title":"`zlib.deflateSync(buffer[, options])`","description":"Compress a chunk of data with Deflate."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflateraw_buffer_options_callback","title":"`zlib.deflateRaw(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_deflaterawsync_buffer_options","title":"`zlib.deflateRawSync(buffer[, options])`","description":"Compress a chunk of data with DeflateRaw."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gunzip_buffer_options_callback","title":"`zlib.gunzip(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gunzipsync_buffer_options","title":"`zlib.gunzipSync(buffer[, options])`","description":"Decompress a chunk of data with Gunzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gzip_buffer_options_callback","title":"`zlib.gzip(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_gzipsync_buffer_options","title":"`zlib.gzipSync(buffer[, options])`","description":"Compress a chunk of data with Gzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflate_buffer_options_callback","title":"`zlib.inflate(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflatesync_buffer_options","title":"`zlib.inflateSync(buffer[, options])`","description":"Decompress a chunk of data with Inflate."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflateraw_buffer_options_callback","title":"`zlib.inflateRaw(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_inflaterawsync_buffer_options","title":"`zlib.inflateRawSync(buffer[, options])`","description":"Decompress a chunk of data with InflateRaw."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_unzip_buffer_options_callback","title":"`zlib.unzip(buffer[, options], callback)`","description":""},{"url":"http:\/\/nodejs.org\/api\/all.html#all_zlib_unzipsync_buffer_options","title":"`zlib.unzipSync(buffer[, options])`","description":"Decompress a chunk of data with Unzip."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_threadpool_usage_and_performance_considerations","title":"Threadpool usage and performance considerations","description":"All zlib APIs, except those that are explicitly synchronous, use the Node.js internal threadpool. This can lead to surprising effects and performance limitations in some applications. Creating and using a large number of zlib objects simultaneously can cause significant memory fragmentation. const zlib = require('zlib');  const payload = Buffer.from('This is some data');  \/\/ WARNING: DO NOT DO THIS! for (let i = 0; i < 30000; ++i) {   zlib.deflate(payload, (err, buffer) => {}); }  In the preceding example, 30,000 deflate instances are created concurrently. Because of how some operating systems handle memory allocation and deallocation, this may lead to to significant memory fragmentation. It is strongly recommended that the results of compression operations be cached to avoid duplication of effort."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_compressing_http_requests_and_responses","title":"Compressing HTTP requests and responses","description":"The zlib module can be used to implement support for the gzip, deflate and br content-encoding mechanisms defined by HTTP. The HTTP Accept-Encoding header is used within an http request to identify the compression encodings accepted by the client. The Content-Encoding header is used to identify the compression encodings actually applied to a message. The examples given below are drastically simplified to show the basic concept. Using zlib encoding can be expensive, and the results ought to be cached. See Memory usage tuning for more information on the speed\/memory\/compression tradeoffs involved in zlib usage. \/\/ Client request example const zlib = require('zlib'); const http = require('http'); const fs = require('fs'); const { pipeline } = require('stream');  const request = http.get({ host: 'example.com',                            path: '\/',                            port: 80,                            headers: { 'Accept-Encoding': 'br,gzip,deflate' } }); request.on('response', (response) => {   const output = fs.createWriteStream('example.com_index.html');    const onError = (err) => {     if (err) {       console.error('An error occurred:', err);       process.exitCode = 1;     }   };    switch (response.headers['content-encoding']) {     case 'br':       pipeline(response, zlib.createBrotliDecompress(), output, onError);       break;     \/\/ Or, just use zlib.createUnzip() to handle both of the following cases:     case 'gzip':       pipeline(response, zlib.createGunzip(), output, onError);       break;     case 'deflate':       pipeline(response, zlib.createInflate(), output, onError);       break;     default:       pipeline(response, output, onError);       break;   } });  \/\/ server example \/\/ Running a gzip operation on every request is quite expensive. \/\/ It would be much more efficient to cache the compressed buffer. const zlib = require('zlib'); const http = require('http'); const fs = require('fs'); const { pipeline } = require('stream');  http.createServer((request, response) => {   const raw = fs.createReadStream('index.html');   \/\/ Store both a compressed and an uncompressed version of the resource.   response.setHeader('Vary', 'Accept-Encoding');   let acceptEncoding = request.headers['accept-encoding'];   if (!acceptEncoding) {     acceptEncoding = '';   }    const onError = (err) => {     if (err) {       \/\/ If an error occurs, there's not much we can do because       \/\/ the server has already sent the 200 response code and       \/\/ some amount of data has already been sent to the client.       \/\/ The best we can do is terminate the response immediately       \/\/ and log the error.       response.end();       console.error('An error occurred:', err);     }   };    \/\/ Note: This is not a conformant accept-encoding parser.   \/\/ See https:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec14.html#sec14.3   if (\/\\bdeflate\\b\/.test(acceptEncoding)) {     response.writeHead(200, { 'Content-Encoding': 'deflate' });     pipeline(raw, zlib.createDeflate(), response, onError);   } else if (\/\\bgzip\\b\/.test(acceptEncoding)) {     response.writeHead(200, { 'Content-Encoding': 'gzip' });     pipeline(raw, zlib.createGzip(), response, onError);   } else if (\/\\bbr\\b\/.test(acceptEncoding)) {     response.writeHead(200, { 'Content-Encoding': 'br' });     pipeline(raw, zlib.createBrotliCompress(), response, onError);   } else {     response.writeHead(200, {});     pipeline(raw, response, onError);   } }).listen(1337);  By default, the zlib methods will throw an error when decompressing truncated data. However, if it is known that the data is incomplete, or the desire is to inspect only the beginning of a compressed file, it is possible to suppress the default error handling by changing the flushing method that is used to decompress the last chunk of input data: \/\/ This is a truncated version of the buffer from the above examples const buffer = Buffer.from('eJzT0yMA', 'base64');  zlib.unzip(   buffer,   \/\/ For Brotli, the equivalent is zlib.constants.BROTLI_OPERATION_FLUSH.   { finishFlush: zlib.constants.Z_SYNC_FLUSH },   (err, buffer) => {     if (err) {       console.error('An error occurred:', err);       process.exitCode = 1;     }     console.log(buffer.toString());   });  This will not change the behavior in other error-throwing situations, e.g. when the input data has an invalid format. Using this method, it will not be possible to determine whether the input ended prematurely or lacks the integrity checks, making it necessary to manually check that the decompressed result is valid."},{"url":"http:\/\/nodejs.org\/api\/all.html#all_flushing","title":"Flushing","description":"Calling .flush() on a compression stream will make zlib return as much output as currently possible. This may come at the cost of degraded compression quality, but can be useful when data needs to be available as soon as possible. In the following example, flush() is used to write a compressed partial HTTP response to the client: const zlib = require('zlib'); const http = require('http'); const { pipeline } = require('stream');  http.createServer((request, response) => {   \/\/ For the sake of simplicity, the Accept-Encoding checks are omitted.   response.writeHead(200, { 'content-encoding': 'gzip' });   const output = zlib.createGzip();   let i;    pipeline(output, response, (err) => {     if (err) {       \/\/ If an error occurs, there's not much we can do because       \/\/ the server has already sent the 200 response code and       \/\/ some amount of data has already been sent to the client.       \/\/ The best we can do is terminate the response immediately       \/\/ and log the error.       clearInterval(i);       response.end();       console.error('An error occurred:', err);     }   });    i = setInterval(() => {     output.write(`The current time is ${Date()}\\n`, () => {       \/\/ The data has been passed to zlib, but the compression algorithm may       \/\/ have decided to buffer the data for more efficient compression.       \/\/ Calling .flush() will make the data available as soon as the client       \/\/ is ready to receive it.       output.flush();     });   }, 1000); }).listen(1337);"}]